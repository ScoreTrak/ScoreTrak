// Code generated by ogen, DO NOT EDIT.

package ogent

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *ApiTokenCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApiTokenCreate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("token")
		e.Str(s.Token)
	}
	{

		e.FieldStart("role_id")
		e.Str(s.RoleID)
	}
	{

		e.FieldStart("expired_at")
		json.EncodeDateTime(e, s.ExpiredAt)
	}
	{

		e.FieldStart("user_id")
		e.Str(s.UserID)
	}
}

var jsonFieldsNameOfApiTokenCreate = [7]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "token",
	4: "role_id",
	5: "expired_at",
	6: "user_id",
}

// Decode decodes ApiTokenCreate from json.
func (s *ApiTokenCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApiTokenCreate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "token":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "role_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.RoleID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role_id\"")
			}
		case "expired_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpiredAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expired_at\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.UserID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApiTokenCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApiTokenCreate) {
					name = jsonFieldsNameOfApiTokenCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApiTokenCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApiTokenCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApiTokenList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApiTokenList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("token")
		e.Str(s.Token)
	}
	{

		e.FieldStart("role_id")
		e.Str(s.RoleID)
	}
	{

		e.FieldStart("expired_at")
		json.EncodeDateTime(e, s.ExpiredAt)
	}
	{

		e.FieldStart("user_id")
		e.Str(s.UserID)
	}
}

var jsonFieldsNameOfApiTokenList = [7]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "token",
	4: "role_id",
	5: "expired_at",
	6: "user_id",
}

// Decode decodes ApiTokenList from json.
func (s *ApiTokenList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApiTokenList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "token":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "role_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.RoleID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role_id\"")
			}
		case "expired_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpiredAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expired_at\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.UserID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApiTokenList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApiTokenList) {
					name = jsonFieldsNameOfApiTokenList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApiTokenList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApiTokenList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApiTokenRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApiTokenRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("token")
		e.Str(s.Token)
	}
	{

		e.FieldStart("role_id")
		e.Str(s.RoleID)
	}
	{

		e.FieldStart("expired_at")
		json.EncodeDateTime(e, s.ExpiredAt)
	}
	{

		e.FieldStart("user_id")
		e.Str(s.UserID)
	}
}

var jsonFieldsNameOfApiTokenRead = [7]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "token",
	4: "role_id",
	5: "expired_at",
	6: "user_id",
}

// Decode decodes ApiTokenRead from json.
func (s *ApiTokenRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApiTokenRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "token":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "role_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.RoleID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role_id\"")
			}
		case "expired_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpiredAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expired_at\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.UserID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApiTokenRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApiTokenRead) {
					name = jsonFieldsNameOfApiTokenRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApiTokenRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApiTokenRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApiTokenUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApiTokenUpdate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("token")
		e.Str(s.Token)
	}
	{

		e.FieldStart("role_id")
		e.Str(s.RoleID)
	}
	{

		e.FieldStart("expired_at")
		json.EncodeDateTime(e, s.ExpiredAt)
	}
	{

		e.FieldStart("user_id")
		e.Str(s.UserID)
	}
}

var jsonFieldsNameOfApiTokenUpdate = [7]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "token",
	4: "role_id",
	5: "expired_at",
	6: "user_id",
}

// Decode decodes ApiTokenUpdate from json.
func (s *ApiTokenUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApiTokenUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "token":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "role_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.RoleID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role_id\"")
			}
		case "expired_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpiredAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expired_at\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.UserID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApiTokenUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfApiTokenUpdate) {
					name = jsonFieldsNameOfApiTokenUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApiTokenUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApiTokenUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CheckCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CheckCreate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Log.Set {
			e.FieldStart("log")
			s.Log.Encode(e)
		}
	}
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{

		e.FieldStart("passed")
		e.Bool(s.Passed)
	}
	{

		e.FieldStart("round_id")
		e.Str(s.RoundID)
	}
	{

		e.FieldStart("host_service_id")
		e.Str(s.HostServiceID)
	}
}

var jsonFieldsNameOfCheckCreate = [8]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "log",
	4: "error",
	5: "passed",
	6: "round_id",
	7: "host_service_id",
}

// Decode decodes CheckCreate from json.
func (s *CheckCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckCreate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "log":
			if err := func() error {
				s.Log.Reset()
				if err := s.Log.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"log\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "passed":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Passed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passed\"")
			}
		case "round_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.RoundID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_id\"")
			}
		case "host_service_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.HostServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_service_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11100001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCheckCreate) {
					name = jsonFieldsNameOfCheckCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CheckCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CheckHostserviceRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CheckHostserviceRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("service_id")
		e.Str(s.ServiceID)
	}
	{

		e.FieldStart("host_id")
		e.Str(s.HostID)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
}

var jsonFieldsNameOfCheckHostserviceRead = [10]string{
	0: "id",
	1: "name",
	2: "display_name",
	3: "pause",
	4: "hidden",
	5: "create_time",
	6: "update_time",
	7: "service_id",
	8: "host_id",
	9: "team_id",
}

// Decode decodes CheckHostserviceRead from json.
func (s *CheckHostserviceRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckHostserviceRead to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "service_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_id\"")
			}
		case "host_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.HostID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_id\"")
			}
		case "team_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckHostserviceRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCheckHostserviceRead) {
					name = jsonFieldsNameOfCheckHostserviceRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CheckHostserviceRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckHostserviceRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CheckList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CheckList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Log.Set {
			e.FieldStart("log")
			s.Log.Encode(e)
		}
	}
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{

		e.FieldStart("passed")
		e.Bool(s.Passed)
	}
	{

		e.FieldStart("round_id")
		e.Str(s.RoundID)
	}
	{

		e.FieldStart("host_service_id")
		e.Str(s.HostServiceID)
	}
}

var jsonFieldsNameOfCheckList = [8]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "log",
	4: "error",
	5: "passed",
	6: "round_id",
	7: "host_service_id",
}

// Decode decodes CheckList from json.
func (s *CheckList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "log":
			if err := func() error {
				s.Log.Reset()
				if err := s.Log.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"log\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "passed":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Passed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passed\"")
			}
		case "round_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.RoundID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_id\"")
			}
		case "host_service_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.HostServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_service_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11100001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCheckList) {
					name = jsonFieldsNameOfCheckList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CheckList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CheckRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CheckRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Log.Set {
			e.FieldStart("log")
			s.Log.Encode(e)
		}
	}
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{

		e.FieldStart("passed")
		e.Bool(s.Passed)
	}
	{

		e.FieldStart("round_id")
		e.Str(s.RoundID)
	}
	{

		e.FieldStart("host_service_id")
		e.Str(s.HostServiceID)
	}
}

var jsonFieldsNameOfCheckRead = [8]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "log",
	4: "error",
	5: "passed",
	6: "round_id",
	7: "host_service_id",
}

// Decode decodes CheckRead from json.
func (s *CheckRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "log":
			if err := func() error {
				s.Log.Reset()
				if err := s.Log.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"log\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "passed":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Passed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passed\"")
			}
		case "round_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.RoundID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_id\"")
			}
		case "host_service_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.HostServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_service_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11100001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCheckRead) {
					name = jsonFieldsNameOfCheckRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CheckRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CheckRoundRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CheckRoundRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("round_number")
		e.Int(s.RoundNumber)
	}
	{
		if s.NumOfIntendedChecks.Set {
			e.FieldStart("num_of_intended_checks")
			s.NumOfIntendedChecks.Encode(e)
		}
	}
	{

		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{

		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		if s.FinishedAt.Set {
			e.FieldStart("finished_at")
			s.FinishedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfCheckRoundRead = [8]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "round_number",
	4: "num_of_intended_checks",
	5: "status",
	6: "started_at",
	7: "finished_at",
}

// Decode decodes CheckRoundRead from json.
func (s *CheckRoundRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckRoundRead to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "round_number":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.RoundNumber = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_number\"")
			}
		case "num_of_intended_checks":
			if err := func() error {
				s.NumOfIntendedChecks.Reset()
				if err := s.NumOfIntendedChecks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"num_of_intended_checks\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "finished_at":
			if err := func() error {
				s.FinishedAt.Reset()
				if err := s.FinishedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finished_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckRoundRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01101001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCheckRoundRead) {
					name = jsonFieldsNameOfCheckRoundRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CheckRoundRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckRoundRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CheckRoundReadStatus as json.
func (s CheckRoundReadStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CheckRoundReadStatus from json.
func (s *CheckRoundReadStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckRoundReadStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CheckRoundReadStatus(v) {
	case CheckRoundReadStatusStarted:
		*s = CheckRoundReadStatusStarted
	case CheckRoundReadStatusOngoing:
		*s = CheckRoundReadStatusOngoing
	case CheckRoundReadStatusFinished:
		*s = CheckRoundReadStatusFinished
	case CheckRoundReadStatusIncomplete:
		*s = CheckRoundReadStatusIncomplete
	default:
		*s = CheckRoundReadStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CheckRoundReadStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckRoundReadStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CheckUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CheckUpdate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Log.Set {
			e.FieldStart("log")
			s.Log.Encode(e)
		}
	}
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{

		e.FieldStart("passed")
		e.Bool(s.Passed)
	}
	{

		e.FieldStart("round_id")
		e.Str(s.RoundID)
	}
	{

		e.FieldStart("host_service_id")
		e.Str(s.HostServiceID)
	}
}

var jsonFieldsNameOfCheckUpdate = [8]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "log",
	4: "error",
	5: "passed",
	6: "round_id",
	7: "host_service_id",
}

// Decode decodes CheckUpdate from json.
func (s *CheckUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CheckUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "log":
			if err := func() error {
				s.Log.Reset()
				if err := s.Log.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"log\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "passed":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Passed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passed\"")
			}
		case "round_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.RoundID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_id\"")
			}
		case "host_service_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.HostServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_service_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CheckUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11100001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCheckUpdate) {
					name = jsonFieldsNameOfCheckUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CheckUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CheckUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CompetitionCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CompetitionCreate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.RoundDuration.Set {
			e.FieldStart("round_duration")
			s.RoundDuration.Encode(e)
		}
	}
	{
		if s.CurrentRoundID.Set {
			e.FieldStart("current_round_id")
			s.CurrentRoundID.Encode(e)
		}
	}
	{
		if s.ViewableToPublic.Set {
			e.FieldStart("viewable_to_public")
			s.ViewableToPublic.Encode(e)
		}
	}
	{
		if s.IgnoreIncompleteRoundInScoring.Set {
			e.FieldStart("ignore_incomplete_round_in_scoring")
			s.IgnoreIncompleteRoundInScoring.Encode(e)
		}
	}
	{
		if s.ToBeStartedAt.Set {
			e.FieldStart("to_be_started_at")
			s.ToBeStartedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.StartedAt.Set {
			e.FieldStart("started_at")
			s.StartedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.FinishedAt.Set {
			e.FieldStart("finished_at")
			s.FinishedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfCompetitionCreate = [13]string{
	0:  "id",
	1:  "pause",
	2:  "create_time",
	3:  "update_time",
	4:  "name",
	5:  "display_name",
	6:  "round_duration",
	7:  "current_round_id",
	8:  "viewable_to_public",
	9:  "ignore_incomplete_round_in_scoring",
	10: "to_be_started_at",
	11: "started_at",
	12: "finished_at",
}

// Decode decodes CompetitionCreate from json.
func (s *CompetitionCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompetitionCreate to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "round_duration":
			if err := func() error {
				s.RoundDuration.Reset()
				if err := s.RoundDuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_duration\"")
			}
		case "current_round_id":
			if err := func() error {
				s.CurrentRoundID.Reset()
				if err := s.CurrentRoundID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_round_id\"")
			}
		case "viewable_to_public":
			if err := func() error {
				s.ViewableToPublic.Reset()
				if err := s.ViewableToPublic.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewable_to_public\"")
			}
		case "ignore_incomplete_round_in_scoring":
			if err := func() error {
				s.IgnoreIncompleteRoundInScoring.Reset()
				if err := s.IgnoreIncompleteRoundInScoring.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ignore_incomplete_round_in_scoring\"")
			}
		case "to_be_started_at":
			if err := func() error {
				s.ToBeStartedAt.Reset()
				if err := s.ToBeStartedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to_be_started_at\"")
			}
		case "started_at":
			if err := func() error {
				s.StartedAt.Reset()
				if err := s.StartedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "finished_at":
			if err := func() error {
				s.FinishedAt.Reset()
				if err := s.FinishedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finished_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CompetitionCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00110001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCompetitionCreate) {
					name = jsonFieldsNameOfCompetitionCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompetitionCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompetitionCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CompetitionRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CompetitionRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.RoundDuration.Set {
			e.FieldStart("round_duration")
			s.RoundDuration.Encode(e)
		}
	}
	{
		if s.CurrentRoundID.Set {
			e.FieldStart("current_round_id")
			s.CurrentRoundID.Encode(e)
		}
	}
	{
		if s.ViewableToPublic.Set {
			e.FieldStart("viewable_to_public")
			s.ViewableToPublic.Encode(e)
		}
	}
	{
		if s.IgnoreIncompleteRoundInScoring.Set {
			e.FieldStart("ignore_incomplete_round_in_scoring")
			s.IgnoreIncompleteRoundInScoring.Encode(e)
		}
	}
	{
		if s.ToBeStartedAt.Set {
			e.FieldStart("to_be_started_at")
			s.ToBeStartedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.StartedAt.Set {
			e.FieldStart("started_at")
			s.StartedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.FinishedAt.Set {
			e.FieldStart("finished_at")
			s.FinishedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfCompetitionRead = [13]string{
	0:  "id",
	1:  "pause",
	2:  "create_time",
	3:  "update_time",
	4:  "name",
	5:  "display_name",
	6:  "round_duration",
	7:  "current_round_id",
	8:  "viewable_to_public",
	9:  "ignore_incomplete_round_in_scoring",
	10: "to_be_started_at",
	11: "started_at",
	12: "finished_at",
}

// Decode decodes CompetitionRead from json.
func (s *CompetitionRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompetitionRead to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "round_duration":
			if err := func() error {
				s.RoundDuration.Reset()
				if err := s.RoundDuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_duration\"")
			}
		case "current_round_id":
			if err := func() error {
				s.CurrentRoundID.Reset()
				if err := s.CurrentRoundID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_round_id\"")
			}
		case "viewable_to_public":
			if err := func() error {
				s.ViewableToPublic.Reset()
				if err := s.ViewableToPublic.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewable_to_public\"")
			}
		case "ignore_incomplete_round_in_scoring":
			if err := func() error {
				s.IgnoreIncompleteRoundInScoring.Reset()
				if err := s.IgnoreIncompleteRoundInScoring.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ignore_incomplete_round_in_scoring\"")
			}
		case "to_be_started_at":
			if err := func() error {
				s.ToBeStartedAt.Reset()
				if err := s.ToBeStartedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to_be_started_at\"")
			}
		case "started_at":
			if err := func() error {
				s.StartedAt.Reset()
				if err := s.StartedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "finished_at":
			if err := func() error {
				s.FinishedAt.Reset()
				if err := s.FinishedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finished_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CompetitionRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00110001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCompetitionRead) {
					name = jsonFieldsNameOfCompetitionRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompetitionRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompetitionRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CompetitionUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CompetitionUpdate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.RoundDuration.Set {
			e.FieldStart("round_duration")
			s.RoundDuration.Encode(e)
		}
	}
	{
		if s.CurrentRoundID.Set {
			e.FieldStart("current_round_id")
			s.CurrentRoundID.Encode(e)
		}
	}
	{
		if s.ViewableToPublic.Set {
			e.FieldStart("viewable_to_public")
			s.ViewableToPublic.Encode(e)
		}
	}
	{
		if s.IgnoreIncompleteRoundInScoring.Set {
			e.FieldStart("ignore_incomplete_round_in_scoring")
			s.IgnoreIncompleteRoundInScoring.Encode(e)
		}
	}
	{
		if s.ToBeStartedAt.Set {
			e.FieldStart("to_be_started_at")
			s.ToBeStartedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.StartedAt.Set {
			e.FieldStart("started_at")
			s.StartedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.FinishedAt.Set {
			e.FieldStart("finished_at")
			s.FinishedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfCompetitionUpdate = [13]string{
	0:  "id",
	1:  "pause",
	2:  "create_time",
	3:  "update_time",
	4:  "name",
	5:  "display_name",
	6:  "round_duration",
	7:  "current_round_id",
	8:  "viewable_to_public",
	9:  "ignore_incomplete_round_in_scoring",
	10: "to_be_started_at",
	11: "started_at",
	12: "finished_at",
}

// Decode decodes CompetitionUpdate from json.
func (s *CompetitionUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CompetitionUpdate to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "round_duration":
			if err := func() error {
				s.RoundDuration.Reset()
				if err := s.RoundDuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_duration\"")
			}
		case "current_round_id":
			if err := func() error {
				s.CurrentRoundID.Reset()
				if err := s.CurrentRoundID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_round_id\"")
			}
		case "viewable_to_public":
			if err := func() error {
				s.ViewableToPublic.Reset()
				if err := s.ViewableToPublic.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewable_to_public\"")
			}
		case "ignore_incomplete_round_in_scoring":
			if err := func() error {
				s.IgnoreIncompleteRoundInScoring.Reset()
				if err := s.IgnoreIncompleteRoundInScoring.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ignore_incomplete_round_in_scoring\"")
			}
		case "to_be_started_at":
			if err := func() error {
				s.ToBeStartedAt.Reset()
				if err := s.ToBeStartedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to_be_started_at\"")
			}
		case "started_at":
			if err := func() error {
				s.StartedAt.Reset()
				if err := s.StartedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "finished_at":
			if err := func() error {
				s.FinishedAt.Reset()
				if err := s.FinishedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finished_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CompetitionUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00110001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCompetitionUpdate) {
					name = jsonFieldsNameOfCompetitionUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CompetitionUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CompetitionUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateApiTokenReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateApiTokenReq) encodeFields(e *jx.Encoder) {
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("token")
		e.Str(s.Token)
	}
	{

		e.FieldStart("role_id")
		e.Str(s.RoleID)
	}
	{

		e.FieldStart("expired_at")
		json.EncodeDateTime(e, s.ExpiredAt)
	}
	{

		e.FieldStart("user_id")
		e.Str(s.UserID)
	}
}

var jsonFieldsNameOfCreateApiTokenReq = [6]string{
	0: "create_time",
	1: "update_time",
	2: "token",
	3: "role_id",
	4: "expired_at",
	5: "user_id",
}

// Decode decodes CreateApiTokenReq from json.
func (s *CreateApiTokenReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateApiTokenReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "token":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "role_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.RoleID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role_id\"")
			}
		case "expired_at":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpiredAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expired_at\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.UserID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateApiTokenReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateApiTokenReq) {
					name = jsonFieldsNameOfCreateApiTokenReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateApiTokenReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateApiTokenReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateCheckReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateCheckReq) encodeFields(e *jx.Encoder) {
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Log.Set {
			e.FieldStart("log")
			s.Log.Encode(e)
		}
	}
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{

		e.FieldStart("passed")
		e.Bool(s.Passed)
	}
	{

		e.FieldStart("round_id")
		e.Str(s.RoundID)
	}
	{

		e.FieldStart("host_service_id")
		e.Str(s.HostServiceID)
	}
	{

		e.FieldStart("round")
		e.Str(s.Round)
	}
	{

		e.FieldStart("hostservice")
		e.Str(s.Hostservice)
	}
}

var jsonFieldsNameOfCreateCheckReq = [9]string{
	0: "create_time",
	1: "update_time",
	2: "log",
	3: "error",
	4: "passed",
	5: "round_id",
	6: "host_service_id",
	7: "round",
	8: "hostservice",
}

// Decode decodes CreateCheckReq from json.
func (s *CreateCheckReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateCheckReq to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "log":
			if err := func() error {
				s.Log.Reset()
				if err := s.Log.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"log\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "passed":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Passed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passed\"")
			}
		case "round_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.RoundID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_id\"")
			}
		case "host_service_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.HostServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_service_id\"")
			}
		case "round":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Round = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round\"")
			}
		case "hostservice":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Hostservice = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostservice\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateCheckReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11110000,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateCheckReq) {
					name = jsonFieldsNameOfCreateCheckReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateCheckReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateCheckReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateCompetitionReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateCompetitionReq) encodeFields(e *jx.Encoder) {
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.RoundDuration.Set {
			e.FieldStart("round_duration")
			s.RoundDuration.Encode(e)
		}
	}
	{
		if s.CurrentRoundID.Set {
			e.FieldStart("current_round_id")
			s.CurrentRoundID.Encode(e)
		}
	}
	{
		if s.ViewableToPublic.Set {
			e.FieldStart("viewable_to_public")
			s.ViewableToPublic.Encode(e)
		}
	}
	{
		if s.IgnoreIncompleteRoundInScoring.Set {
			e.FieldStart("ignore_incomplete_round_in_scoring")
			s.IgnoreIncompleteRoundInScoring.Encode(e)
		}
	}
	{
		if s.ToBeStartedAt.Set {
			e.FieldStart("to_be_started_at")
			s.ToBeStartedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.StartedAt.Set {
			e.FieldStart("started_at")
			s.StartedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.FinishedAt.Set {
			e.FieldStart("finished_at")
			s.FinishedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfCreateCompetitionReq = [12]string{
	0:  "pause",
	1:  "create_time",
	2:  "update_time",
	3:  "name",
	4:  "display_name",
	5:  "round_duration",
	6:  "current_round_id",
	7:  "viewable_to_public",
	8:  "ignore_incomplete_round_in_scoring",
	9:  "to_be_started_at",
	10: "started_at",
	11: "finished_at",
}

// Decode decodes CreateCompetitionReq from json.
func (s *CreateCompetitionReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateCompetitionReq to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "round_duration":
			if err := func() error {
				s.RoundDuration.Reset()
				if err := s.RoundDuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_duration\"")
			}
		case "current_round_id":
			if err := func() error {
				s.CurrentRoundID.Reset()
				if err := s.CurrentRoundID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_round_id\"")
			}
		case "viewable_to_public":
			if err := func() error {
				s.ViewableToPublic.Reset()
				if err := s.ViewableToPublic.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewable_to_public\"")
			}
		case "ignore_incomplete_round_in_scoring":
			if err := func() error {
				s.IgnoreIncompleteRoundInScoring.Reset()
				if err := s.IgnoreIncompleteRoundInScoring.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ignore_incomplete_round_in_scoring\"")
			}
		case "to_be_started_at":
			if err := func() error {
				s.ToBeStartedAt.Reset()
				if err := s.ToBeStartedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to_be_started_at\"")
			}
		case "started_at":
			if err := func() error {
				s.StartedAt.Reset()
				if err := s.StartedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "finished_at":
			if err := func() error {
				s.FinishedAt.Reset()
				if err := s.FinishedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finished_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateCompetitionReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateCompetitionReq) {
					name = jsonFieldsNameOfCreateCompetitionReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateCompetitionReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateCompetitionReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateHostReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateHostReq) encodeFields(e *jx.Encoder) {
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("address")
		e.Str(s.Address)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
	{
		if s.Hostservices != nil {
			e.FieldStart("hostservices")
			e.ArrStart()
			for _, elem := range s.Hostservices {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{

		e.FieldStart("team")
		e.Str(s.Team)
	}
}

var jsonFieldsNameOfCreateHostReq = [8]string{
	0: "pause",
	1: "hidden",
	2: "create_time",
	3: "update_time",
	4: "address",
	5: "team_id",
	6: "hostservices",
	7: "team",
}

// Decode decodes CreateHostReq from json.
func (s *CreateHostReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateHostReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "team_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		case "hostservices":
			if err := func() error {
				s.Hostservices = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Hostservices = append(s.Hostservices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostservices\"")
			}
		case "team":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Team = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateHostReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b10110000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateHostReq) {
					name = jsonFieldsNameOfCreateHostReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateHostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateHostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateHostServiceReportReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateHostServiceReportReq) encodeFields(e *jx.Encoder) {
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("points")
		e.Int(s.Points)
	}
	{

		e.FieldStart("passing")
		e.Bool(s.Passing)
	}
	{

		e.FieldStart("latest_check_time")
		json.EncodeDateTime(e, s.LatestCheckTime)
	}
	{

		e.FieldStart("host_service_id")
		e.Str(s.HostServiceID)
	}
	{

		e.FieldStart("service_id")
		e.Str(s.ServiceID)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
	{
		if s.TeamReportID.Set {
			e.FieldStart("team_report_id")
			s.TeamReportID.Encode(e)
		}
	}
	{

		e.FieldStart("hostservice")
		e.Str(s.Hostservice)
	}
	{

		e.FieldStart("service")
		e.Str(s.Service)
	}
	{

		e.FieldStart("team")
		e.Str(s.Team)
	}
	{
		if s.Teamreport.Set {
			e.FieldStart("teamreport")
			s.Teamreport.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateHostServiceReportReq = [13]string{
	0:  "create_time",
	1:  "update_time",
	2:  "points",
	3:  "passing",
	4:  "latest_check_time",
	5:  "host_service_id",
	6:  "service_id",
	7:  "team_id",
	8:  "team_report_id",
	9:  "hostservice",
	10: "service",
	11: "team",
	12: "teamreport",
}

// Decode decodes CreateHostServiceReportReq from json.
func (s *CreateHostServiceReportReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateHostServiceReportReq to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "points":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Points = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		case "passing":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Passing = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passing\"")
			}
		case "latest_check_time":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.LatestCheckTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latest_check_time\"")
			}
		case "host_service_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.HostServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_service_id\"")
			}
		case "service_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_id\"")
			}
		case "team_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		case "team_report_id":
			if err := func() error {
				s.TeamReportID.Reset()
				if err := s.TeamReportID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_report_id\"")
			}
		case "hostservice":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Hostservice = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostservice\"")
			}
		case "service":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Service = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service\"")
			}
		case "team":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Team = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team\"")
			}
		case "teamreport":
			if err := func() error {
				s.Teamreport.Reset()
				if err := s.Teamreport.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamreport\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateHostServiceReportReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111100,
		0b00001110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateHostServiceReportReq) {
					name = jsonFieldsNameOfCreateHostServiceReportReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateHostServiceReportReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateHostServiceReportReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateHostServiceReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateHostServiceReq) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("service_id")
		e.Str(s.ServiceID)
	}
	{

		e.FieldStart("host_id")
		e.Str(s.HostID)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
	{
		if s.Checks != nil {
			e.FieldStart("checks")
			e.ArrStart()
			for _, elem := range s.Checks {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Properties != nil {
			e.FieldStart("properties")
			e.ArrStart()
			for _, elem := range s.Properties {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Hostservicereport.Set {
			e.FieldStart("hostservicereport")
			s.Hostservicereport.Encode(e)
		}
	}
	{

		e.FieldStart("service")
		e.Str(s.Service)
	}
	{

		e.FieldStart("host")
		e.Str(s.Host)
	}
	{

		e.FieldStart("team")
		e.Str(s.Team)
	}
}

var jsonFieldsNameOfCreateHostServiceReq = [15]string{
	0:  "name",
	1:  "display_name",
	2:  "pause",
	3:  "hidden",
	4:  "create_time",
	5:  "update_time",
	6:  "service_id",
	7:  "host_id",
	8:  "team_id",
	9:  "checks",
	10: "properties",
	11: "hostservicereport",
	12: "service",
	13: "host",
	14: "team",
}

// Decode decodes CreateHostServiceReq from json.
func (s *CreateHostServiceReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateHostServiceReq to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "service_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_id\"")
			}
		case "host_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.HostID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_id\"")
			}
		case "team_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		case "checks":
			if err := func() error {
				s.Checks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Checks = append(s.Checks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checks\"")
			}
		case "properties":
			if err := func() error {
				s.Properties = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Properties = append(s.Properties, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"properties\"")
			}
		case "hostservicereport":
			if err := func() error {
				s.Hostservicereport.Reset()
				if err := s.Hostservicereport.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostservicereport\"")
			}
		case "service":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Service = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service\"")
			}
		case "host":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Host = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "team":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Team = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateHostServiceReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11000011,
		0b01110001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateHostServiceReq) {
					name = jsonFieldsNameOfCreateHostServiceReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateHostServiceReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateHostServiceReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreatePropertyReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreatePropertyReq) encodeFields(e *jx.Encoder) {
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("key")
		e.Str(s.Key)
	}
	{

		e.FieldStart("value")
		e.Str(s.Value)
	}
	{

		e.FieldStart("host_service_id")
		e.Str(s.HostServiceID)
	}
	{

		e.FieldStart("hostservice")
		e.Str(s.Hostservice)
	}
}

var jsonFieldsNameOfCreatePropertyReq = [6]string{
	0: "create_time",
	1: "update_time",
	2: "key",
	3: "value",
	4: "host_service_id",
	5: "hostservice",
}

// Decode decodes CreatePropertyReq from json.
func (s *CreatePropertyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreatePropertyReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "host_service_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.HostServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_service_id\"")
			}
		case "hostservice":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Hostservice = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostservice\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreatePropertyReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreatePropertyReq) {
					name = jsonFieldsNameOfCreatePropertyReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreatePropertyReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreatePropertyReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateRoundReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateRoundReq) encodeFields(e *jx.Encoder) {
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("round_number")
		e.Int(s.RoundNumber)
	}
	{
		if s.NumOfIntendedChecks.Set {
			e.FieldStart("num_of_intended_checks")
			s.NumOfIntendedChecks.Encode(e)
		}
	}
	{

		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{

		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		if s.FinishedAt.Set {
			e.FieldStart("finished_at")
			s.FinishedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Checks != nil {
			e.FieldStart("checks")
			e.ArrStart()
			for _, elem := range s.Checks {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCreateRoundReq = [8]string{
	0: "create_time",
	1: "update_time",
	2: "round_number",
	3: "num_of_intended_checks",
	4: "status",
	5: "started_at",
	6: "finished_at",
	7: "checks",
}

// Decode decodes CreateRoundReq from json.
func (s *CreateRoundReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateRoundReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "round_number":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.RoundNumber = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_number\"")
			}
		case "num_of_intended_checks":
			if err := func() error {
				s.NumOfIntendedChecks.Reset()
				if err := s.NumOfIntendedChecks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"num_of_intended_checks\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "finished_at":
			if err := func() error {
				s.FinishedAt.Reset()
				if err := s.FinishedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finished_at\"")
			}
		case "checks":
			if err := func() error {
				s.Checks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Checks = append(s.Checks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateRoundReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateRoundReq) {
					name = jsonFieldsNameOfCreateRoundReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateRoundReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateRoundReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateRoundReqStatus as json.
func (s CreateRoundReqStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateRoundReqStatus from json.
func (s *CreateRoundReqStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateRoundReqStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateRoundReqStatus(v) {
	case CreateRoundReqStatusStarted:
		*s = CreateRoundReqStatusStarted
	case CreateRoundReqStatusOngoing:
		*s = CreateRoundReqStatusOngoing
	case CreateRoundReqStatusFinished:
		*s = CreateRoundReqStatusFinished
	case CreateRoundReqStatusIncomplete:
		*s = CreateRoundReqStatusIncomplete
	default:
		*s = CreateRoundReqStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateRoundReqStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateRoundReqStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateServiceReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateServiceReq) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{

		e.FieldStart("weight")
		e.Int(s.Weight)
	}
	{

		e.FieldStart("point_boost")
		e.Int(s.PointBoost)
	}
	{

		e.FieldStart("round_frequency")
		e.Int(s.RoundFrequency)
	}
	{

		e.FieldStart("round_delay")
		e.Int(s.RoundDelay)
	}
	{
		if s.Hostservices != nil {
			e.FieldStart("hostservices")
			e.ArrStart()
			for _, elem := range s.Hostservices {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Hostservicereports != nil {
			e.FieldStart("hostservicereports")
			e.ArrStart()
			for _, elem := range s.Hostservicereports {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCreateServiceReq = [13]string{
	0:  "name",
	1:  "display_name",
	2:  "pause",
	3:  "hidden",
	4:  "create_time",
	5:  "update_time",
	6:  "type",
	7:  "weight",
	8:  "point_boost",
	9:  "round_frequency",
	10: "round_delay",
	11: "hostservices",
	12: "hostservicereports",
}

// Decode decodes CreateServiceReq from json.
func (s *CreateServiceReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateServiceReq to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "weight":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Weight = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "point_boost":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.PointBoost = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"point_boost\"")
			}
		case "round_frequency":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.RoundFrequency = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_frequency\"")
			}
		case "round_delay":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.RoundDelay = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_delay\"")
			}
		case "hostservices":
			if err := func() error {
				s.Hostservices = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Hostservices = append(s.Hostservices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostservices\"")
			}
		case "hostservicereports":
			if err := func() error {
				s.Hostservicereports = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Hostservicereports = append(s.Hostservicereports, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostservicereports\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateServiceReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11000011,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateServiceReq) {
					name = jsonFieldsNameOfCreateServiceReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateServiceReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateServiceReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateServiceReqType as json.
func (s CreateServiceReqType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateServiceReqType from json.
func (s *CreateServiceReqType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateServiceReqType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateServiceReqType(v) {
	case CreateServiceReqTypeFtp:
		*s = CreateServiceReqTypeFtp
	case CreateServiceReqTypeSSH:
		*s = CreateServiceReqTypeSSH
	case CreateServiceReqTypeWinrm:
		*s = CreateServiceReqTypeWinrm
	case CreateServiceReqTypePing:
		*s = CreateServiceReqTypePing
	case CreateServiceReqTypeHTTP:
		*s = CreateServiceReqTypeHTTP
	case CreateServiceReqTypeLdap:
		*s = CreateServiceReqTypeLdap
	case CreateServiceReqTypeDNS:
		*s = CreateServiceReqTypeDNS
	case CreateServiceReqTypeSmb:
		*s = CreateServiceReqTypeSmb
	case CreateServiceReqTypeImap:
		*s = CreateServiceReqTypeImap
	case CreateServiceReqTypeSQL:
		*s = CreateServiceReqTypeSQL
	case CreateServiceReqTypeCaldav:
		*s = CreateServiceReqTypeCaldav
	default:
		*s = CreateServiceReqType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateServiceReqType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateServiceReqType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateTeamReportReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateTeamReportReq) encodeFields(e *jx.Encoder) {
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("points")
		e.Int(s.Points)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
	{

		e.FieldStart("team")
		e.Str(s.Team)
	}
	{
		if s.Hostservicereports != nil {
			e.FieldStart("hostservicereports")
			e.ArrStart()
			for _, elem := range s.Hostservicereports {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCreateTeamReportReq = [6]string{
	0: "create_time",
	1: "update_time",
	2: "points",
	3: "team_id",
	4: "team",
	5: "hostservicereports",
}

// Decode decodes CreateTeamReportReq from json.
func (s *CreateTeamReportReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTeamReportReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "points":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Points = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		case "team_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		case "team":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Team = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team\"")
			}
		case "hostservicereports":
			if err := func() error {
				s.Hostservicereports = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Hostservicereports = append(s.Hostservicereports, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostservicereports\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateTeamReportReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateTeamReportReq) {
					name = jsonFieldsNameOfCreateTeamReportReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTeamReportReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTeamReportReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateTeamReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateTeamReq) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("number")
		e.Int(s.Number)
	}
	{
		if s.Hosts != nil {
			e.FieldStart("hosts")
			e.ArrStart()
			for _, elem := range s.Hosts {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Hostservices != nil {
			e.FieldStart("hostservices")
			e.ArrStart()
			for _, elem := range s.Hostservices {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Teamreport.Set {
			e.FieldStart("teamreport")
			s.Teamreport.Encode(e)
		}
	}
	{
		if s.Hostservicereports != nil {
			e.FieldStart("hostservicereports")
			e.ArrStart()
			for _, elem := range s.Hostservicereports {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCreateTeamReq = [11]string{
	0:  "name",
	1:  "display_name",
	2:  "pause",
	3:  "hidden",
	4:  "create_time",
	5:  "update_time",
	6:  "number",
	7:  "hosts",
	8:  "hostservices",
	9:  "teamreport",
	10: "hostservicereports",
}

// Decode decodes CreateTeamReq from json.
func (s *CreateTeamReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTeamReq to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "number":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "hosts":
			if err := func() error {
				s.Hosts = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Hosts = append(s.Hosts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hosts\"")
			}
		case "hostservices":
			if err := func() error {
				s.Hostservices = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Hostservices = append(s.Hostservices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostservices\"")
			}
		case "teamreport":
			if err := func() error {
				s.Teamreport.Reset()
				if err := s.Teamreport.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamreport\"")
			}
		case "hostservicereports":
			if err := func() error {
				s.Hostservicereports = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Hostservicereports = append(s.Hostservicereports, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostservicereports\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateTeamReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateTeamReq) {
					name = jsonFieldsNameOfCreateTeamReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTeamReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTeamReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostCreate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("address")
		e.Str(s.Address)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
}

var jsonFieldsNameOfHostCreate = [7]string{
	0: "id",
	1: "pause",
	2: "hidden",
	3: "create_time",
	4: "update_time",
	5: "address",
	6: "team_id",
}

// Decode decodes HostCreate from json.
func (s *HostCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostCreate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "team_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01100001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHostCreate) {
					name = jsonFieldsNameOfHostCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostHostservicesList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostHostservicesList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("service_id")
		e.Str(s.ServiceID)
	}
	{

		e.FieldStart("host_id")
		e.Str(s.HostID)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
}

var jsonFieldsNameOfHostHostservicesList = [10]string{
	0: "id",
	1: "name",
	2: "display_name",
	3: "pause",
	4: "hidden",
	5: "create_time",
	6: "update_time",
	7: "service_id",
	8: "host_id",
	9: "team_id",
}

// Decode decodes HostHostservicesList from json.
func (s *HostHostservicesList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostHostservicesList to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "service_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_id\"")
			}
		case "host_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.HostID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_id\"")
			}
		case "team_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostHostservicesList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHostHostservicesList) {
					name = jsonFieldsNameOfHostHostservicesList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostHostservicesList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostHostservicesList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("address")
		e.Str(s.Address)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
}

var jsonFieldsNameOfHostList = [7]string{
	0: "id",
	1: "pause",
	2: "hidden",
	3: "create_time",
	4: "update_time",
	5: "address",
	6: "team_id",
}

// Decode decodes HostList from json.
func (s *HostList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "team_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01100001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHostList) {
					name = jsonFieldsNameOfHostList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("address")
		e.Str(s.Address)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
}

var jsonFieldsNameOfHostRead = [7]string{
	0: "id",
	1: "pause",
	2: "hidden",
	3: "create_time",
	4: "update_time",
	5: "address",
	6: "team_id",
}

// Decode decodes HostRead from json.
func (s *HostRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "team_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01100001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHostRead) {
					name = jsonFieldsNameOfHostRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostServiceChecksList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostServiceChecksList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Log.Set {
			e.FieldStart("log")
			s.Log.Encode(e)
		}
	}
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{

		e.FieldStart("passed")
		e.Bool(s.Passed)
	}
	{

		e.FieldStart("round_id")
		e.Str(s.RoundID)
	}
	{

		e.FieldStart("host_service_id")
		e.Str(s.HostServiceID)
	}
}

var jsonFieldsNameOfHostServiceChecksList = [8]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "log",
	4: "error",
	5: "passed",
	6: "round_id",
	7: "host_service_id",
}

// Decode decodes HostServiceChecksList from json.
func (s *HostServiceChecksList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostServiceChecksList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "log":
			if err := func() error {
				s.Log.Reset()
				if err := s.Log.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"log\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "passed":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Passed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passed\"")
			}
		case "round_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.RoundID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_id\"")
			}
		case "host_service_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.HostServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_service_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostServiceChecksList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11100001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHostServiceChecksList) {
					name = jsonFieldsNameOfHostServiceChecksList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostServiceChecksList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostServiceChecksList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostServiceCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostServiceCreate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("service_id")
		e.Str(s.ServiceID)
	}
	{

		e.FieldStart("host_id")
		e.Str(s.HostID)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
}

var jsonFieldsNameOfHostServiceCreate = [10]string{
	0: "id",
	1: "name",
	2: "display_name",
	3: "pause",
	4: "hidden",
	5: "create_time",
	6: "update_time",
	7: "service_id",
	8: "host_id",
	9: "team_id",
}

// Decode decodes HostServiceCreate from json.
func (s *HostServiceCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostServiceCreate to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "service_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_id\"")
			}
		case "host_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.HostID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_id\"")
			}
		case "team_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostServiceCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHostServiceCreate) {
					name = jsonFieldsNameOfHostServiceCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostServiceCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostServiceCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostServiceHostRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostServiceHostRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("address")
		e.Str(s.Address)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
}

var jsonFieldsNameOfHostServiceHostRead = [7]string{
	0: "id",
	1: "pause",
	2: "hidden",
	3: "create_time",
	4: "update_time",
	5: "address",
	6: "team_id",
}

// Decode decodes HostServiceHostRead from json.
func (s *HostServiceHostRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostServiceHostRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "team_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostServiceHostRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01100001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHostServiceHostRead) {
					name = jsonFieldsNameOfHostServiceHostRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostServiceHostRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostServiceHostRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostServiceHostservicereportRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostServiceHostservicereportRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("points")
		e.Int(s.Points)
	}
	{

		e.FieldStart("passing")
		e.Bool(s.Passing)
	}
	{

		e.FieldStart("latest_check_time")
		json.EncodeDateTime(e, s.LatestCheckTime)
	}
	{

		e.FieldStart("host_service_id")
		e.Str(s.HostServiceID)
	}
	{

		e.FieldStart("service_id")
		e.Str(s.ServiceID)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
	{
		if s.TeamReportID.Set {
			e.FieldStart("team_report_id")
			s.TeamReportID.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostServiceHostservicereportRead = [10]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "points",
	4: "passing",
	5: "latest_check_time",
	6: "host_service_id",
	7: "service_id",
	8: "team_id",
	9: "team_report_id",
}

// Decode decodes HostServiceHostservicereportRead from json.
func (s *HostServiceHostservicereportRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostServiceHostservicereportRead to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "points":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Points = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		case "passing":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Passing = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passing\"")
			}
		case "latest_check_time":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.LatestCheckTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latest_check_time\"")
			}
		case "host_service_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.HostServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_service_id\"")
			}
		case "service_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_id\"")
			}
		case "team_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		case "team_report_id":
			if err := func() error {
				s.TeamReportID.Reset()
				if err := s.TeamReportID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_report_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostServiceHostservicereportRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111001,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHostServiceHostservicereportRead) {
					name = jsonFieldsNameOfHostServiceHostservicereportRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostServiceHostservicereportRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostServiceHostservicereportRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostServiceList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostServiceList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("service_id")
		e.Str(s.ServiceID)
	}
	{

		e.FieldStart("host_id")
		e.Str(s.HostID)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
}

var jsonFieldsNameOfHostServiceList = [10]string{
	0: "id",
	1: "name",
	2: "display_name",
	3: "pause",
	4: "hidden",
	5: "create_time",
	6: "update_time",
	7: "service_id",
	8: "host_id",
	9: "team_id",
}

// Decode decodes HostServiceList from json.
func (s *HostServiceList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostServiceList to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "service_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_id\"")
			}
		case "host_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.HostID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_id\"")
			}
		case "team_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostServiceList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHostServiceList) {
					name = jsonFieldsNameOfHostServiceList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostServiceList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostServiceList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostServicePropertiesList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostServicePropertiesList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("key")
		e.Str(s.Key)
	}
	{

		e.FieldStart("value")
		e.Str(s.Value)
	}
	{

		e.FieldStart("host_service_id")
		e.Str(s.HostServiceID)
	}
}

var jsonFieldsNameOfHostServicePropertiesList = [6]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "key",
	4: "value",
	5: "host_service_id",
}

// Decode decodes HostServicePropertiesList from json.
func (s *HostServicePropertiesList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostServicePropertiesList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "host_service_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.HostServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_service_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostServicePropertiesList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHostServicePropertiesList) {
					name = jsonFieldsNameOfHostServicePropertiesList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostServicePropertiesList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostServicePropertiesList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostServiceRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostServiceRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("service_id")
		e.Str(s.ServiceID)
	}
	{

		e.FieldStart("host_id")
		e.Str(s.HostID)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
}

var jsonFieldsNameOfHostServiceRead = [10]string{
	0: "id",
	1: "name",
	2: "display_name",
	3: "pause",
	4: "hidden",
	5: "create_time",
	6: "update_time",
	7: "service_id",
	8: "host_id",
	9: "team_id",
}

// Decode decodes HostServiceRead from json.
func (s *HostServiceRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostServiceRead to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "service_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_id\"")
			}
		case "host_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.HostID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_id\"")
			}
		case "team_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostServiceRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHostServiceRead) {
					name = jsonFieldsNameOfHostServiceRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostServiceRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostServiceRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostServiceReportCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostServiceReportCreate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("points")
		e.Int(s.Points)
	}
	{

		e.FieldStart("passing")
		e.Bool(s.Passing)
	}
	{

		e.FieldStart("latest_check_time")
		json.EncodeDateTime(e, s.LatestCheckTime)
	}
	{

		e.FieldStart("host_service_id")
		e.Str(s.HostServiceID)
	}
	{

		e.FieldStart("service_id")
		e.Str(s.ServiceID)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
	{
		if s.TeamReportID.Set {
			e.FieldStart("team_report_id")
			s.TeamReportID.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostServiceReportCreate = [10]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "points",
	4: "passing",
	5: "latest_check_time",
	6: "host_service_id",
	7: "service_id",
	8: "team_id",
	9: "team_report_id",
}

// Decode decodes HostServiceReportCreate from json.
func (s *HostServiceReportCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostServiceReportCreate to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "points":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Points = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		case "passing":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Passing = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passing\"")
			}
		case "latest_check_time":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.LatestCheckTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latest_check_time\"")
			}
		case "host_service_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.HostServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_service_id\"")
			}
		case "service_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_id\"")
			}
		case "team_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		case "team_report_id":
			if err := func() error {
				s.TeamReportID.Reset()
				if err := s.TeamReportID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_report_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostServiceReportCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111001,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHostServiceReportCreate) {
					name = jsonFieldsNameOfHostServiceReportCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostServiceReportCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostServiceReportCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostServiceReportHostserviceRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostServiceReportHostserviceRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("service_id")
		e.Str(s.ServiceID)
	}
	{

		e.FieldStart("host_id")
		e.Str(s.HostID)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
}

var jsonFieldsNameOfHostServiceReportHostserviceRead = [10]string{
	0: "id",
	1: "name",
	2: "display_name",
	3: "pause",
	4: "hidden",
	5: "create_time",
	6: "update_time",
	7: "service_id",
	8: "host_id",
	9: "team_id",
}

// Decode decodes HostServiceReportHostserviceRead from json.
func (s *HostServiceReportHostserviceRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostServiceReportHostserviceRead to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "service_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_id\"")
			}
		case "host_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.HostID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_id\"")
			}
		case "team_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostServiceReportHostserviceRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHostServiceReportHostserviceRead) {
					name = jsonFieldsNameOfHostServiceReportHostserviceRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostServiceReportHostserviceRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostServiceReportHostserviceRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostServiceReportList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostServiceReportList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("points")
		e.Int(s.Points)
	}
	{

		e.FieldStart("passing")
		e.Bool(s.Passing)
	}
	{

		e.FieldStart("latest_check_time")
		json.EncodeDateTime(e, s.LatestCheckTime)
	}
	{

		e.FieldStart("host_service_id")
		e.Str(s.HostServiceID)
	}
	{

		e.FieldStart("service_id")
		e.Str(s.ServiceID)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
	{
		if s.TeamReportID.Set {
			e.FieldStart("team_report_id")
			s.TeamReportID.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostServiceReportList = [10]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "points",
	4: "passing",
	5: "latest_check_time",
	6: "host_service_id",
	7: "service_id",
	8: "team_id",
	9: "team_report_id",
}

// Decode decodes HostServiceReportList from json.
func (s *HostServiceReportList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostServiceReportList to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "points":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Points = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		case "passing":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Passing = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passing\"")
			}
		case "latest_check_time":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.LatestCheckTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latest_check_time\"")
			}
		case "host_service_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.HostServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_service_id\"")
			}
		case "service_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_id\"")
			}
		case "team_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		case "team_report_id":
			if err := func() error {
				s.TeamReportID.Reset()
				if err := s.TeamReportID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_report_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostServiceReportList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111001,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHostServiceReportList) {
					name = jsonFieldsNameOfHostServiceReportList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostServiceReportList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostServiceReportList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostServiceReportRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostServiceReportRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("points")
		e.Int(s.Points)
	}
	{

		e.FieldStart("passing")
		e.Bool(s.Passing)
	}
	{

		e.FieldStart("latest_check_time")
		json.EncodeDateTime(e, s.LatestCheckTime)
	}
	{

		e.FieldStart("host_service_id")
		e.Str(s.HostServiceID)
	}
	{

		e.FieldStart("service_id")
		e.Str(s.ServiceID)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
	{
		if s.TeamReportID.Set {
			e.FieldStart("team_report_id")
			s.TeamReportID.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostServiceReportRead = [10]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "points",
	4: "passing",
	5: "latest_check_time",
	6: "host_service_id",
	7: "service_id",
	8: "team_id",
	9: "team_report_id",
}

// Decode decodes HostServiceReportRead from json.
func (s *HostServiceReportRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostServiceReportRead to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "points":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Points = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		case "passing":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Passing = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passing\"")
			}
		case "latest_check_time":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.LatestCheckTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latest_check_time\"")
			}
		case "host_service_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.HostServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_service_id\"")
			}
		case "service_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_id\"")
			}
		case "team_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		case "team_report_id":
			if err := func() error {
				s.TeamReportID.Reset()
				if err := s.TeamReportID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_report_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostServiceReportRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111001,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHostServiceReportRead) {
					name = jsonFieldsNameOfHostServiceReportRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostServiceReportRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostServiceReportRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostServiceReportServiceRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostServiceReportServiceRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{

		e.FieldStart("weight")
		e.Int(s.Weight)
	}
	{

		e.FieldStart("point_boost")
		e.Int(s.PointBoost)
	}
	{

		e.FieldStart("round_frequency")
		e.Int(s.RoundFrequency)
	}
	{

		e.FieldStart("round_delay")
		e.Int(s.RoundDelay)
	}
}

var jsonFieldsNameOfHostServiceReportServiceRead = [12]string{
	0:  "id",
	1:  "name",
	2:  "display_name",
	3:  "pause",
	4:  "hidden",
	5:  "create_time",
	6:  "update_time",
	7:  "type",
	8:  "weight",
	9:  "point_boost",
	10: "round_frequency",
	11: "round_delay",
}

// Decode decodes HostServiceReportServiceRead from json.
func (s *HostServiceReportServiceRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostServiceReportServiceRead to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "weight":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Weight = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "point_boost":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.PointBoost = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"point_boost\"")
			}
		case "round_frequency":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.RoundFrequency = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_frequency\"")
			}
		case "round_delay":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.RoundDelay = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_delay\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostServiceReportServiceRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHostServiceReportServiceRead) {
					name = jsonFieldsNameOfHostServiceReportServiceRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostServiceReportServiceRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostServiceReportServiceRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HostServiceReportServiceReadType as json.
func (s HostServiceReportServiceReadType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HostServiceReportServiceReadType from json.
func (s *HostServiceReportServiceReadType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostServiceReportServiceReadType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HostServiceReportServiceReadType(v) {
	case HostServiceReportServiceReadTypeFtp:
		*s = HostServiceReportServiceReadTypeFtp
	case HostServiceReportServiceReadTypeSSH:
		*s = HostServiceReportServiceReadTypeSSH
	case HostServiceReportServiceReadTypeWinrm:
		*s = HostServiceReportServiceReadTypeWinrm
	case HostServiceReportServiceReadTypePing:
		*s = HostServiceReportServiceReadTypePing
	case HostServiceReportServiceReadTypeHTTP:
		*s = HostServiceReportServiceReadTypeHTTP
	case HostServiceReportServiceReadTypeLdap:
		*s = HostServiceReportServiceReadTypeLdap
	case HostServiceReportServiceReadTypeDNS:
		*s = HostServiceReportServiceReadTypeDNS
	case HostServiceReportServiceReadTypeSmb:
		*s = HostServiceReportServiceReadTypeSmb
	case HostServiceReportServiceReadTypeImap:
		*s = HostServiceReportServiceReadTypeImap
	case HostServiceReportServiceReadTypeSQL:
		*s = HostServiceReportServiceReadTypeSQL
	case HostServiceReportServiceReadTypeCaldav:
		*s = HostServiceReportServiceReadTypeCaldav
	default:
		*s = HostServiceReportServiceReadType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HostServiceReportServiceReadType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostServiceReportServiceReadType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostServiceReportTeamRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostServiceReportTeamRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("number")
		e.Int(s.Number)
	}
}

var jsonFieldsNameOfHostServiceReportTeamRead = [8]string{
	0: "id",
	1: "name",
	2: "display_name",
	3: "pause",
	4: "hidden",
	5: "create_time",
	6: "update_time",
	7: "number",
}

// Decode decodes HostServiceReportTeamRead from json.
func (s *HostServiceReportTeamRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostServiceReportTeamRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "number":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostServiceReportTeamRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b10000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHostServiceReportTeamRead) {
					name = jsonFieldsNameOfHostServiceReportTeamRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostServiceReportTeamRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostServiceReportTeamRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostServiceReportTeamreportRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostServiceReportTeamreportRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("points")
		e.Int(s.Points)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
}

var jsonFieldsNameOfHostServiceReportTeamreportRead = [5]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "points",
	4: "team_id",
}

// Decode decodes HostServiceReportTeamreportRead from json.
func (s *HostServiceReportTeamreportRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostServiceReportTeamreportRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "points":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Points = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		case "team_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostServiceReportTeamreportRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHostServiceReportTeamreportRead) {
					name = jsonFieldsNameOfHostServiceReportTeamreportRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostServiceReportTeamreportRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostServiceReportTeamreportRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostServiceReportUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostServiceReportUpdate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("points")
		e.Int(s.Points)
	}
	{

		e.FieldStart("passing")
		e.Bool(s.Passing)
	}
	{

		e.FieldStart("latest_check_time")
		json.EncodeDateTime(e, s.LatestCheckTime)
	}
	{

		e.FieldStart("host_service_id")
		e.Str(s.HostServiceID)
	}
	{

		e.FieldStart("service_id")
		e.Str(s.ServiceID)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
	{
		if s.TeamReportID.Set {
			e.FieldStart("team_report_id")
			s.TeamReportID.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostServiceReportUpdate = [10]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "points",
	4: "passing",
	5: "latest_check_time",
	6: "host_service_id",
	7: "service_id",
	8: "team_id",
	9: "team_report_id",
}

// Decode decodes HostServiceReportUpdate from json.
func (s *HostServiceReportUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostServiceReportUpdate to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "points":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Points = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		case "passing":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Passing = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passing\"")
			}
		case "latest_check_time":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.LatestCheckTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latest_check_time\"")
			}
		case "host_service_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.HostServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_service_id\"")
			}
		case "service_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_id\"")
			}
		case "team_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		case "team_report_id":
			if err := func() error {
				s.TeamReportID.Reset()
				if err := s.TeamReportID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_report_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostServiceReportUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111001,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHostServiceReportUpdate) {
					name = jsonFieldsNameOfHostServiceReportUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostServiceReportUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostServiceReportUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostServiceServiceRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostServiceServiceRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{

		e.FieldStart("weight")
		e.Int(s.Weight)
	}
	{

		e.FieldStart("point_boost")
		e.Int(s.PointBoost)
	}
	{

		e.FieldStart("round_frequency")
		e.Int(s.RoundFrequency)
	}
	{

		e.FieldStart("round_delay")
		e.Int(s.RoundDelay)
	}
}

var jsonFieldsNameOfHostServiceServiceRead = [12]string{
	0:  "id",
	1:  "name",
	2:  "display_name",
	3:  "pause",
	4:  "hidden",
	5:  "create_time",
	6:  "update_time",
	7:  "type",
	8:  "weight",
	9:  "point_boost",
	10: "round_frequency",
	11: "round_delay",
}

// Decode decodes HostServiceServiceRead from json.
func (s *HostServiceServiceRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostServiceServiceRead to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "weight":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Weight = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "point_boost":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.PointBoost = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"point_boost\"")
			}
		case "round_frequency":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.RoundFrequency = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_frequency\"")
			}
		case "round_delay":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.RoundDelay = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_delay\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostServiceServiceRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHostServiceServiceRead) {
					name = jsonFieldsNameOfHostServiceServiceRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostServiceServiceRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostServiceServiceRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HostServiceServiceReadType as json.
func (s HostServiceServiceReadType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HostServiceServiceReadType from json.
func (s *HostServiceServiceReadType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostServiceServiceReadType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HostServiceServiceReadType(v) {
	case HostServiceServiceReadTypeFtp:
		*s = HostServiceServiceReadTypeFtp
	case HostServiceServiceReadTypeSSH:
		*s = HostServiceServiceReadTypeSSH
	case HostServiceServiceReadTypeWinrm:
		*s = HostServiceServiceReadTypeWinrm
	case HostServiceServiceReadTypePing:
		*s = HostServiceServiceReadTypePing
	case HostServiceServiceReadTypeHTTP:
		*s = HostServiceServiceReadTypeHTTP
	case HostServiceServiceReadTypeLdap:
		*s = HostServiceServiceReadTypeLdap
	case HostServiceServiceReadTypeDNS:
		*s = HostServiceServiceReadTypeDNS
	case HostServiceServiceReadTypeSmb:
		*s = HostServiceServiceReadTypeSmb
	case HostServiceServiceReadTypeImap:
		*s = HostServiceServiceReadTypeImap
	case HostServiceServiceReadTypeSQL:
		*s = HostServiceServiceReadTypeSQL
	case HostServiceServiceReadTypeCaldav:
		*s = HostServiceServiceReadTypeCaldav
	default:
		*s = HostServiceServiceReadType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HostServiceServiceReadType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostServiceServiceReadType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostServiceTeamRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostServiceTeamRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("number")
		e.Int(s.Number)
	}
}

var jsonFieldsNameOfHostServiceTeamRead = [8]string{
	0: "id",
	1: "name",
	2: "display_name",
	3: "pause",
	4: "hidden",
	5: "create_time",
	6: "update_time",
	7: "number",
}

// Decode decodes HostServiceTeamRead from json.
func (s *HostServiceTeamRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostServiceTeamRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "number":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostServiceTeamRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b10000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHostServiceTeamRead) {
					name = jsonFieldsNameOfHostServiceTeamRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostServiceTeamRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostServiceTeamRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostServiceUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostServiceUpdate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("service_id")
		e.Str(s.ServiceID)
	}
	{

		e.FieldStart("host_id")
		e.Str(s.HostID)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
}

var jsonFieldsNameOfHostServiceUpdate = [10]string{
	0: "id",
	1: "name",
	2: "display_name",
	3: "pause",
	4: "hidden",
	5: "create_time",
	6: "update_time",
	7: "service_id",
	8: "host_id",
	9: "team_id",
}

// Decode decodes HostServiceUpdate from json.
func (s *HostServiceUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostServiceUpdate to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "service_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_id\"")
			}
		case "host_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.HostID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_id\"")
			}
		case "team_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostServiceUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHostServiceUpdate) {
					name = jsonFieldsNameOfHostServiceUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostServiceUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostServiceUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostTeamRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostTeamRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("number")
		e.Int(s.Number)
	}
}

var jsonFieldsNameOfHostTeamRead = [8]string{
	0: "id",
	1: "name",
	2: "display_name",
	3: "pause",
	4: "hidden",
	5: "create_time",
	6: "update_time",
	7: "number",
}

// Decode decodes HostTeamRead from json.
func (s *HostTeamRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostTeamRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "number":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostTeamRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b10000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHostTeamRead) {
					name = jsonFieldsNameOfHostTeamRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostTeamRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostTeamRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostUpdate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("address")
		e.Str(s.Address)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
}

var jsonFieldsNameOfHostUpdate = [7]string{
	0: "id",
	1: "pause",
	2: "hidden",
	3: "create_time",
	4: "update_time",
	5: "address",
	6: "team_id",
}

// Decode decodes HostUpdate from json.
func (s *HostUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "team_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01100001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHostUpdate) {
					name = jsonFieldsNameOfHostUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListApiTokenOKApplicationJSON as json.
func (s ListApiTokenOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []ApiTokenList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListApiTokenOKApplicationJSON from json.
func (s *ListApiTokenOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListApiTokenOKApplicationJSON to nil")
	}
	var unwrapped []ApiTokenList
	if err := func() error {
		unwrapped = make([]ApiTokenList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ApiTokenList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListApiTokenOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListApiTokenOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListApiTokenOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListCheckOKApplicationJSON as json.
func (s ListCheckOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []CheckList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListCheckOKApplicationJSON from json.
func (s *ListCheckOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListCheckOKApplicationJSON to nil")
	}
	var unwrapped []CheckList
	if err := func() error {
		unwrapped = make([]CheckList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem CheckList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListCheckOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListCheckOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListCheckOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListHostHostservicesOKApplicationJSON as json.
func (s ListHostHostservicesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []HostHostservicesList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListHostHostservicesOKApplicationJSON from json.
func (s *ListHostHostservicesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListHostHostservicesOKApplicationJSON to nil")
	}
	var unwrapped []HostHostservicesList
	if err := func() error {
		unwrapped = make([]HostHostservicesList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem HostHostservicesList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListHostHostservicesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListHostHostservicesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListHostHostservicesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListHostOKApplicationJSON as json.
func (s ListHostOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []HostList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListHostOKApplicationJSON from json.
func (s *ListHostOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListHostOKApplicationJSON to nil")
	}
	var unwrapped []HostList
	if err := func() error {
		unwrapped = make([]HostList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem HostList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListHostOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListHostOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListHostOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListHostServiceChecksOKApplicationJSON as json.
func (s ListHostServiceChecksOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []HostServiceChecksList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListHostServiceChecksOKApplicationJSON from json.
func (s *ListHostServiceChecksOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListHostServiceChecksOKApplicationJSON to nil")
	}
	var unwrapped []HostServiceChecksList
	if err := func() error {
		unwrapped = make([]HostServiceChecksList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem HostServiceChecksList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListHostServiceChecksOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListHostServiceChecksOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListHostServiceChecksOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListHostServiceOKApplicationJSON as json.
func (s ListHostServiceOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []HostServiceList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListHostServiceOKApplicationJSON from json.
func (s *ListHostServiceOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListHostServiceOKApplicationJSON to nil")
	}
	var unwrapped []HostServiceList
	if err := func() error {
		unwrapped = make([]HostServiceList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem HostServiceList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListHostServiceOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListHostServiceOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListHostServiceOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListHostServicePropertiesOKApplicationJSON as json.
func (s ListHostServicePropertiesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []HostServicePropertiesList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListHostServicePropertiesOKApplicationJSON from json.
func (s *ListHostServicePropertiesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListHostServicePropertiesOKApplicationJSON to nil")
	}
	var unwrapped []HostServicePropertiesList
	if err := func() error {
		unwrapped = make([]HostServicePropertiesList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem HostServicePropertiesList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListHostServicePropertiesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListHostServicePropertiesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListHostServicePropertiesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListHostServiceReportOKApplicationJSON as json.
func (s ListHostServiceReportOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []HostServiceReportList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListHostServiceReportOKApplicationJSON from json.
func (s *ListHostServiceReportOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListHostServiceReportOKApplicationJSON to nil")
	}
	var unwrapped []HostServiceReportList
	if err := func() error {
		unwrapped = make([]HostServiceReportList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem HostServiceReportList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListHostServiceReportOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListHostServiceReportOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListHostServiceReportOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListPropertyOKApplicationJSON as json.
func (s ListPropertyOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []PropertyList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListPropertyOKApplicationJSON from json.
func (s *ListPropertyOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListPropertyOKApplicationJSON to nil")
	}
	var unwrapped []PropertyList
	if err := func() error {
		unwrapped = make([]PropertyList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem PropertyList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListPropertyOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListPropertyOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListPropertyOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListRoundChecksLatestOKApplicationJSON as json.
func (s ListRoundChecksLatestOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []RoundChecksList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListRoundChecksLatestOKApplicationJSON from json.
func (s *ListRoundChecksLatestOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListRoundChecksLatestOKApplicationJSON to nil")
	}
	var unwrapped []RoundChecksList
	if err := func() error {
		unwrapped = make([]RoundChecksList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem RoundChecksList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListRoundChecksLatestOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListRoundChecksLatestOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListRoundChecksLatestOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListRoundChecksOKApplicationJSON as json.
func (s ListRoundChecksOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []RoundChecksList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListRoundChecksOKApplicationJSON from json.
func (s *ListRoundChecksOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListRoundChecksOKApplicationJSON to nil")
	}
	var unwrapped []RoundChecksList
	if err := func() error {
		unwrapped = make([]RoundChecksList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem RoundChecksList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListRoundChecksOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListRoundChecksOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListRoundChecksOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListRoundOKApplicationJSON as json.
func (s ListRoundOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []RoundList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListRoundOKApplicationJSON from json.
func (s *ListRoundOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListRoundOKApplicationJSON to nil")
	}
	var unwrapped []RoundList
	if err := func() error {
		unwrapped = make([]RoundList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem RoundList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListRoundOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListRoundOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListRoundOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListServiceHostservicereportsOKApplicationJSON as json.
func (s ListServiceHostservicereportsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []ServiceHostservicereportsList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListServiceHostservicereportsOKApplicationJSON from json.
func (s *ListServiceHostservicereportsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListServiceHostservicereportsOKApplicationJSON to nil")
	}
	var unwrapped []ServiceHostservicereportsList
	if err := func() error {
		unwrapped = make([]ServiceHostservicereportsList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ServiceHostservicereportsList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListServiceHostservicereportsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListServiceHostservicereportsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListServiceHostservicereportsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListServiceHostservicesOKApplicationJSON as json.
func (s ListServiceHostservicesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []ServiceHostservicesList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListServiceHostservicesOKApplicationJSON from json.
func (s *ListServiceHostservicesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListServiceHostservicesOKApplicationJSON to nil")
	}
	var unwrapped []ServiceHostservicesList
	if err := func() error {
		unwrapped = make([]ServiceHostservicesList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ServiceHostservicesList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListServiceHostservicesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListServiceHostservicesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListServiceHostservicesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListServiceOKApplicationJSON as json.
func (s ListServiceOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []ServiceList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListServiceOKApplicationJSON from json.
func (s *ListServiceOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListServiceOKApplicationJSON to nil")
	}
	var unwrapped []ServiceList
	if err := func() error {
		unwrapped = make([]ServiceList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ServiceList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListServiceOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListServiceOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListServiceOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListTeamHostsOKApplicationJSON as json.
func (s ListTeamHostsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []TeamHostsList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListTeamHostsOKApplicationJSON from json.
func (s *ListTeamHostsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListTeamHostsOKApplicationJSON to nil")
	}
	var unwrapped []TeamHostsList
	if err := func() error {
		unwrapped = make([]TeamHostsList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem TeamHostsList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListTeamHostsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListTeamHostsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListTeamHostsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListTeamHostservicereportsOKApplicationJSON as json.
func (s ListTeamHostservicereportsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []TeamHostservicereportsList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListTeamHostservicereportsOKApplicationJSON from json.
func (s *ListTeamHostservicereportsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListTeamHostservicereportsOKApplicationJSON to nil")
	}
	var unwrapped []TeamHostservicereportsList
	if err := func() error {
		unwrapped = make([]TeamHostservicereportsList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem TeamHostservicereportsList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListTeamHostservicereportsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListTeamHostservicereportsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListTeamHostservicereportsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListTeamHostservicesOKApplicationJSON as json.
func (s ListTeamHostservicesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []TeamHostservicesList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListTeamHostservicesOKApplicationJSON from json.
func (s *ListTeamHostservicesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListTeamHostservicesOKApplicationJSON to nil")
	}
	var unwrapped []TeamHostservicesList
	if err := func() error {
		unwrapped = make([]TeamHostservicesList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem TeamHostservicesList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListTeamHostservicesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListTeamHostservicesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListTeamHostservicesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListTeamOKApplicationJSON as json.
func (s ListTeamOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []TeamList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListTeamOKApplicationJSON from json.
func (s *ListTeamOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListTeamOKApplicationJSON to nil")
	}
	var unwrapped []TeamList
	if err := func() error {
		unwrapped = make([]TeamList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem TeamList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListTeamOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListTeamOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListTeamOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListTeamReportHostservicereportsOKApplicationJSON as json.
func (s ListTeamReportHostservicereportsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []TeamReportHostservicereportsList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListTeamReportHostservicereportsOKApplicationJSON from json.
func (s *ListTeamReportHostservicereportsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListTeamReportHostservicereportsOKApplicationJSON to nil")
	}
	var unwrapped []TeamReportHostservicereportsList
	if err := func() error {
		unwrapped = make([]TeamReportHostservicereportsList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem TeamReportHostservicereportsList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListTeamReportHostservicereportsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListTeamReportHostservicereportsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListTeamReportHostservicereportsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListTeamReportOKApplicationJSON as json.
func (s ListTeamReportOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []TeamReportList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListTeamReportOKApplicationJSON from json.
func (s *ListTeamReportOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListTeamReportOKApplicationJSON to nil")
	}
	var unwrapped []TeamReportList
	if err := func() error {
		unwrapped = make([]TeamReportList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem TeamReportList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListTeamReportOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListTeamReportOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListTeamReportOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateRoundReqStatus as json.
func (o OptUpdateRoundReqStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateRoundReqStatus from json.
func (o *OptUpdateRoundReqStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateRoundReqStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateRoundReqStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateRoundReqStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateServiceReqType as json.
func (o OptUpdateServiceReqType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateServiceReqType from json.
func (o *OptUpdateServiceReqType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateServiceReqType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateServiceReqType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateServiceReqType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PropertyCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PropertyCreate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("key")
		e.Str(s.Key)
	}
	{

		e.FieldStart("value")
		e.Str(s.Value)
	}
	{

		e.FieldStart("host_service_id")
		e.Str(s.HostServiceID)
	}
}

var jsonFieldsNameOfPropertyCreate = [6]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "key",
	4: "value",
	5: "host_service_id",
}

// Decode decodes PropertyCreate from json.
func (s *PropertyCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PropertyCreate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "host_service_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.HostServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_service_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PropertyCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPropertyCreate) {
					name = jsonFieldsNameOfPropertyCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PropertyCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PropertyCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PropertyHostserviceRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PropertyHostserviceRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("service_id")
		e.Str(s.ServiceID)
	}
	{

		e.FieldStart("host_id")
		e.Str(s.HostID)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
}

var jsonFieldsNameOfPropertyHostserviceRead = [10]string{
	0: "id",
	1: "name",
	2: "display_name",
	3: "pause",
	4: "hidden",
	5: "create_time",
	6: "update_time",
	7: "service_id",
	8: "host_id",
	9: "team_id",
}

// Decode decodes PropertyHostserviceRead from json.
func (s *PropertyHostserviceRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PropertyHostserviceRead to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "service_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_id\"")
			}
		case "host_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.HostID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_id\"")
			}
		case "team_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PropertyHostserviceRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPropertyHostserviceRead) {
					name = jsonFieldsNameOfPropertyHostserviceRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PropertyHostserviceRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PropertyHostserviceRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PropertyList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PropertyList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("key")
		e.Str(s.Key)
	}
	{

		e.FieldStart("value")
		e.Str(s.Value)
	}
	{

		e.FieldStart("host_service_id")
		e.Str(s.HostServiceID)
	}
}

var jsonFieldsNameOfPropertyList = [6]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "key",
	4: "value",
	5: "host_service_id",
}

// Decode decodes PropertyList from json.
func (s *PropertyList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PropertyList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "host_service_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.HostServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_service_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PropertyList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPropertyList) {
					name = jsonFieldsNameOfPropertyList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PropertyList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PropertyList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PropertyRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PropertyRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("key")
		e.Str(s.Key)
	}
	{

		e.FieldStart("value")
		e.Str(s.Value)
	}
	{

		e.FieldStart("host_service_id")
		e.Str(s.HostServiceID)
	}
}

var jsonFieldsNameOfPropertyRead = [6]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "key",
	4: "value",
	5: "host_service_id",
}

// Decode decodes PropertyRead from json.
func (s *PropertyRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PropertyRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "host_service_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.HostServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_service_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PropertyRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPropertyRead) {
					name = jsonFieldsNameOfPropertyRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PropertyRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PropertyRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PropertyUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PropertyUpdate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("key")
		e.Str(s.Key)
	}
	{

		e.FieldStart("value")
		e.Str(s.Value)
	}
	{

		e.FieldStart("host_service_id")
		e.Str(s.HostServiceID)
	}
}

var jsonFieldsNameOfPropertyUpdate = [6]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "key",
	4: "value",
	5: "host_service_id",
}

// Decode decodes PropertyUpdate from json.
func (s *PropertyUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PropertyUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "host_service_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.HostServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_service_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PropertyUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPropertyUpdate) {
					name = jsonFieldsNameOfPropertyUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PropertyUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PropertyUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *R400) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *R400) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("code")
		e.Int(s.Code)
	}
	{

		e.FieldStart("status")
		e.Str(s.Status)
	}
	{

		if len(s.Errors) != 0 {
			e.FieldStart("errors")
			e.Raw(s.Errors)
		}
	}
}

var jsonFieldsNameOfR400 = [3]string{
	0: "code",
	1: "status",
	2: "errors",
}

// Decode decodes R400 from json.
func (s *R400) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R400 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "errors":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Errors = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode R400")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfR400) {
					name = jsonFieldsNameOfR400[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *R400) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *R400) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *R404) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *R404) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("code")
		e.Int(s.Code)
	}
	{

		e.FieldStart("status")
		e.Str(s.Status)
	}
	{

		if len(s.Errors) != 0 {
			e.FieldStart("errors")
			e.Raw(s.Errors)
		}
	}
}

var jsonFieldsNameOfR404 = [3]string{
	0: "code",
	1: "status",
	2: "errors",
}

// Decode decodes R404 from json.
func (s *R404) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R404 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "errors":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Errors = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode R404")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfR404) {
					name = jsonFieldsNameOfR404[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *R404) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *R404) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *R409) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *R409) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("code")
		e.Int(s.Code)
	}
	{

		e.FieldStart("status")
		e.Str(s.Status)
	}
	{

		if len(s.Errors) != 0 {
			e.FieldStart("errors")
			e.Raw(s.Errors)
		}
	}
}

var jsonFieldsNameOfR409 = [3]string{
	0: "code",
	1: "status",
	2: "errors",
}

// Decode decodes R409 from json.
func (s *R409) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R409 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "errors":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Errors = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode R409")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfR409) {
					name = jsonFieldsNameOfR409[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *R409) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *R409) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *R500) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *R500) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("code")
		e.Int(s.Code)
	}
	{

		e.FieldStart("status")
		e.Str(s.Status)
	}
	{

		if len(s.Errors) != 0 {
			e.FieldStart("errors")
			e.Raw(s.Errors)
		}
	}
}

var jsonFieldsNameOfR500 = [3]string{
	0: "code",
	1: "status",
	2: "errors",
}

// Decode decodes R500 from json.
func (s *R500) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R500 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "errors":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Errors = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode R500")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfR500) {
					name = jsonFieldsNameOfR500[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *R500) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *R500) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RoundChecksList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RoundChecksList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Log.Set {
			e.FieldStart("log")
			s.Log.Encode(e)
		}
	}
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{

		e.FieldStart("passed")
		e.Bool(s.Passed)
	}
	{

		e.FieldStart("round_id")
		e.Str(s.RoundID)
	}
	{

		e.FieldStart("host_service_id")
		e.Str(s.HostServiceID)
	}
}

var jsonFieldsNameOfRoundChecksList = [8]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "log",
	4: "error",
	5: "passed",
	6: "round_id",
	7: "host_service_id",
}

// Decode decodes RoundChecksList from json.
func (s *RoundChecksList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RoundChecksList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "log":
			if err := func() error {
				s.Log.Reset()
				if err := s.Log.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"log\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "passed":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Passed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passed\"")
			}
		case "round_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.RoundID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_id\"")
			}
		case "host_service_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.HostServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_service_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RoundChecksList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11100001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRoundChecksList) {
					name = jsonFieldsNameOfRoundChecksList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RoundChecksList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RoundChecksList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RoundCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RoundCreate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("round_number")
		e.Int(s.RoundNumber)
	}
	{
		if s.NumOfIntendedChecks.Set {
			e.FieldStart("num_of_intended_checks")
			s.NumOfIntendedChecks.Encode(e)
		}
	}
	{

		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{

		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		if s.FinishedAt.Set {
			e.FieldStart("finished_at")
			s.FinishedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfRoundCreate = [8]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "round_number",
	4: "num_of_intended_checks",
	5: "status",
	6: "started_at",
	7: "finished_at",
}

// Decode decodes RoundCreate from json.
func (s *RoundCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RoundCreate to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "round_number":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.RoundNumber = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_number\"")
			}
		case "num_of_intended_checks":
			if err := func() error {
				s.NumOfIntendedChecks.Reset()
				if err := s.NumOfIntendedChecks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"num_of_intended_checks\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "finished_at":
			if err := func() error {
				s.FinishedAt.Reset()
				if err := s.FinishedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finished_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RoundCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01101001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRoundCreate) {
					name = jsonFieldsNameOfRoundCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RoundCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RoundCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RoundCreateStatus as json.
func (s RoundCreateStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RoundCreateStatus from json.
func (s *RoundCreateStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RoundCreateStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RoundCreateStatus(v) {
	case RoundCreateStatusStarted:
		*s = RoundCreateStatusStarted
	case RoundCreateStatusOngoing:
		*s = RoundCreateStatusOngoing
	case RoundCreateStatusFinished:
		*s = RoundCreateStatusFinished
	case RoundCreateStatusIncomplete:
		*s = RoundCreateStatusIncomplete
	default:
		*s = RoundCreateStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RoundCreateStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RoundCreateStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RoundList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RoundList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("round_number")
		e.Int(s.RoundNumber)
	}
	{
		if s.NumOfIntendedChecks.Set {
			e.FieldStart("num_of_intended_checks")
			s.NumOfIntendedChecks.Encode(e)
		}
	}
	{

		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{

		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		if s.FinishedAt.Set {
			e.FieldStart("finished_at")
			s.FinishedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfRoundList = [8]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "round_number",
	4: "num_of_intended_checks",
	5: "status",
	6: "started_at",
	7: "finished_at",
}

// Decode decodes RoundList from json.
func (s *RoundList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RoundList to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "round_number":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.RoundNumber = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_number\"")
			}
		case "num_of_intended_checks":
			if err := func() error {
				s.NumOfIntendedChecks.Reset()
				if err := s.NumOfIntendedChecks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"num_of_intended_checks\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "finished_at":
			if err := func() error {
				s.FinishedAt.Reset()
				if err := s.FinishedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finished_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RoundList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01101001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRoundList) {
					name = jsonFieldsNameOfRoundList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RoundList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RoundList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RoundListStatus as json.
func (s RoundListStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RoundListStatus from json.
func (s *RoundListStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RoundListStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RoundListStatus(v) {
	case RoundListStatusStarted:
		*s = RoundListStatusStarted
	case RoundListStatusOngoing:
		*s = RoundListStatusOngoing
	case RoundListStatusFinished:
		*s = RoundListStatusFinished
	case RoundListStatusIncomplete:
		*s = RoundListStatusIncomplete
	default:
		*s = RoundListStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RoundListStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RoundListStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RoundRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RoundRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("round_number")
		e.Int(s.RoundNumber)
	}
	{
		if s.NumOfIntendedChecks.Set {
			e.FieldStart("num_of_intended_checks")
			s.NumOfIntendedChecks.Encode(e)
		}
	}
	{

		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{

		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		if s.FinishedAt.Set {
			e.FieldStart("finished_at")
			s.FinishedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfRoundRead = [8]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "round_number",
	4: "num_of_intended_checks",
	5: "status",
	6: "started_at",
	7: "finished_at",
}

// Decode decodes RoundRead from json.
func (s *RoundRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RoundRead to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "round_number":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.RoundNumber = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_number\"")
			}
		case "num_of_intended_checks":
			if err := func() error {
				s.NumOfIntendedChecks.Reset()
				if err := s.NumOfIntendedChecks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"num_of_intended_checks\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "finished_at":
			if err := func() error {
				s.FinishedAt.Reset()
				if err := s.FinishedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finished_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RoundRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01101001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRoundRead) {
					name = jsonFieldsNameOfRoundRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RoundRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RoundRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RoundReadStatus as json.
func (s RoundReadStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RoundReadStatus from json.
func (s *RoundReadStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RoundReadStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RoundReadStatus(v) {
	case RoundReadStatusStarted:
		*s = RoundReadStatusStarted
	case RoundReadStatusOngoing:
		*s = RoundReadStatusOngoing
	case RoundReadStatusFinished:
		*s = RoundReadStatusFinished
	case RoundReadStatusIncomplete:
		*s = RoundReadStatusIncomplete
	default:
		*s = RoundReadStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RoundReadStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RoundReadStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RoundUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RoundUpdate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("round_number")
		e.Int(s.RoundNumber)
	}
	{
		if s.NumOfIntendedChecks.Set {
			e.FieldStart("num_of_intended_checks")
			s.NumOfIntendedChecks.Encode(e)
		}
	}
	{

		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{

		e.FieldStart("started_at")
		json.EncodeDateTime(e, s.StartedAt)
	}
	{
		if s.FinishedAt.Set {
			e.FieldStart("finished_at")
			s.FinishedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfRoundUpdate = [8]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "round_number",
	4: "num_of_intended_checks",
	5: "status",
	6: "started_at",
	7: "finished_at",
}

// Decode decodes RoundUpdate from json.
func (s *RoundUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RoundUpdate to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "round_number":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.RoundNumber = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_number\"")
			}
		case "num_of_intended_checks":
			if err := func() error {
				s.NumOfIntendedChecks.Reset()
				if err := s.NumOfIntendedChecks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"num_of_intended_checks\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "started_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.StartedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "finished_at":
			if err := func() error {
				s.FinishedAt.Reset()
				if err := s.FinishedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finished_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RoundUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01101001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRoundUpdate) {
					name = jsonFieldsNameOfRoundUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RoundUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RoundUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RoundUpdateStatus as json.
func (s RoundUpdateStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RoundUpdateStatus from json.
func (s *RoundUpdateStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RoundUpdateStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RoundUpdateStatus(v) {
	case RoundUpdateStatusStarted:
		*s = RoundUpdateStatusStarted
	case RoundUpdateStatusOngoing:
		*s = RoundUpdateStatusOngoing
	case RoundUpdateStatusFinished:
		*s = RoundUpdateStatusFinished
	case RoundUpdateStatusIncomplete:
		*s = RoundUpdateStatusIncomplete
	default:
		*s = RoundUpdateStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RoundUpdateStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RoundUpdateStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ServiceCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ServiceCreate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{

		e.FieldStart("weight")
		e.Int(s.Weight)
	}
	{

		e.FieldStart("point_boost")
		e.Int(s.PointBoost)
	}
	{

		e.FieldStart("round_frequency")
		e.Int(s.RoundFrequency)
	}
	{

		e.FieldStart("round_delay")
		e.Int(s.RoundDelay)
	}
}

var jsonFieldsNameOfServiceCreate = [12]string{
	0:  "id",
	1:  "name",
	2:  "display_name",
	3:  "pause",
	4:  "hidden",
	5:  "create_time",
	6:  "update_time",
	7:  "type",
	8:  "weight",
	9:  "point_boost",
	10: "round_frequency",
	11: "round_delay",
}

// Decode decodes ServiceCreate from json.
func (s *ServiceCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServiceCreate to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "weight":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Weight = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "point_boost":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.PointBoost = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"point_boost\"")
			}
		case "round_frequency":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.RoundFrequency = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_frequency\"")
			}
		case "round_delay":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.RoundDelay = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_delay\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServiceCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfServiceCreate) {
					name = jsonFieldsNameOfServiceCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ServiceCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServiceCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ServiceCreateType as json.
func (s ServiceCreateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ServiceCreateType from json.
func (s *ServiceCreateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServiceCreateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ServiceCreateType(v) {
	case ServiceCreateTypeFtp:
		*s = ServiceCreateTypeFtp
	case ServiceCreateTypeSSH:
		*s = ServiceCreateTypeSSH
	case ServiceCreateTypeWinrm:
		*s = ServiceCreateTypeWinrm
	case ServiceCreateTypePing:
		*s = ServiceCreateTypePing
	case ServiceCreateTypeHTTP:
		*s = ServiceCreateTypeHTTP
	case ServiceCreateTypeLdap:
		*s = ServiceCreateTypeLdap
	case ServiceCreateTypeDNS:
		*s = ServiceCreateTypeDNS
	case ServiceCreateTypeSmb:
		*s = ServiceCreateTypeSmb
	case ServiceCreateTypeImap:
		*s = ServiceCreateTypeImap
	case ServiceCreateTypeSQL:
		*s = ServiceCreateTypeSQL
	case ServiceCreateTypeCaldav:
		*s = ServiceCreateTypeCaldav
	default:
		*s = ServiceCreateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ServiceCreateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServiceCreateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ServiceHostservicereportsList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ServiceHostservicereportsList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("points")
		e.Int(s.Points)
	}
	{

		e.FieldStart("passing")
		e.Bool(s.Passing)
	}
	{

		e.FieldStart("latest_check_time")
		json.EncodeDateTime(e, s.LatestCheckTime)
	}
	{

		e.FieldStart("host_service_id")
		e.Str(s.HostServiceID)
	}
	{

		e.FieldStart("service_id")
		e.Str(s.ServiceID)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
	{
		if s.TeamReportID.Set {
			e.FieldStart("team_report_id")
			s.TeamReportID.Encode(e)
		}
	}
}

var jsonFieldsNameOfServiceHostservicereportsList = [10]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "points",
	4: "passing",
	5: "latest_check_time",
	6: "host_service_id",
	7: "service_id",
	8: "team_id",
	9: "team_report_id",
}

// Decode decodes ServiceHostservicereportsList from json.
func (s *ServiceHostservicereportsList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServiceHostservicereportsList to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "points":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Points = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		case "passing":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Passing = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passing\"")
			}
		case "latest_check_time":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.LatestCheckTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latest_check_time\"")
			}
		case "host_service_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.HostServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_service_id\"")
			}
		case "service_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_id\"")
			}
		case "team_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		case "team_report_id":
			if err := func() error {
				s.TeamReportID.Reset()
				if err := s.TeamReportID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_report_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServiceHostservicereportsList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111001,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfServiceHostservicereportsList) {
					name = jsonFieldsNameOfServiceHostservicereportsList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ServiceHostservicereportsList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServiceHostservicereportsList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ServiceHostservicesList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ServiceHostservicesList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("service_id")
		e.Str(s.ServiceID)
	}
	{

		e.FieldStart("host_id")
		e.Str(s.HostID)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
}

var jsonFieldsNameOfServiceHostservicesList = [10]string{
	0: "id",
	1: "name",
	2: "display_name",
	3: "pause",
	4: "hidden",
	5: "create_time",
	6: "update_time",
	7: "service_id",
	8: "host_id",
	9: "team_id",
}

// Decode decodes ServiceHostservicesList from json.
func (s *ServiceHostservicesList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServiceHostservicesList to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "service_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_id\"")
			}
		case "host_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.HostID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_id\"")
			}
		case "team_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServiceHostservicesList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfServiceHostservicesList) {
					name = jsonFieldsNameOfServiceHostservicesList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ServiceHostservicesList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServiceHostservicesList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ServiceList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ServiceList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{

		e.FieldStart("weight")
		e.Int(s.Weight)
	}
	{

		e.FieldStart("point_boost")
		e.Int(s.PointBoost)
	}
	{

		e.FieldStart("round_frequency")
		e.Int(s.RoundFrequency)
	}
	{

		e.FieldStart("round_delay")
		e.Int(s.RoundDelay)
	}
}

var jsonFieldsNameOfServiceList = [12]string{
	0:  "id",
	1:  "name",
	2:  "display_name",
	3:  "pause",
	4:  "hidden",
	5:  "create_time",
	6:  "update_time",
	7:  "type",
	8:  "weight",
	9:  "point_boost",
	10: "round_frequency",
	11: "round_delay",
}

// Decode decodes ServiceList from json.
func (s *ServiceList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServiceList to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "weight":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Weight = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "point_boost":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.PointBoost = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"point_boost\"")
			}
		case "round_frequency":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.RoundFrequency = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_frequency\"")
			}
		case "round_delay":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.RoundDelay = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_delay\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServiceList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfServiceList) {
					name = jsonFieldsNameOfServiceList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ServiceList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServiceList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ServiceListType as json.
func (s ServiceListType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ServiceListType from json.
func (s *ServiceListType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServiceListType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ServiceListType(v) {
	case ServiceListTypeFtp:
		*s = ServiceListTypeFtp
	case ServiceListTypeSSH:
		*s = ServiceListTypeSSH
	case ServiceListTypeWinrm:
		*s = ServiceListTypeWinrm
	case ServiceListTypePing:
		*s = ServiceListTypePing
	case ServiceListTypeHTTP:
		*s = ServiceListTypeHTTP
	case ServiceListTypeLdap:
		*s = ServiceListTypeLdap
	case ServiceListTypeDNS:
		*s = ServiceListTypeDNS
	case ServiceListTypeSmb:
		*s = ServiceListTypeSmb
	case ServiceListTypeImap:
		*s = ServiceListTypeImap
	case ServiceListTypeSQL:
		*s = ServiceListTypeSQL
	case ServiceListTypeCaldav:
		*s = ServiceListTypeCaldav
	default:
		*s = ServiceListType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ServiceListType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServiceListType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ServiceRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ServiceRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{

		e.FieldStart("weight")
		e.Int(s.Weight)
	}
	{

		e.FieldStart("point_boost")
		e.Int(s.PointBoost)
	}
	{

		e.FieldStart("round_frequency")
		e.Int(s.RoundFrequency)
	}
	{

		e.FieldStart("round_delay")
		e.Int(s.RoundDelay)
	}
}

var jsonFieldsNameOfServiceRead = [12]string{
	0:  "id",
	1:  "name",
	2:  "display_name",
	3:  "pause",
	4:  "hidden",
	5:  "create_time",
	6:  "update_time",
	7:  "type",
	8:  "weight",
	9:  "point_boost",
	10: "round_frequency",
	11: "round_delay",
}

// Decode decodes ServiceRead from json.
func (s *ServiceRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServiceRead to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "weight":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Weight = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "point_boost":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.PointBoost = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"point_boost\"")
			}
		case "round_frequency":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.RoundFrequency = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_frequency\"")
			}
		case "round_delay":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.RoundDelay = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_delay\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServiceRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfServiceRead) {
					name = jsonFieldsNameOfServiceRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ServiceRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServiceRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ServiceReadType as json.
func (s ServiceReadType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ServiceReadType from json.
func (s *ServiceReadType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServiceReadType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ServiceReadType(v) {
	case ServiceReadTypeFtp:
		*s = ServiceReadTypeFtp
	case ServiceReadTypeSSH:
		*s = ServiceReadTypeSSH
	case ServiceReadTypeWinrm:
		*s = ServiceReadTypeWinrm
	case ServiceReadTypePing:
		*s = ServiceReadTypePing
	case ServiceReadTypeHTTP:
		*s = ServiceReadTypeHTTP
	case ServiceReadTypeLdap:
		*s = ServiceReadTypeLdap
	case ServiceReadTypeDNS:
		*s = ServiceReadTypeDNS
	case ServiceReadTypeSmb:
		*s = ServiceReadTypeSmb
	case ServiceReadTypeImap:
		*s = ServiceReadTypeImap
	case ServiceReadTypeSQL:
		*s = ServiceReadTypeSQL
	case ServiceReadTypeCaldav:
		*s = ServiceReadTypeCaldav
	default:
		*s = ServiceReadType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ServiceReadType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServiceReadType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ServiceUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ServiceUpdate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{

		e.FieldStart("weight")
		e.Int(s.Weight)
	}
	{

		e.FieldStart("point_boost")
		e.Int(s.PointBoost)
	}
	{

		e.FieldStart("round_frequency")
		e.Int(s.RoundFrequency)
	}
	{

		e.FieldStart("round_delay")
		e.Int(s.RoundDelay)
	}
}

var jsonFieldsNameOfServiceUpdate = [12]string{
	0:  "id",
	1:  "name",
	2:  "display_name",
	3:  "pause",
	4:  "hidden",
	5:  "create_time",
	6:  "update_time",
	7:  "type",
	8:  "weight",
	9:  "point_boost",
	10: "round_frequency",
	11: "round_delay",
}

// Decode decodes ServiceUpdate from json.
func (s *ServiceUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServiceUpdate to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "weight":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Weight = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "point_boost":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.PointBoost = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"point_boost\"")
			}
		case "round_frequency":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.RoundFrequency = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_frequency\"")
			}
		case "round_delay":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.RoundDelay = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_delay\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServiceUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfServiceUpdate) {
					name = jsonFieldsNameOfServiceUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ServiceUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServiceUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ServiceUpdateType as json.
func (s ServiceUpdateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ServiceUpdateType from json.
func (s *ServiceUpdateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServiceUpdateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ServiceUpdateType(v) {
	case ServiceUpdateTypeFtp:
		*s = ServiceUpdateTypeFtp
	case ServiceUpdateTypeSSH:
		*s = ServiceUpdateTypeSSH
	case ServiceUpdateTypeWinrm:
		*s = ServiceUpdateTypeWinrm
	case ServiceUpdateTypePing:
		*s = ServiceUpdateTypePing
	case ServiceUpdateTypeHTTP:
		*s = ServiceUpdateTypeHTTP
	case ServiceUpdateTypeLdap:
		*s = ServiceUpdateTypeLdap
	case ServiceUpdateTypeDNS:
		*s = ServiceUpdateTypeDNS
	case ServiceUpdateTypeSmb:
		*s = ServiceUpdateTypeSmb
	case ServiceUpdateTypeImap:
		*s = ServiceUpdateTypeImap
	case ServiceUpdateTypeSQL:
		*s = ServiceUpdateTypeSQL
	case ServiceUpdateTypeCaldav:
		*s = ServiceUpdateTypeCaldav
	default:
		*s = ServiceUpdateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ServiceUpdateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServiceUpdateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamCreate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("number")
		e.Int(s.Number)
	}
}

var jsonFieldsNameOfTeamCreate = [8]string{
	0: "id",
	1: "name",
	2: "display_name",
	3: "pause",
	4: "hidden",
	5: "create_time",
	6: "update_time",
	7: "number",
}

// Decode decodes TeamCreate from json.
func (s *TeamCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamCreate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "number":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b10000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamCreate) {
					name = jsonFieldsNameOfTeamCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamHostsList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamHostsList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("address")
		e.Str(s.Address)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
}

var jsonFieldsNameOfTeamHostsList = [7]string{
	0: "id",
	1: "pause",
	2: "hidden",
	3: "create_time",
	4: "update_time",
	5: "address",
	6: "team_id",
}

// Decode decodes TeamHostsList from json.
func (s *TeamHostsList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamHostsList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "team_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamHostsList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01100001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamHostsList) {
					name = jsonFieldsNameOfTeamHostsList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamHostsList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamHostsList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamHostservicereportsList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamHostservicereportsList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("points")
		e.Int(s.Points)
	}
	{

		e.FieldStart("passing")
		e.Bool(s.Passing)
	}
	{

		e.FieldStart("latest_check_time")
		json.EncodeDateTime(e, s.LatestCheckTime)
	}
	{

		e.FieldStart("host_service_id")
		e.Str(s.HostServiceID)
	}
	{

		e.FieldStart("service_id")
		e.Str(s.ServiceID)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
	{
		if s.TeamReportID.Set {
			e.FieldStart("team_report_id")
			s.TeamReportID.Encode(e)
		}
	}
}

var jsonFieldsNameOfTeamHostservicereportsList = [10]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "points",
	4: "passing",
	5: "latest_check_time",
	6: "host_service_id",
	7: "service_id",
	8: "team_id",
	9: "team_report_id",
}

// Decode decodes TeamHostservicereportsList from json.
func (s *TeamHostservicereportsList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamHostservicereportsList to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "points":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Points = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		case "passing":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Passing = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passing\"")
			}
		case "latest_check_time":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.LatestCheckTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latest_check_time\"")
			}
		case "host_service_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.HostServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_service_id\"")
			}
		case "service_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_id\"")
			}
		case "team_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		case "team_report_id":
			if err := func() error {
				s.TeamReportID.Reset()
				if err := s.TeamReportID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_report_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamHostservicereportsList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111001,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamHostservicereportsList) {
					name = jsonFieldsNameOfTeamHostservicereportsList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamHostservicereportsList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamHostservicereportsList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamHostservicesList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamHostservicesList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("service_id")
		e.Str(s.ServiceID)
	}
	{

		e.FieldStart("host_id")
		e.Str(s.HostID)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
}

var jsonFieldsNameOfTeamHostservicesList = [10]string{
	0: "id",
	1: "name",
	2: "display_name",
	3: "pause",
	4: "hidden",
	5: "create_time",
	6: "update_time",
	7: "service_id",
	8: "host_id",
	9: "team_id",
}

// Decode decodes TeamHostservicesList from json.
func (s *TeamHostservicesList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamHostservicesList to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "service_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_id\"")
			}
		case "host_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.HostID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_id\"")
			}
		case "team_id":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamHostservicesList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamHostservicesList) {
					name = jsonFieldsNameOfTeamHostservicesList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamHostservicesList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamHostservicesList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("number")
		e.Int(s.Number)
	}
}

var jsonFieldsNameOfTeamList = [8]string{
	0: "id",
	1: "name",
	2: "display_name",
	3: "pause",
	4: "hidden",
	5: "create_time",
	6: "update_time",
	7: "number",
}

// Decode decodes TeamList from json.
func (s *TeamList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "number":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b10000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamList) {
					name = jsonFieldsNameOfTeamList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("number")
		e.Int(s.Number)
	}
}

var jsonFieldsNameOfTeamRead = [8]string{
	0: "id",
	1: "name",
	2: "display_name",
	3: "pause",
	4: "hidden",
	5: "create_time",
	6: "update_time",
	7: "number",
}

// Decode decodes TeamRead from json.
func (s *TeamRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "number":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b10000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamRead) {
					name = jsonFieldsNameOfTeamRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamReportCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamReportCreate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("points")
		e.Int(s.Points)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
}

var jsonFieldsNameOfTeamReportCreate = [5]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "points",
	4: "team_id",
}

// Decode decodes TeamReportCreate from json.
func (s *TeamReportCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamReportCreate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "points":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Points = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		case "team_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamReportCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamReportCreate) {
					name = jsonFieldsNameOfTeamReportCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamReportCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamReportCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamReportHostservicereportsList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamReportHostservicereportsList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("points")
		e.Int(s.Points)
	}
	{

		e.FieldStart("passing")
		e.Bool(s.Passing)
	}
	{

		e.FieldStart("latest_check_time")
		json.EncodeDateTime(e, s.LatestCheckTime)
	}
	{

		e.FieldStart("host_service_id")
		e.Str(s.HostServiceID)
	}
	{

		e.FieldStart("service_id")
		e.Str(s.ServiceID)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
	{
		if s.TeamReportID.Set {
			e.FieldStart("team_report_id")
			s.TeamReportID.Encode(e)
		}
	}
}

var jsonFieldsNameOfTeamReportHostservicereportsList = [10]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "points",
	4: "passing",
	5: "latest_check_time",
	6: "host_service_id",
	7: "service_id",
	8: "team_id",
	9: "team_report_id",
}

// Decode decodes TeamReportHostservicereportsList from json.
func (s *TeamReportHostservicereportsList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamReportHostservicereportsList to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "points":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Points = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		case "passing":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Passing = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passing\"")
			}
		case "latest_check_time":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.LatestCheckTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latest_check_time\"")
			}
		case "host_service_id":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.HostServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host_service_id\"")
			}
		case "service_id":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ServiceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service_id\"")
			}
		case "team_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		case "team_report_id":
			if err := func() error {
				s.TeamReportID.Reset()
				if err := s.TeamReportID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_report_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamReportHostservicereportsList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111001,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamReportHostservicereportsList) {
					name = jsonFieldsNameOfTeamReportHostservicereportsList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamReportHostservicereportsList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamReportHostservicereportsList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamReportList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamReportList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("points")
		e.Int(s.Points)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
}

var jsonFieldsNameOfTeamReportList = [5]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "points",
	4: "team_id",
}

// Decode decodes TeamReportList from json.
func (s *TeamReportList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamReportList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "points":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Points = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		case "team_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamReportList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamReportList) {
					name = jsonFieldsNameOfTeamReportList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamReportList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamReportList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamReportRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamReportRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("points")
		e.Int(s.Points)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
}

var jsonFieldsNameOfTeamReportRead = [5]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "points",
	4: "team_id",
}

// Decode decodes TeamReportRead from json.
func (s *TeamReportRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamReportRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "points":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Points = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		case "team_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamReportRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamReportRead) {
					name = jsonFieldsNameOfTeamReportRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamReportRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamReportRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamReportTeamRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamReportTeamRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("number")
		e.Int(s.Number)
	}
}

var jsonFieldsNameOfTeamReportTeamRead = [8]string{
	0: "id",
	1: "name",
	2: "display_name",
	3: "pause",
	4: "hidden",
	5: "create_time",
	6: "update_time",
	7: "number",
}

// Decode decodes TeamReportTeamRead from json.
func (s *TeamReportTeamRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamReportTeamRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "number":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamReportTeamRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b10000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamReportTeamRead) {
					name = jsonFieldsNameOfTeamReportTeamRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamReportTeamRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamReportTeamRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamReportUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamReportUpdate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("points")
		e.Int(s.Points)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
}

var jsonFieldsNameOfTeamReportUpdate = [5]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "points",
	4: "team_id",
}

// Decode decodes TeamReportUpdate from json.
func (s *TeamReportUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamReportUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "points":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Points = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		case "team_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamReportUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamReportUpdate) {
					name = jsonFieldsNameOfTeamReportUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamReportUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamReportUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamTeamreportRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamTeamreportRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("points")
		e.Int(s.Points)
	}
	{

		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
}

var jsonFieldsNameOfTeamTeamreportRead = [5]string{
	0: "id",
	1: "create_time",
	2: "update_time",
	3: "points",
	4: "team_id",
}

// Decode decodes TeamTeamreportRead from json.
func (s *TeamTeamreportRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamTeamreportRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "points":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Points = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		case "team_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamTeamreportRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamTeamreportRead) {
					name = jsonFieldsNameOfTeamTeamreportRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamTeamreportRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamTeamreportRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamUpdate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		e.Str(s.ID)
	}
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("display_name")
		e.Str(s.DisplayName)
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.CreateTime.Set {
			e.FieldStart("create_time")
			s.CreateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{

		e.FieldStart("number")
		e.Int(s.Number)
	}
}

var jsonFieldsNameOfTeamUpdate = [8]string{
	0: "id",
	1: "name",
	2: "display_name",
	3: "pause",
	4: "hidden",
	5: "create_time",
	6: "update_time",
	7: "number",
}

// Decode decodes TeamUpdate from json.
func (s *TeamUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DisplayName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "create_time":
			if err := func() error {
				s.CreateTime.Reset()
				if err := s.CreateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create_time\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "number":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b10000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamUpdate) {
					name = jsonFieldsNameOfTeamUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateApiTokenReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateApiTokenReq) encodeFields(e *jx.Encoder) {
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Token.Set {
			e.FieldStart("token")
			s.Token.Encode(e)
		}
	}
	{
		if s.ExpiredAt.Set {
			e.FieldStart("expired_at")
			s.ExpiredAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfUpdateApiTokenReq = [3]string{
	0: "update_time",
	1: "token",
	2: "expired_at",
}

// Decode decodes UpdateApiTokenReq from json.
func (s *UpdateApiTokenReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateApiTokenReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "token":
			if err := func() error {
				s.Token.Reset()
				if err := s.Token.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "expired_at":
			if err := func() error {
				s.ExpiredAt.Reset()
				if err := s.ExpiredAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expired_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateApiTokenReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateApiTokenReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateApiTokenReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateCheckReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateCheckReq) encodeFields(e *jx.Encoder) {
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Log.Set {
			e.FieldStart("log")
			s.Log.Encode(e)
		}
	}
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.Passed.Set {
			e.FieldStart("passed")
			s.Passed.Encode(e)
		}
	}
	{
		if s.Round.Set {
			e.FieldStart("round")
			s.Round.Encode(e)
		}
	}
	{
		if s.Hostservice.Set {
			e.FieldStart("hostservice")
			s.Hostservice.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateCheckReq = [6]string{
	0: "update_time",
	1: "log",
	2: "error",
	3: "passed",
	4: "round",
	5: "hostservice",
}

// Decode decodes UpdateCheckReq from json.
func (s *UpdateCheckReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCheckReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "log":
			if err := func() error {
				s.Log.Reset()
				if err := s.Log.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"log\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "passed":
			if err := func() error {
				s.Passed.Reset()
				if err := s.Passed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passed\"")
			}
		case "round":
			if err := func() error {
				s.Round.Reset()
				if err := s.Round.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round\"")
			}
		case "hostservice":
			if err := func() error {
				s.Hostservice.Reset()
				if err := s.Hostservice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostservice\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateCheckReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCheckReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCheckReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateCompetitionReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateCompetitionReq) encodeFields(e *jx.Encoder) {
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.DisplayName.Set {
			e.FieldStart("display_name")
			s.DisplayName.Encode(e)
		}
	}
	{
		if s.RoundDuration.Set {
			e.FieldStart("round_duration")
			s.RoundDuration.Encode(e)
		}
	}
	{
		if s.CurrentRoundID.Set {
			e.FieldStart("current_round_id")
			s.CurrentRoundID.Encode(e)
		}
	}
	{
		if s.ViewableToPublic.Set {
			e.FieldStart("viewable_to_public")
			s.ViewableToPublic.Encode(e)
		}
	}
	{
		if s.IgnoreIncompleteRoundInScoring.Set {
			e.FieldStart("ignore_incomplete_round_in_scoring")
			s.IgnoreIncompleteRoundInScoring.Encode(e)
		}
	}
	{
		if s.ToBeStartedAt.Set {
			e.FieldStart("to_be_started_at")
			s.ToBeStartedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.StartedAt.Set {
			e.FieldStart("started_at")
			s.StartedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.FinishedAt.Set {
			e.FieldStart("finished_at")
			s.FinishedAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfUpdateCompetitionReq = [11]string{
	0:  "pause",
	1:  "update_time",
	2:  "name",
	3:  "display_name",
	4:  "round_duration",
	5:  "current_round_id",
	6:  "viewable_to_public",
	7:  "ignore_incomplete_round_in_scoring",
	8:  "to_be_started_at",
	9:  "started_at",
	10: "finished_at",
}

// Decode decodes UpdateCompetitionReq from json.
func (s *UpdateCompetitionReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCompetitionReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			if err := func() error {
				s.DisplayName.Reset()
				if err := s.DisplayName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "round_duration":
			if err := func() error {
				s.RoundDuration.Reset()
				if err := s.RoundDuration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_duration\"")
			}
		case "current_round_id":
			if err := func() error {
				s.CurrentRoundID.Reset()
				if err := s.CurrentRoundID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current_round_id\"")
			}
		case "viewable_to_public":
			if err := func() error {
				s.ViewableToPublic.Reset()
				if err := s.ViewableToPublic.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewable_to_public\"")
			}
		case "ignore_incomplete_round_in_scoring":
			if err := func() error {
				s.IgnoreIncompleteRoundInScoring.Reset()
				if err := s.IgnoreIncompleteRoundInScoring.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ignore_incomplete_round_in_scoring\"")
			}
		case "to_be_started_at":
			if err := func() error {
				s.ToBeStartedAt.Reset()
				if err := s.ToBeStartedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to_be_started_at\"")
			}
		case "started_at":
			if err := func() error {
				s.StartedAt.Reset()
				if err := s.StartedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "finished_at":
			if err := func() error {
				s.FinishedAt.Reset()
				if err := s.FinishedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finished_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateCompetitionReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCompetitionReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCompetitionReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateHostReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateHostReq) encodeFields(e *jx.Encoder) {
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Address.Set {
			e.FieldStart("address")
			s.Address.Encode(e)
		}
	}
	{
		if s.TeamID.Set {
			e.FieldStart("team_id")
			s.TeamID.Encode(e)
		}
	}
	{
		if s.Hostservices != nil {
			e.FieldStart("hostservices")
			e.ArrStart()
			for _, elem := range s.Hostservices {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Team.Set {
			e.FieldStart("team")
			s.Team.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateHostReq = [7]string{
	0: "pause",
	1: "hidden",
	2: "update_time",
	3: "address",
	4: "team_id",
	5: "hostservices",
	6: "team",
}

// Decode decodes UpdateHostReq from json.
func (s *UpdateHostReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHostReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "address":
			if err := func() error {
				s.Address.Reset()
				if err := s.Address.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "team_id":
			if err := func() error {
				s.TeamID.Reset()
				if err := s.TeamID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		case "hostservices":
			if err := func() error {
				s.Hostservices = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Hostservices = append(s.Hostservices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostservices\"")
			}
		case "team":
			if err := func() error {
				s.Team.Reset()
				if err := s.Team.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateHostReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateHostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateHostServiceReportReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateHostServiceReportReq) encodeFields(e *jx.Encoder) {
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Points.Set {
			e.FieldStart("points")
			s.Points.Encode(e)
		}
	}
	{
		if s.Passing.Set {
			e.FieldStart("passing")
			s.Passing.Encode(e)
		}
	}
	{
		if s.LatestCheckTime.Set {
			e.FieldStart("latest_check_time")
			s.LatestCheckTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Hostservice.Set {
			e.FieldStart("hostservice")
			s.Hostservice.Encode(e)
		}
	}
	{
		if s.Service.Set {
			e.FieldStart("service")
			s.Service.Encode(e)
		}
	}
	{
		if s.Team.Set {
			e.FieldStart("team")
			s.Team.Encode(e)
		}
	}
	{
		if s.Teamreport.Set {
			e.FieldStart("teamreport")
			s.Teamreport.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateHostServiceReportReq = [8]string{
	0: "update_time",
	1: "points",
	2: "passing",
	3: "latest_check_time",
	4: "hostservice",
	5: "service",
	6: "team",
	7: "teamreport",
}

// Decode decodes UpdateHostServiceReportReq from json.
func (s *UpdateHostServiceReportReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHostServiceReportReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "points":
			if err := func() error {
				s.Points.Reset()
				if err := s.Points.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		case "passing":
			if err := func() error {
				s.Passing.Reset()
				if err := s.Passing.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passing\"")
			}
		case "latest_check_time":
			if err := func() error {
				s.LatestCheckTime.Reset()
				if err := s.LatestCheckTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latest_check_time\"")
			}
		case "hostservice":
			if err := func() error {
				s.Hostservice.Reset()
				if err := s.Hostservice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostservice\"")
			}
		case "service":
			if err := func() error {
				s.Service.Reset()
				if err := s.Service.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service\"")
			}
		case "team":
			if err := func() error {
				s.Team.Reset()
				if err := s.Team.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team\"")
			}
		case "teamreport":
			if err := func() error {
				s.Teamreport.Reset()
				if err := s.Teamreport.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamreport\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateHostServiceReportReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateHostServiceReportReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHostServiceReportReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateHostServiceReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateHostServiceReq) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.DisplayName.Set {
			e.FieldStart("display_name")
			s.DisplayName.Encode(e)
		}
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Checks != nil {
			e.FieldStart("checks")
			e.ArrStart()
			for _, elem := range s.Checks {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Properties != nil {
			e.FieldStart("properties")
			e.ArrStart()
			for _, elem := range s.Properties {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Hostservicereport.Set {
			e.FieldStart("hostservicereport")
			s.Hostservicereport.Encode(e)
		}
	}
	{
		if s.Service.Set {
			e.FieldStart("service")
			s.Service.Encode(e)
		}
	}
	{
		if s.Host.Set {
			e.FieldStart("host")
			s.Host.Encode(e)
		}
	}
	{
		if s.Team.Set {
			e.FieldStart("team")
			s.Team.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateHostServiceReq = [11]string{
	0:  "name",
	1:  "display_name",
	2:  "pause",
	3:  "hidden",
	4:  "update_time",
	5:  "checks",
	6:  "properties",
	7:  "hostservicereport",
	8:  "service",
	9:  "host",
	10: "team",
}

// Decode decodes UpdateHostServiceReq from json.
func (s *UpdateHostServiceReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHostServiceReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			if err := func() error {
				s.DisplayName.Reset()
				if err := s.DisplayName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "checks":
			if err := func() error {
				s.Checks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Checks = append(s.Checks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checks\"")
			}
		case "properties":
			if err := func() error {
				s.Properties = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Properties = append(s.Properties, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"properties\"")
			}
		case "hostservicereport":
			if err := func() error {
				s.Hostservicereport.Reset()
				if err := s.Hostservicereport.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostservicereport\"")
			}
		case "service":
			if err := func() error {
				s.Service.Reset()
				if err := s.Service.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service\"")
			}
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "team":
			if err := func() error {
				s.Team.Reset()
				if err := s.Team.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateHostServiceReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateHostServiceReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHostServiceReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdatePropertyReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdatePropertyReq) encodeFields(e *jx.Encoder) {
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
	{
		if s.Hostservice.Set {
			e.FieldStart("hostservice")
			s.Hostservice.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdatePropertyReq = [3]string{
	0: "update_time",
	1: "value",
	2: "hostservice",
}

// Decode decodes UpdatePropertyReq from json.
func (s *UpdatePropertyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePropertyReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "hostservice":
			if err := func() error {
				s.Hostservice.Reset()
				if err := s.Hostservice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostservice\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdatePropertyReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdatePropertyReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatePropertyReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateRoundReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateRoundReq) encodeFields(e *jx.Encoder) {
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.RoundNumber.Set {
			e.FieldStart("round_number")
			s.RoundNumber.Encode(e)
		}
	}
	{
		if s.NumOfIntendedChecks.Set {
			e.FieldStart("num_of_intended_checks")
			s.NumOfIntendedChecks.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.StartedAt.Set {
			e.FieldStart("started_at")
			s.StartedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.FinishedAt.Set {
			e.FieldStart("finished_at")
			s.FinishedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Checks != nil {
			e.FieldStart("checks")
			e.ArrStart()
			for _, elem := range s.Checks {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUpdateRoundReq = [7]string{
	0: "update_time",
	1: "round_number",
	2: "num_of_intended_checks",
	3: "status",
	4: "started_at",
	5: "finished_at",
	6: "checks",
}

// Decode decodes UpdateRoundReq from json.
func (s *UpdateRoundReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRoundReq to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "round_number":
			if err := func() error {
				s.RoundNumber.Reset()
				if err := s.RoundNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_number\"")
			}
		case "num_of_intended_checks":
			if err := func() error {
				s.NumOfIntendedChecks.Reset()
				if err := s.NumOfIntendedChecks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"num_of_intended_checks\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "started_at":
			if err := func() error {
				s.StartedAt.Reset()
				if err := s.StartedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"started_at\"")
			}
		case "finished_at":
			if err := func() error {
				s.FinishedAt.Reset()
				if err := s.FinishedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"finished_at\"")
			}
		case "checks":
			if err := func() error {
				s.Checks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Checks = append(s.Checks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateRoundReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRoundReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRoundReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateRoundReqStatus as json.
func (s UpdateRoundReqStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateRoundReqStatus from json.
func (s *UpdateRoundReqStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRoundReqStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateRoundReqStatus(v) {
	case UpdateRoundReqStatusStarted:
		*s = UpdateRoundReqStatusStarted
	case UpdateRoundReqStatusOngoing:
		*s = UpdateRoundReqStatusOngoing
	case UpdateRoundReqStatusFinished:
		*s = UpdateRoundReqStatusFinished
	case UpdateRoundReqStatusIncomplete:
		*s = UpdateRoundReqStatusIncomplete
	default:
		*s = UpdateRoundReqStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateRoundReqStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRoundReqStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateServiceReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateServiceReq) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.DisplayName.Set {
			e.FieldStart("display_name")
			s.DisplayName.Encode(e)
		}
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Weight.Set {
			e.FieldStart("weight")
			s.Weight.Encode(e)
		}
	}
	{
		if s.PointBoost.Set {
			e.FieldStart("point_boost")
			s.PointBoost.Encode(e)
		}
	}
	{
		if s.RoundFrequency.Set {
			e.FieldStart("round_frequency")
			s.RoundFrequency.Encode(e)
		}
	}
	{
		if s.RoundDelay.Set {
			e.FieldStart("round_delay")
			s.RoundDelay.Encode(e)
		}
	}
	{
		if s.Hostservices != nil {
			e.FieldStart("hostservices")
			e.ArrStart()
			for _, elem := range s.Hostservices {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Hostservicereports != nil {
			e.FieldStart("hostservicereports")
			e.ArrStart()
			for _, elem := range s.Hostservicereports {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUpdateServiceReq = [12]string{
	0:  "name",
	1:  "display_name",
	2:  "pause",
	3:  "hidden",
	4:  "update_time",
	5:  "type",
	6:  "weight",
	7:  "point_boost",
	8:  "round_frequency",
	9:  "round_delay",
	10: "hostservices",
	11: "hostservicereports",
}

// Decode decodes UpdateServiceReq from json.
func (s *UpdateServiceReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateServiceReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			if err := func() error {
				s.DisplayName.Reset()
				if err := s.DisplayName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "point_boost":
			if err := func() error {
				s.PointBoost.Reset()
				if err := s.PointBoost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"point_boost\"")
			}
		case "round_frequency":
			if err := func() error {
				s.RoundFrequency.Reset()
				if err := s.RoundFrequency.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_frequency\"")
			}
		case "round_delay":
			if err := func() error {
				s.RoundDelay.Reset()
				if err := s.RoundDelay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"round_delay\"")
			}
		case "hostservices":
			if err := func() error {
				s.Hostservices = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Hostservices = append(s.Hostservices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostservices\"")
			}
		case "hostservicereports":
			if err := func() error {
				s.Hostservicereports = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Hostservicereports = append(s.Hostservicereports, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostservicereports\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateServiceReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateServiceReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateServiceReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateServiceReqType as json.
func (s UpdateServiceReqType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateServiceReqType from json.
func (s *UpdateServiceReqType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateServiceReqType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateServiceReqType(v) {
	case UpdateServiceReqTypeFtp:
		*s = UpdateServiceReqTypeFtp
	case UpdateServiceReqTypeSSH:
		*s = UpdateServiceReqTypeSSH
	case UpdateServiceReqTypeWinrm:
		*s = UpdateServiceReqTypeWinrm
	case UpdateServiceReqTypePing:
		*s = UpdateServiceReqTypePing
	case UpdateServiceReqTypeHTTP:
		*s = UpdateServiceReqTypeHTTP
	case UpdateServiceReqTypeLdap:
		*s = UpdateServiceReqTypeLdap
	case UpdateServiceReqTypeDNS:
		*s = UpdateServiceReqTypeDNS
	case UpdateServiceReqTypeSmb:
		*s = UpdateServiceReqTypeSmb
	case UpdateServiceReqTypeImap:
		*s = UpdateServiceReqTypeImap
	case UpdateServiceReqTypeSQL:
		*s = UpdateServiceReqTypeSQL
	case UpdateServiceReqTypeCaldav:
		*s = UpdateServiceReqTypeCaldav
	default:
		*s = UpdateServiceReqType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateServiceReqType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateServiceReqType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateTeamReportReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateTeamReportReq) encodeFields(e *jx.Encoder) {
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Points.Set {
			e.FieldStart("points")
			s.Points.Encode(e)
		}
	}
	{
		if s.Team.Set {
			e.FieldStart("team")
			s.Team.Encode(e)
		}
	}
	{
		if s.Hostservicereports != nil {
			e.FieldStart("hostservicereports")
			e.ArrStart()
			for _, elem := range s.Hostservicereports {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUpdateTeamReportReq = [4]string{
	0: "update_time",
	1: "points",
	2: "team",
	3: "hostservicereports",
}

// Decode decodes UpdateTeamReportReq from json.
func (s *UpdateTeamReportReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTeamReportReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "points":
			if err := func() error {
				s.Points.Reset()
				if err := s.Points.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"points\"")
			}
		case "team":
			if err := func() error {
				s.Team.Reset()
				if err := s.Team.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team\"")
			}
		case "hostservicereports":
			if err := func() error {
				s.Hostservicereports = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Hostservicereports = append(s.Hostservicereports, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostservicereports\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateTeamReportReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTeamReportReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTeamReportReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateTeamReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateTeamReq) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.DisplayName.Set {
			e.FieldStart("display_name")
			s.DisplayName.Encode(e)
		}
	}
	{
		if s.Pause.Set {
			e.FieldStart("pause")
			s.Pause.Encode(e)
		}
	}
	{
		if s.Hidden.Set {
			e.FieldStart("hidden")
			s.Hidden.Encode(e)
		}
	}
	{
		if s.UpdateTime.Set {
			e.FieldStart("update_time")
			s.UpdateTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Number.Set {
			e.FieldStart("number")
			s.Number.Encode(e)
		}
	}
	{
		if s.Hosts != nil {
			e.FieldStart("hosts")
			e.ArrStart()
			for _, elem := range s.Hosts {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Hostservices != nil {
			e.FieldStart("hostservices")
			e.ArrStart()
			for _, elem := range s.Hostservices {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Teamreport.Set {
			e.FieldStart("teamreport")
			s.Teamreport.Encode(e)
		}
	}
	{
		if s.Hostservicereports != nil {
			e.FieldStart("hostservicereports")
			e.ArrStart()
			for _, elem := range s.Hostservicereports {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUpdateTeamReq = [10]string{
	0: "name",
	1: "display_name",
	2: "pause",
	3: "hidden",
	4: "update_time",
	5: "number",
	6: "hosts",
	7: "hostservices",
	8: "teamreport",
	9: "hostservicereports",
}

// Decode decodes UpdateTeamReq from json.
func (s *UpdateTeamReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTeamReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			if err := func() error {
				s.DisplayName.Reset()
				if err := s.DisplayName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "pause":
			if err := func() error {
				s.Pause.Reset()
				if err := s.Pause.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pause\"")
			}
		case "hidden":
			if err := func() error {
				s.Hidden.Reset()
				if err := s.Hidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hidden\"")
			}
		case "update_time":
			if err := func() error {
				s.UpdateTime.Reset()
				if err := s.UpdateTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"update_time\"")
			}
		case "number":
			if err := func() error {
				s.Number.Reset()
				if err := s.Number.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "hosts":
			if err := func() error {
				s.Hosts = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Hosts = append(s.Hosts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hosts\"")
			}
		case "hostservices":
			if err := func() error {
				s.Hostservices = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Hostservices = append(s.Hostservices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostservices\"")
			}
		case "teamreport":
			if err := func() error {
				s.Teamreport.Reset()
				if err := s.Teamreport.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teamreport\"")
			}
		case "hostservicereports":
			if err := func() error {
				s.Hostservicereports = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Hostservicereports = append(s.Hostservicereports, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostservicereports\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateTeamReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTeamReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTeamReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
