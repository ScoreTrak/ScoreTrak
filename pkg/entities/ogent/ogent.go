// Code generated by ent, DO NOT EDIT.

package ogent

import (
	"context"
	"net/http"

	"github.com/ScoreTrak/ScoreTrak/pkg/entities"
	"github.com/ScoreTrak/ScoreTrak/pkg/entities/apitoken"
	"github.com/ScoreTrak/ScoreTrak/pkg/entities/check"
	"github.com/ScoreTrak/ScoreTrak/pkg/entities/competition"
	"github.com/ScoreTrak/ScoreTrak/pkg/entities/host"
	"github.com/ScoreTrak/ScoreTrak/pkg/entities/hostservice"
	"github.com/ScoreTrak/ScoreTrak/pkg/entities/hostservicereport"
	"github.com/ScoreTrak/ScoreTrak/pkg/entities/property"
	"github.com/ScoreTrak/ScoreTrak/pkg/entities/round"
	"github.com/ScoreTrak/ScoreTrak/pkg/entities/service"
	"github.com/ScoreTrak/ScoreTrak/pkg/entities/team"
	"github.com/ScoreTrak/ScoreTrak/pkg/entities/teamreport"
	"github.com/ScoreTrak/ScoreTrak/pkg/scorer/scorerservice"
	"github.com/go-faster/jx"
)

// OgentHandler implements the ogen generated Handler interface and uses Ent as data layer.
type OgentHandler struct {
	client *entities.Client
}

// NewOgentHandler returns a new OgentHandler.
func NewOgentHandler(c *entities.Client) *OgentHandler { return &OgentHandler{c} }

// rawError renders err as json string.
func rawError(err error) jx.Raw {
	var e jx.Encoder
	e.Str(err.Error())
	return e.Bytes()
}

// CreateApiToken handles POST /api-tokens requests.
func (h *OgentHandler) CreateApiToken(ctx context.Context, req *CreateApiTokenReq) (CreateApiTokenRes, error) {
	b := h.client.ApiToken.Create()
	// Add all fields.
	if v, ok := req.CreateTime.Get(); ok {
		b.SetCreateTime(v)
	}
	if v, ok := req.UpdateTime.Get(); ok {
		b.SetUpdateTime(v)
	}
	b.SetToken(req.Token)
	b.SetRoleID(req.RoleID)
	b.SetExpiredAt(req.ExpiredAt)
	b.SetUserID(req.UserID)
	// Add all edges.
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.ApiToken.Query().Where(apitoken.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewApiTokenCreate(e), nil
}

// ReadApiToken handles GET /api-tokens/{id} requests.
func (h *OgentHandler) ReadApiToken(ctx context.Context, params ReadApiTokenParams) (ReadApiTokenRes, error) {
	q := h.client.ApiToken.Query().Where(apitoken.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewApiTokenRead(e), nil
}

// UpdateApiToken handles PATCH /api-tokens/{id} requests.
func (h *OgentHandler) UpdateApiToken(ctx context.Context, req *UpdateApiTokenReq, params UpdateApiTokenParams) (UpdateApiTokenRes, error) {
	b := h.client.ApiToken.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.UpdateTime.Get(); ok {
		b.SetUpdateTime(v)
	}
	if v, ok := req.Token.Get(); ok {
		b.SetToken(v)
	}
	if v, ok := req.ExpiredAt.Get(); ok {
		b.SetExpiredAt(v)
	}
	// Add all edges.
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.ApiToken.Query().Where(apitoken.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewApiTokenUpdate(e), nil
}

// DeleteApiToken handles DELETE /api-tokens/{id} requests.
func (h *OgentHandler) DeleteApiToken(ctx context.Context, params DeleteApiTokenParams) (DeleteApiTokenRes, error) {
	err := h.client.ApiToken.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteApiTokenNoContent), nil

}

// ListApiToken handles GET /api-tokens requests.
func (h *OgentHandler) ListApiToken(ctx context.Context, params ListApiTokenParams) (ListApiTokenRes, error) {
	q := h.client.ApiToken.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewApiTokenLists(es)
	return (*ListApiTokenOKApplicationJSON)(&r), nil
}

// CreateCheck handles POST /checks requests.
func (h *OgentHandler) CreateCheck(ctx context.Context, req *CreateCheckReq) (CreateCheckRes, error) {
	b := h.client.Check.Create()
	// Add all fields.
	if v, ok := req.CreateTime.Get(); ok {
		b.SetCreateTime(v)
	}
	if v, ok := req.UpdateTime.Get(); ok {
		b.SetUpdateTime(v)
	}
	if v, ok := req.Log.Get(); ok {
		b.SetLog(v)
	}
	if v, ok := req.Error.Get(); ok {
		b.SetError(v)
	}
	b.SetPassed(req.Passed)
	b.SetRoundID(req.RoundID)
	b.SetHostServiceID(req.HostServiceID)
	// Add all edges.
	b.SetRoundID(req.Round)
	b.SetHostserviceID(req.Hostservice)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Check.Query().Where(check.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewCheckCreate(e), nil
}

// ReadCheck handles GET /checks/{id} requests.
func (h *OgentHandler) ReadCheck(ctx context.Context, params ReadCheckParams) (ReadCheckRes, error) {
	q := h.client.Check.Query().Where(check.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewCheckRead(e), nil
}

// UpdateCheck handles PATCH /checks/{id} requests.
func (h *OgentHandler) UpdateCheck(ctx context.Context, req *UpdateCheckReq, params UpdateCheckParams) (UpdateCheckRes, error) {
	b := h.client.Check.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.UpdateTime.Get(); ok {
		b.SetUpdateTime(v)
	}
	if v, ok := req.Log.Get(); ok {
		b.SetLog(v)
	}
	if v, ok := req.Error.Get(); ok {
		b.SetError(v)
	}
	if v, ok := req.Passed.Get(); ok {
		b.SetPassed(v)
	}
	// Add all edges.
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Check.Query().Where(check.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewCheckUpdate(e), nil
}

// DeleteCheck handles DELETE /checks/{id} requests.
func (h *OgentHandler) DeleteCheck(ctx context.Context, params DeleteCheckParams) (DeleteCheckRes, error) {
	err := h.client.Check.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteCheckNoContent), nil

}

// ListCheck handles GET /checks requests.
func (h *OgentHandler) ListCheck(ctx context.Context, params ListCheckParams) (ListCheckRes, error) {
	q := h.client.Check.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewCheckLists(es)
	return (*ListCheckOKApplicationJSON)(&r), nil
}

// ReadCheckRound handles GET /checks/{id}/round requests.
func (h *OgentHandler) ReadCheckRound(ctx context.Context, params ReadCheckRoundParams) (ReadCheckRoundRes, error) {
	q := h.client.Check.Query().Where(check.IDEQ(params.ID)).QueryRound()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewCheckRoundRead(e), nil
}

// ReadCheckHostservice handles GET /checks/{id}/hostservice requests.
func (h *OgentHandler) ReadCheckHostservice(ctx context.Context, params ReadCheckHostserviceParams) (ReadCheckHostserviceRes, error) {
	q := h.client.Check.Query().Where(check.IDEQ(params.ID)).QueryHostservice()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewCheckHostserviceRead(e), nil
}

// CreateCompetition handles POST /competitions requests.
func (h *OgentHandler) CreateCompetition(ctx context.Context, req *CreateCompetitionReq) (CreateCompetitionRes, error) {
	b := h.client.Competition.Create()
	// Add all fields.
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.CreateTime.Get(); ok {
		b.SetCreateTime(v)
	}
	if v, ok := req.UpdateTime.Get(); ok {
		b.SetUpdateTime(v)
	}
	b.SetName(req.Name)
	b.SetDisplayName(req.DisplayName)
	if v, ok := req.RoundDuration.Get(); ok {
		b.SetRoundDuration(v)
	}
	if v, ok := req.CurrentRoundID.Get(); ok {
		b.SetCurrentRoundID(v)
	}
	if v, ok := req.ViewableToPublic.Get(); ok {
		b.SetViewableToPublic(v)
	}
	if v, ok := req.IgnoreIncompleteRoundInScoring.Get(); ok {
		b.SetIgnoreIncompleteRoundInScoring(v)
	}
	if v, ok := req.ToBeStartedAt.Get(); ok {
		b.SetToBeStartedAt(v)
	}
	if v, ok := req.StartedAt.Get(); ok {
		b.SetStartedAt(v)
	}
	if v, ok := req.FinishedAt.Get(); ok {
		b.SetFinishedAt(v)
	}
	// Add all edges.
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Competition.Query().Where(competition.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewCompetitionCreate(e), nil
}

// ReadCompetition handles GET /competitions/{id} requests.
func (h *OgentHandler) ReadCompetition(ctx context.Context, params ReadCompetitionParams) (ReadCompetitionRes, error) {
	q := h.client.Competition.Query().Where(competition.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewCompetitionRead(e), nil
}

// UpdateCompetition handles PATCH /competitions/{id} requests.
func (h *OgentHandler) UpdateCompetition(ctx context.Context, req *UpdateCompetitionReq, params UpdateCompetitionParams) (UpdateCompetitionRes, error) {
	b := h.client.Competition.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.UpdateTime.Get(); ok {
		b.SetUpdateTime(v)
	}
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.DisplayName.Get(); ok {
		b.SetDisplayName(v)
	}
	if v, ok := req.RoundDuration.Get(); ok {
		b.SetRoundDuration(v)
	}
	if v, ok := req.CurrentRoundID.Get(); ok {
		b.SetCurrentRoundID(v)
	}
	if v, ok := req.ViewableToPublic.Get(); ok {
		b.SetViewableToPublic(v)
	}
	if v, ok := req.IgnoreIncompleteRoundInScoring.Get(); ok {
		b.SetIgnoreIncompleteRoundInScoring(v)
	}
	if v, ok := req.ToBeStartedAt.Get(); ok {
		b.SetToBeStartedAt(v)
	}
	if v, ok := req.StartedAt.Get(); ok {
		b.SetStartedAt(v)
	}
	if v, ok := req.FinishedAt.Get(); ok {
		b.SetFinishedAt(v)
	}
	// Add all edges.
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Competition.Query().Where(competition.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewCompetitionUpdate(e), nil
}

// CreateHost handles POST /hosts requests.
func (h *OgentHandler) CreateHost(ctx context.Context, req *CreateHostReq) (CreateHostRes, error) {
	b := h.client.Host.Create()
	// Add all fields.
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	if v, ok := req.CreateTime.Get(); ok {
		b.SetCreateTime(v)
	}
	if v, ok := req.UpdateTime.Get(); ok {
		b.SetUpdateTime(v)
	}
	b.SetAddress(req.Address)
	b.SetTeamID(req.TeamID)
	// Add all edges.
	b.AddHostserviceIDs(req.Hostservices...)
	b.SetTeamID(req.Team)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Host.Query().Where(host.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewHostCreate(e), nil
}

// ReadHost handles GET /hosts/{id} requests.
func (h *OgentHandler) ReadHost(ctx context.Context, params ReadHostParams) (ReadHostRes, error) {
	q := h.client.Host.Query().Where(host.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewHostRead(e), nil
}

// UpdateHost handles PATCH /hosts/{id} requests.
func (h *OgentHandler) UpdateHost(ctx context.Context, req *UpdateHostReq, params UpdateHostParams) (UpdateHostRes, error) {
	b := h.client.Host.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	if v, ok := req.UpdateTime.Get(); ok {
		b.SetUpdateTime(v)
	}
	if v, ok := req.Address.Get(); ok {
		b.SetAddress(v)
	}
	if v, ok := req.TeamID.Get(); ok {
		b.SetTeamID(v)
	}
	// Add all edges.
	if req.Hostservices != nil {
		b.ClearHostservices().AddHostserviceIDs(req.Hostservices...)
	}
	if v, ok := req.Team.Get(); ok {
		b.SetTeamID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Host.Query().Where(host.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewHostUpdate(e), nil
}

// DeleteHost handles DELETE /hosts/{id} requests.
func (h *OgentHandler) DeleteHost(ctx context.Context, params DeleteHostParams) (DeleteHostRes, error) {
	err := h.client.Host.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteHostNoContent), nil

}

// ListHost handles GET /hosts requests.
func (h *OgentHandler) ListHost(ctx context.Context, params ListHostParams) (ListHostRes, error) {
	q := h.client.Host.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewHostLists(es)
	return (*ListHostOKApplicationJSON)(&r), nil
}

// ListHostHostservices handles GET /hosts/{id}/hostservices requests.
func (h *OgentHandler) ListHostHostservices(ctx context.Context, params ListHostHostservicesParams) (ListHostHostservicesRes, error) {
	q := h.client.Host.Query().Where(host.IDEQ(params.ID)).QueryHostservices()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewHostHostservicesLists(es)
	return (*ListHostHostservicesOKApplicationJSON)(&r), nil
}

// ReadHostTeam handles GET /hosts/{id}/team requests.
func (h *OgentHandler) ReadHostTeam(ctx context.Context, params ReadHostTeamParams) (ReadHostTeamRes, error) {
	q := h.client.Host.Query().Where(host.IDEQ(params.ID)).QueryTeam()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewHostTeamRead(e), nil
}

// CreateHostService handles POST /host-services requests.
func (h *OgentHandler) CreateHostService(ctx context.Context, req *CreateHostServiceReq) (CreateHostServiceRes, error) {
	b := h.client.HostService.Create()
	// Add all fields.
	b.SetName(req.Name)
	b.SetDisplayName(req.DisplayName)
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	if v, ok := req.CreateTime.Get(); ok {
		b.SetCreateTime(v)
	}
	if v, ok := req.UpdateTime.Get(); ok {
		b.SetUpdateTime(v)
	}
	b.SetServiceID(req.ServiceID)
	b.SetHostID(req.HostID)
	b.SetTeamID(req.TeamID)
	// Add all edges.
	b.AddCheckIDs(req.Checks...)
	b.AddPropertyIDs(req.Properties...)
	if v, ok := req.Hostservicereport.Get(); ok {
		b.SetHostservicereportID(v)
	}
	b.SetServiceID(req.Service)
	b.SetHostID(req.Host)
	b.SetTeamID(req.Team)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.HostService.Query().Where(hostservice.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewHostServiceCreate(e), nil
}

// ReadHostService handles GET /host-services/{id} requests.
func (h *OgentHandler) ReadHostService(ctx context.Context, params ReadHostServiceParams) (ReadHostServiceRes, error) {
	q := h.client.HostService.Query().Where(hostservice.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewHostServiceRead(e), nil
}

// UpdateHostService handles PATCH /host-services/{id} requests.
func (h *OgentHandler) UpdateHostService(ctx context.Context, req *UpdateHostServiceReq, params UpdateHostServiceParams) (UpdateHostServiceRes, error) {
	b := h.client.HostService.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.DisplayName.Get(); ok {
		b.SetDisplayName(v)
	}
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	if v, ok := req.UpdateTime.Get(); ok {
		b.SetUpdateTime(v)
	}
	// Add all edges.
	if req.Checks != nil {
		b.ClearChecks().AddCheckIDs(req.Checks...)
	}
	if req.Properties != nil {
		b.ClearProperties().AddPropertyIDs(req.Properties...)
	}
	if v, ok := req.Hostservicereport.Get(); ok {
		b.SetHostservicereportID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.HostService.Query().Where(hostservice.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewHostServiceUpdate(e), nil
}

// DeleteHostService handles DELETE /host-services/{id} requests.
func (h *OgentHandler) DeleteHostService(ctx context.Context, params DeleteHostServiceParams) (DeleteHostServiceRes, error) {
	err := h.client.HostService.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteHostServiceNoContent), nil

}

// ListHostService handles GET /host-services requests.
func (h *OgentHandler) ListHostService(ctx context.Context, params ListHostServiceParams) (ListHostServiceRes, error) {
	q := h.client.HostService.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewHostServiceLists(es)
	return (*ListHostServiceOKApplicationJSON)(&r), nil
}

// ListHostServiceChecks handles GET /host-services/{id}/checks requests.
func (h *OgentHandler) ListHostServiceChecks(ctx context.Context, params ListHostServiceChecksParams) (ListHostServiceChecksRes, error) {
	q := h.client.HostService.Query().Where(hostservice.IDEQ(params.ID)).QueryChecks()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewHostServiceChecksLists(es)
	return (*ListHostServiceChecksOKApplicationJSON)(&r), nil
}

// ListHostServiceProperties handles GET /host-services/{id}/properties requests.
func (h *OgentHandler) ListHostServiceProperties(ctx context.Context, params ListHostServicePropertiesParams) (ListHostServicePropertiesRes, error) {
	q := h.client.HostService.Query().Where(hostservice.IDEQ(params.ID)).QueryProperties()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewHostServicePropertiesLists(es)
	return (*ListHostServicePropertiesOKApplicationJSON)(&r), nil
}

// ReadHostServiceHostservicereport handles GET /host-services/{id}/hostservicereport requests.
func (h *OgentHandler) ReadHostServiceHostservicereport(ctx context.Context, params ReadHostServiceHostservicereportParams) (ReadHostServiceHostservicereportRes, error) {
	q := h.client.HostService.Query().Where(hostservice.IDEQ(params.ID)).QueryHostservicereport()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewHostServiceHostservicereportRead(e), nil
}

// ReadHostServiceService handles GET /host-services/{id}/service requests.
func (h *OgentHandler) ReadHostServiceService(ctx context.Context, params ReadHostServiceServiceParams) (ReadHostServiceServiceRes, error) {
	q := h.client.HostService.Query().Where(hostservice.IDEQ(params.ID)).QueryService()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewHostServiceServiceRead(e), nil
}

// ReadHostServiceHost handles GET /host-services/{id}/host requests.
func (h *OgentHandler) ReadHostServiceHost(ctx context.Context, params ReadHostServiceHostParams) (ReadHostServiceHostRes, error) {
	q := h.client.HostService.Query().Where(hostservice.IDEQ(params.ID)).QueryHost()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewHostServiceHostRead(e), nil
}

// ReadHostServiceTeam handles GET /host-services/{id}/team requests.
func (h *OgentHandler) ReadHostServiceTeam(ctx context.Context, params ReadHostServiceTeamParams) (ReadHostServiceTeamRes, error) {
	q := h.client.HostService.Query().Where(hostservice.IDEQ(params.ID)).QueryTeam()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewHostServiceTeamRead(e), nil
}

// CreateHostServiceReport handles POST /host-service-reports requests.
func (h *OgentHandler) CreateHostServiceReport(ctx context.Context, req *CreateHostServiceReportReq) (CreateHostServiceReportRes, error) {
	b := h.client.HostServiceReport.Create()
	// Add all fields.
	if v, ok := req.CreateTime.Get(); ok {
		b.SetCreateTime(v)
	}
	if v, ok := req.UpdateTime.Get(); ok {
		b.SetUpdateTime(v)
	}
	b.SetPoints(req.Points)
	b.SetPassing(req.Passing)
	b.SetLatestCheckTime(req.LatestCheckTime)
	b.SetHostServiceID(req.HostServiceID)
	b.SetServiceID(req.ServiceID)
	b.SetTeamID(req.TeamID)
	if v, ok := req.TeamReportID.Get(); ok {
		b.SetTeamReportID(v)
	}
	// Add all edges.
	b.SetHostserviceID(req.Hostservice)
	b.SetServiceID(req.Service)
	b.SetTeamID(req.Team)
	if v, ok := req.Teamreport.Get(); ok {
		b.SetTeamreportID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.HostServiceReport.Query().Where(hostservicereport.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewHostServiceReportCreate(e), nil
}

// ReadHostServiceReport handles GET /host-service-reports/{id} requests.
func (h *OgentHandler) ReadHostServiceReport(ctx context.Context, params ReadHostServiceReportParams) (ReadHostServiceReportRes, error) {
	q := h.client.HostServiceReport.Query().Where(hostservicereport.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewHostServiceReportRead(e), nil
}

// UpdateHostServiceReport handles PATCH /host-service-reports/{id} requests.
func (h *OgentHandler) UpdateHostServiceReport(ctx context.Context, req *UpdateHostServiceReportReq, params UpdateHostServiceReportParams) (UpdateHostServiceReportRes, error) {
	b := h.client.HostServiceReport.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.UpdateTime.Get(); ok {
		b.SetUpdateTime(v)
	}
	if v, ok := req.Points.Get(); ok {
		b.SetPoints(v)
	}
	if v, ok := req.Passing.Get(); ok {
		b.SetPassing(v)
	}
	if v, ok := req.LatestCheckTime.Get(); ok {
		b.SetLatestCheckTime(v)
	}
	// Add all edges.
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.HostServiceReport.Query().Where(hostservicereport.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewHostServiceReportUpdate(e), nil
}

// DeleteHostServiceReport handles DELETE /host-service-reports/{id} requests.
func (h *OgentHandler) DeleteHostServiceReport(ctx context.Context, params DeleteHostServiceReportParams) (DeleteHostServiceReportRes, error) {
	err := h.client.HostServiceReport.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteHostServiceReportNoContent), nil

}

// ListHostServiceReport handles GET /host-service-reports requests.
func (h *OgentHandler) ListHostServiceReport(ctx context.Context, params ListHostServiceReportParams) (ListHostServiceReportRes, error) {
	q := h.client.HostServiceReport.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewHostServiceReportLists(es)
	return (*ListHostServiceReportOKApplicationJSON)(&r), nil
}

// ReadHostServiceReportHostservice handles GET /host-service-reports/{id}/hostservice requests.
func (h *OgentHandler) ReadHostServiceReportHostservice(ctx context.Context, params ReadHostServiceReportHostserviceParams) (ReadHostServiceReportHostserviceRes, error) {
	q := h.client.HostServiceReport.Query().Where(hostservicereport.IDEQ(params.ID)).QueryHostservice()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewHostServiceReportHostserviceRead(e), nil
}

// ReadHostServiceReportService handles GET /host-service-reports/{id}/service requests.
func (h *OgentHandler) ReadHostServiceReportService(ctx context.Context, params ReadHostServiceReportServiceParams) (ReadHostServiceReportServiceRes, error) {
	q := h.client.HostServiceReport.Query().Where(hostservicereport.IDEQ(params.ID)).QueryService()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewHostServiceReportServiceRead(e), nil
}

// ReadHostServiceReportTeam handles GET /host-service-reports/{id}/team requests.
func (h *OgentHandler) ReadHostServiceReportTeam(ctx context.Context, params ReadHostServiceReportTeamParams) (ReadHostServiceReportTeamRes, error) {
	q := h.client.HostServiceReport.Query().Where(hostservicereport.IDEQ(params.ID)).QueryTeam()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewHostServiceReportTeamRead(e), nil
}

// ReadHostServiceReportTeamreport handles GET /host-service-reports/{id}/teamreport requests.
func (h *OgentHandler) ReadHostServiceReportTeamreport(ctx context.Context, params ReadHostServiceReportTeamreportParams) (ReadHostServiceReportTeamreportRes, error) {
	q := h.client.HostServiceReport.Query().Where(hostservicereport.IDEQ(params.ID)).QueryTeamreport()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewHostServiceReportTeamreportRead(e), nil
}

// CreateProperty handles POST /properties requests.
func (h *OgentHandler) CreateProperty(ctx context.Context, req *CreatePropertyReq) (CreatePropertyRes, error) {
	b := h.client.Property.Create()
	// Add all fields.
	if v, ok := req.CreateTime.Get(); ok {
		b.SetCreateTime(v)
	}
	if v, ok := req.UpdateTime.Get(); ok {
		b.SetUpdateTime(v)
	}
	b.SetKey(req.Key)
	b.SetValue(req.Value)
	b.SetHostServiceID(req.HostServiceID)
	// Add all edges.
	b.SetHostserviceID(req.Hostservice)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Property.Query().Where(property.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewPropertyCreate(e), nil
}

// ReadProperty handles GET /properties/{id} requests.
func (h *OgentHandler) ReadProperty(ctx context.Context, params ReadPropertyParams) (ReadPropertyRes, error) {
	q := h.client.Property.Query().Where(property.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewPropertyRead(e), nil
}

// UpdateProperty handles PATCH /properties/{id} requests.
func (h *OgentHandler) UpdateProperty(ctx context.Context, req *UpdatePropertyReq, params UpdatePropertyParams) (UpdatePropertyRes, error) {
	b := h.client.Property.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.UpdateTime.Get(); ok {
		b.SetUpdateTime(v)
	}
	if v, ok := req.Value.Get(); ok {
		b.SetValue(v)
	}
	// Add all edges.
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Property.Query().Where(property.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewPropertyUpdate(e), nil
}

// DeleteProperty handles DELETE /properties/{id} requests.
func (h *OgentHandler) DeleteProperty(ctx context.Context, params DeletePropertyParams) (DeletePropertyRes, error) {
	err := h.client.Property.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeletePropertyNoContent), nil

}

// ListProperty handles GET /properties requests.
func (h *OgentHandler) ListProperty(ctx context.Context, params ListPropertyParams) (ListPropertyRes, error) {
	q := h.client.Property.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewPropertyLists(es)
	return (*ListPropertyOKApplicationJSON)(&r), nil
}

// ReadPropertyHostservice handles GET /properties/{id}/hostservice requests.
func (h *OgentHandler) ReadPropertyHostservice(ctx context.Context, params ReadPropertyHostserviceParams) (ReadPropertyHostserviceRes, error) {
	q := h.client.Property.Query().Where(property.IDEQ(params.ID)).QueryHostservice()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewPropertyHostserviceRead(e), nil
}

// CreateRound handles POST /rounds requests.
func (h *OgentHandler) CreateRound(ctx context.Context, req *CreateRoundReq) (CreateRoundRes, error) {
	b := h.client.Round.Create()
	// Add all fields.
	if v, ok := req.CreateTime.Get(); ok {
		b.SetCreateTime(v)
	}
	if v, ok := req.UpdateTime.Get(); ok {
		b.SetUpdateTime(v)
	}
	b.SetRoundNumber(req.RoundNumber)
	if v, ok := req.NumOfIntendedChecks.Get(); ok {
		b.SetNumOfIntendedChecks(v)
	}
	b.SetStatus(round.Status(req.Status))
	b.SetStartedAt(req.StartedAt)
	if v, ok := req.FinishedAt.Get(); ok {
		b.SetFinishedAt(v)
	}
	// Add all edges.
	b.AddCheckIDs(req.Checks...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Round.Query().Where(round.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewRoundCreate(e), nil
}

// ReadRound handles GET /rounds/{id} requests.
func (h *OgentHandler) ReadRound(ctx context.Context, params ReadRoundParams) (ReadRoundRes, error) {
	q := h.client.Round.Query().Where(round.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewRoundRead(e), nil
}

// UpdateRound handles PATCH /rounds/{id} requests.
func (h *OgentHandler) UpdateRound(ctx context.Context, req *UpdateRoundReq, params UpdateRoundParams) (UpdateRoundRes, error) {
	b := h.client.Round.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.UpdateTime.Get(); ok {
		b.SetUpdateTime(v)
	}
	if v, ok := req.RoundNumber.Get(); ok {
		b.SetRoundNumber(v)
	}
	if v, ok := req.NumOfIntendedChecks.Get(); ok {
		b.SetNumOfIntendedChecks(v)
	}
	if v, ok := req.Status.Get(); ok {
		b.SetStatus(round.Status(v))
	}
	if v, ok := req.StartedAt.Get(); ok {
		b.SetStartedAt(v)
	}
	if v, ok := req.FinishedAt.Get(); ok {
		b.SetFinishedAt(v)
	}
	// Add all edges.
	if req.Checks != nil {
		b.ClearChecks().AddCheckIDs(req.Checks...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Round.Query().Where(round.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewRoundUpdate(e), nil
}

// DeleteRound handles DELETE /rounds/{id} requests.
func (h *OgentHandler) DeleteRound(ctx context.Context, params DeleteRoundParams) (DeleteRoundRes, error) {
	err := h.client.Round.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteRoundNoContent), nil

}

// ListRound handles GET /rounds requests.
func (h *OgentHandler) ListRound(ctx context.Context, params ListRoundParams) (ListRoundRes, error) {
	q := h.client.Round.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewRoundLists(es)
	return (*ListRoundOKApplicationJSON)(&r), nil
}

// ListRoundChecks handles GET /rounds/{id}/checks requests.
func (h *OgentHandler) ListRoundChecks(ctx context.Context, params ListRoundChecksParams) (ListRoundChecksRes, error) {
	q := h.client.Round.Query().Where(round.IDEQ(params.ID)).QueryChecks()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewRoundChecksLists(es)
	return (*ListRoundChecksOKApplicationJSON)(&r), nil
}

// CreateService handles POST /services requests.
func (h *OgentHandler) CreateService(ctx context.Context, req *CreateServiceReq) (CreateServiceRes, error) {
	b := h.client.Service.Create()
	// Add all fields.
	b.SetName(req.Name)
	b.SetDisplayName(req.DisplayName)
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	if v, ok := req.CreateTime.Get(); ok {
		b.SetCreateTime(v)
	}
	if v, ok := req.UpdateTime.Get(); ok {
		b.SetUpdateTime(v)
	}
	b.SetType(scorerservice.Service(req.Type))
	b.SetWeight(req.Weight)
	b.SetPointBoost(req.PointBoost)
	b.SetRoundFrequency(req.RoundFrequency)
	b.SetRoundDelay(req.RoundDelay)
	// Add all edges.
	b.AddHostserviceIDs(req.Hostservices...)
	b.AddHostservicereportIDs(req.Hostservicereports...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Service.Query().Where(service.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewServiceCreate(e), nil
}

// ReadService handles GET /services/{id} requests.
func (h *OgentHandler) ReadService(ctx context.Context, params ReadServiceParams) (ReadServiceRes, error) {
	q := h.client.Service.Query().Where(service.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewServiceRead(e), nil
}

// UpdateService handles PATCH /services/{id} requests.
func (h *OgentHandler) UpdateService(ctx context.Context, req *UpdateServiceReq, params UpdateServiceParams) (UpdateServiceRes, error) {
	b := h.client.Service.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.DisplayName.Get(); ok {
		b.SetDisplayName(v)
	}
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	if v, ok := req.UpdateTime.Get(); ok {
		b.SetUpdateTime(v)
	}
	if v, ok := req.Type.Get(); ok {
		b.SetType(scorerservice.Service(v))
	}
	if v, ok := req.Weight.Get(); ok {
		b.SetWeight(v)
	}
	if v, ok := req.PointBoost.Get(); ok {
		b.SetPointBoost(v)
	}
	if v, ok := req.RoundFrequency.Get(); ok {
		b.SetRoundFrequency(v)
	}
	if v, ok := req.RoundDelay.Get(); ok {
		b.SetRoundDelay(v)
	}
	// Add all edges.
	if req.Hostservices != nil {
		b.ClearHostservices().AddHostserviceIDs(req.Hostservices...)
	}
	if req.Hostservicereports != nil {
		b.ClearHostservicereports().AddHostservicereportIDs(req.Hostservicereports...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Service.Query().Where(service.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewServiceUpdate(e), nil
}

// DeleteService handles DELETE /services/{id} requests.
func (h *OgentHandler) DeleteService(ctx context.Context, params DeleteServiceParams) (DeleteServiceRes, error) {
	err := h.client.Service.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteServiceNoContent), nil

}

// ListService handles GET /services requests.
func (h *OgentHandler) ListService(ctx context.Context, params ListServiceParams) (ListServiceRes, error) {
	q := h.client.Service.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewServiceLists(es)
	return (*ListServiceOKApplicationJSON)(&r), nil
}

// ListServiceHostservices handles GET /services/{id}/hostservices requests.
func (h *OgentHandler) ListServiceHostservices(ctx context.Context, params ListServiceHostservicesParams) (ListServiceHostservicesRes, error) {
	q := h.client.Service.Query().Where(service.IDEQ(params.ID)).QueryHostservices()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewServiceHostservicesLists(es)
	return (*ListServiceHostservicesOKApplicationJSON)(&r), nil
}

// ListServiceHostservicereports handles GET /services/{id}/hostservicereports requests.
func (h *OgentHandler) ListServiceHostservicereports(ctx context.Context, params ListServiceHostservicereportsParams) (ListServiceHostservicereportsRes, error) {
	q := h.client.Service.Query().Where(service.IDEQ(params.ID)).QueryHostservicereports()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewServiceHostservicereportsLists(es)
	return (*ListServiceHostservicereportsOKApplicationJSON)(&r), nil
}

// CreateTeam handles POST /teams requests.
func (h *OgentHandler) CreateTeam(ctx context.Context, req *CreateTeamReq) (CreateTeamRes, error) {
	b := h.client.Team.Create()
	// Add all fields.
	b.SetName(req.Name)
	b.SetDisplayName(req.DisplayName)
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	if v, ok := req.CreateTime.Get(); ok {
		b.SetCreateTime(v)
	}
	if v, ok := req.UpdateTime.Get(); ok {
		b.SetUpdateTime(v)
	}
	b.SetNumber(req.Number)
	// Add all edges.
	b.AddHostIDs(req.Hosts...)
	b.AddHostserviceIDs(req.Hostservices...)
	if v, ok := req.Teamreport.Get(); ok {
		b.SetTeamreportID(v)
	}
	b.AddHostservicereportIDs(req.Hostservicereports...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Team.Query().Where(team.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewTeamCreate(e), nil
}

// ReadTeam handles GET /teams/{id} requests.
func (h *OgentHandler) ReadTeam(ctx context.Context, params ReadTeamParams) (ReadTeamRes, error) {
	q := h.client.Team.Query().Where(team.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewTeamRead(e), nil
}

// UpdateTeam handles PATCH /teams/{id} requests.
func (h *OgentHandler) UpdateTeam(ctx context.Context, req *UpdateTeamReq, params UpdateTeamParams) (UpdateTeamRes, error) {
	b := h.client.Team.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.DisplayName.Get(); ok {
		b.SetDisplayName(v)
	}
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	if v, ok := req.UpdateTime.Get(); ok {
		b.SetUpdateTime(v)
	}
	if v, ok := req.Number.Get(); ok {
		b.SetNumber(v)
	}
	// Add all edges.
	if req.Hosts != nil {
		b.ClearHosts().AddHostIDs(req.Hosts...)
	}
	if req.Hostservices != nil {
		b.ClearHostservices().AddHostserviceIDs(req.Hostservices...)
	}
	if v, ok := req.Teamreport.Get(); ok {
		b.SetTeamreportID(v)
	}
	if req.Hostservicereports != nil {
		b.ClearHostservicereports().AddHostservicereportIDs(req.Hostservicereports...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Team.Query().Where(team.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewTeamUpdate(e), nil
}

// DeleteTeam handles DELETE /teams/{id} requests.
func (h *OgentHandler) DeleteTeam(ctx context.Context, params DeleteTeamParams) (DeleteTeamRes, error) {
	err := h.client.Team.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteTeamNoContent), nil

}

// ListTeam handles GET /teams requests.
func (h *OgentHandler) ListTeam(ctx context.Context, params ListTeamParams) (ListTeamRes, error) {
	q := h.client.Team.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewTeamLists(es)
	return (*ListTeamOKApplicationJSON)(&r), nil
}

// ListTeamHosts handles GET /teams/{id}/hosts requests.
func (h *OgentHandler) ListTeamHosts(ctx context.Context, params ListTeamHostsParams) (ListTeamHostsRes, error) {
	q := h.client.Team.Query().Where(team.IDEQ(params.ID)).QueryHosts()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewTeamHostsLists(es)
	return (*ListTeamHostsOKApplicationJSON)(&r), nil
}

// ListTeamHostservices handles GET /teams/{id}/hostservices requests.
func (h *OgentHandler) ListTeamHostservices(ctx context.Context, params ListTeamHostservicesParams) (ListTeamHostservicesRes, error) {
	q := h.client.Team.Query().Where(team.IDEQ(params.ID)).QueryHostservices()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewTeamHostservicesLists(es)
	return (*ListTeamHostservicesOKApplicationJSON)(&r), nil
}

// ReadTeamTeamreport handles GET /teams/{id}/teamreport requests.
func (h *OgentHandler) ReadTeamTeamreport(ctx context.Context, params ReadTeamTeamreportParams) (ReadTeamTeamreportRes, error) {
	q := h.client.Team.Query().Where(team.IDEQ(params.ID)).QueryTeamreport()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewTeamTeamreportRead(e), nil
}

// ListTeamHostservicereports handles GET /teams/{id}/hostservicereports requests.
func (h *OgentHandler) ListTeamHostservicereports(ctx context.Context, params ListTeamHostservicereportsParams) (ListTeamHostservicereportsRes, error) {
	q := h.client.Team.Query().Where(team.IDEQ(params.ID)).QueryHostservicereports()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewTeamHostservicereportsLists(es)
	return (*ListTeamHostservicereportsOKApplicationJSON)(&r), nil
}

// CreateTeamReport handles POST /team-reports requests.
func (h *OgentHandler) CreateTeamReport(ctx context.Context, req *CreateTeamReportReq) (CreateTeamReportRes, error) {
	b := h.client.TeamReport.Create()
	// Add all fields.
	if v, ok := req.CreateTime.Get(); ok {
		b.SetCreateTime(v)
	}
	if v, ok := req.UpdateTime.Get(); ok {
		b.SetUpdateTime(v)
	}
	b.SetPoints(req.Points)
	b.SetTeamID(req.TeamID)
	// Add all edges.
	b.SetTeamID(req.Team)
	b.AddHostservicereportIDs(req.Hostservicereports...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.TeamReport.Query().Where(teamreport.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewTeamReportCreate(e), nil
}

// ReadTeamReport handles GET /team-reports/{id} requests.
func (h *OgentHandler) ReadTeamReport(ctx context.Context, params ReadTeamReportParams) (ReadTeamReportRes, error) {
	q := h.client.TeamReport.Query().Where(teamreport.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewTeamReportRead(e), nil
}

// UpdateTeamReport handles PATCH /team-reports/{id} requests.
func (h *OgentHandler) UpdateTeamReport(ctx context.Context, req *UpdateTeamReportReq, params UpdateTeamReportParams) (UpdateTeamReportRes, error) {
	b := h.client.TeamReport.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.UpdateTime.Get(); ok {
		b.SetUpdateTime(v)
	}
	if v, ok := req.Points.Get(); ok {
		b.SetPoints(v)
	}
	// Add all edges.
	if req.Hostservicereports != nil {
		b.ClearHostservicereports().AddHostservicereportIDs(req.Hostservicereports...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.TeamReport.Query().Where(teamreport.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewTeamReportUpdate(e), nil
}

// DeleteTeamReport handles DELETE /team-reports/{id} requests.
func (h *OgentHandler) DeleteTeamReport(ctx context.Context, params DeleteTeamReportParams) (DeleteTeamReportRes, error) {
	err := h.client.TeamReport.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteTeamReportNoContent), nil

}

// ListTeamReport handles GET /team-reports requests.
func (h *OgentHandler) ListTeamReport(ctx context.Context, params ListTeamReportParams) (ListTeamReportRes, error) {
	q := h.client.TeamReport.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewTeamReportLists(es)
	return (*ListTeamReportOKApplicationJSON)(&r), nil
}

// ReadTeamReportTeam handles GET /team-reports/{id}/team requests.
func (h *OgentHandler) ReadTeamReportTeam(ctx context.Context, params ReadTeamReportTeamParams) (ReadTeamReportTeamRes, error) {
	q := h.client.TeamReport.Query().Where(teamreport.IDEQ(params.ID)).QueryTeam()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewTeamReportTeamRead(e), nil
}

// ListTeamReportHostservicereports handles GET /team-reports/{id}/hostservicereports requests.
func (h *OgentHandler) ListTeamReportHostservicereports(ctx context.Context, params ListTeamReportHostservicereportsParams) (ListTeamReportHostservicereportsRes, error) {
	q := h.client.TeamReport.Query().Where(teamreport.IDEQ(params.ID)).QueryHostservicereports()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewTeamReportHostservicereportsLists(es)
	return (*ListTeamReportHostservicereportsOKApplicationJSON)(&r), nil
}
