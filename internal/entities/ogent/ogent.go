// Code generated by ent, DO NOT EDIT.

package ogent

import (
	"context"
	"net/http"

	"github.com/ScoreTrak/ScoreTrak/internal/entities"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/check"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/competition"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/host"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/hostservice"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/property"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/report"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/round"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/service"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/team"
	"github.com/go-faster/jx"
)

// OgentHandler implements the ogen generated Handler interface and uses Ent as data layer.
type OgentHandler struct {
	client *entities.Client
}

// NewOgentHandler returns a new OgentHandler.
func NewOgentHandler(c *entities.Client) *OgentHandler { return &OgentHandler{c} }

// rawError renders err as json string.
func rawError(err error) jx.Raw {
	var e jx.Encoder
	e.Str(err.Error())
	return e.Bytes()
}

// CreateCheck handles POST /checks requests.
func (h *OgentHandler) CreateCheck(ctx context.Context, req *CreateCheckReq) (CreateCheckRes, error) {
	b := h.client.Check.Create()
	// Add all fields.
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	b.SetLog(req.Log)
	b.SetError(req.Error)
	b.SetPassed(req.Passed)
	b.SetRoundID(req.RoundID)
	b.SetHostServiceID(req.HostServiceID)
	b.SetTeamID(req.TeamID)
	// Add all edges.
	b.SetRoundsID(req.Rounds)
	b.SetHostserviceID(req.Hostservice)
	b.SetTeamID(req.Team)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Check.Query().Where(check.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewCheckCreate(e), nil
}

// ReadCheck handles GET /checks/{id} requests.
func (h *OgentHandler) ReadCheck(ctx context.Context, params ReadCheckParams) (ReadCheckRes, error) {
	q := h.client.Check.Query().Where(check.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewCheckRead(e), nil
}

// UpdateCheck handles PATCH /checks/{id} requests.
func (h *OgentHandler) UpdateCheck(ctx context.Context, req *UpdateCheckReq, params UpdateCheckParams) (UpdateCheckRes, error) {
	b := h.client.Check.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	if v, ok := req.Log.Get(); ok {
		b.SetLog(v)
	}
	if v, ok := req.Error.Get(); ok {
		b.SetError(v)
	}
	if v, ok := req.Passed.Get(); ok {
		b.SetPassed(v)
	}
	if v, ok := req.RoundID.Get(); ok {
		b.SetRoundID(v)
	}
	if v, ok := req.HostServiceID.Get(); ok {
		b.SetHostServiceID(v)
	}
	// Add all edges.
	if v, ok := req.Rounds.Get(); ok {
		b.SetRoundsID(v)
	}
	if v, ok := req.Hostservice.Get(); ok {
		b.SetHostserviceID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Check.Query().Where(check.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewCheckUpdate(e), nil
}

// DeleteCheck handles DELETE /checks/{id} requests.
func (h *OgentHandler) DeleteCheck(ctx context.Context, params DeleteCheckParams) (DeleteCheckRes, error) {
	err := h.client.Check.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteCheckNoContent), nil

}

// ListCheck handles GET /checks requests.
func (h *OgentHandler) ListCheck(ctx context.Context, params ListCheckParams) (ListCheckRes, error) {
	q := h.client.Check.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewCheckLists(es)
	return (*ListCheckOKApplicationJSON)(&r), nil
}

// ReadCheckRounds handles GET /checks/{id}/rounds requests.
func (h *OgentHandler) ReadCheckRounds(ctx context.Context, params ReadCheckRoundsParams) (ReadCheckRoundsRes, error) {
	q := h.client.Check.Query().Where(check.IDEQ(params.ID)).QueryRounds()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewCheckRoundsRead(e), nil
}

// ReadCheckHostservice handles GET /checks/{id}/hostservice requests.
func (h *OgentHandler) ReadCheckHostservice(ctx context.Context, params ReadCheckHostserviceParams) (ReadCheckHostserviceRes, error) {
	q := h.client.Check.Query().Where(check.IDEQ(params.ID)).QueryHostservice()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewCheckHostserviceRead(e), nil
}

// ReadCheckTeam handles GET /checks/{id}/team requests.
func (h *OgentHandler) ReadCheckTeam(ctx context.Context, params ReadCheckTeamParams) (ReadCheckTeamRes, error) {
	q := h.client.Check.Query().Where(check.IDEQ(params.ID)).QueryTeam()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewCheckTeamRead(e), nil
}

// CreateCompetition handles POST /competitions requests.
func (h *OgentHandler) CreateCompetition(ctx context.Context, req *CreateCompetitionReq) (CreateCompetitionRes, error) {
	b := h.client.Competition.Create()
	// Add all fields.
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	b.SetName(req.Name)
	b.SetDisplayName(req.DisplayName)
	if v, ok := req.ViewableToPublic.Get(); ok {
		b.SetViewableToPublic(v)
	}
	if v, ok := req.ToBeStartedAt.Get(); ok {
		b.SetToBeStartedAt(v)
	}
	if v, ok := req.StartedAt.Get(); ok {
		b.SetStartedAt(v)
	}
	if v, ok := req.FinishedAt.Get(); ok {
		b.SetFinishedAt(v)
	}
	// Add all edges.
	b.AddTeamIDs(req.Teams...)
	b.AddServiceIDs(req.Services...)
	b.AddReportIDs(req.Reports...)
	b.AddRoundIDs(req.Rounds...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Competition.Query().Where(competition.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewCompetitionCreate(e), nil
}

// ReadCompetition handles GET /competitions/{id} requests.
func (h *OgentHandler) ReadCompetition(ctx context.Context, params ReadCompetitionParams) (ReadCompetitionRes, error) {
	q := h.client.Competition.Query().Where(competition.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewCompetitionRead(e), nil
}

// UpdateCompetition handles PATCH /competitions/{id} requests.
func (h *OgentHandler) UpdateCompetition(ctx context.Context, req *UpdateCompetitionReq, params UpdateCompetitionParams) (UpdateCompetitionRes, error) {
	b := h.client.Competition.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.DisplayName.Get(); ok {
		b.SetDisplayName(v)
	}
	if v, ok := req.ViewableToPublic.Get(); ok {
		b.SetViewableToPublic(v)
	}
	if v, ok := req.ToBeStartedAt.Get(); ok {
		b.SetToBeStartedAt(v)
	}
	if v, ok := req.StartedAt.Get(); ok {
		b.SetStartedAt(v)
	}
	if v, ok := req.FinishedAt.Get(); ok {
		b.SetFinishedAt(v)
	}
	// Add all edges.
	if req.Teams != nil {
		b.ClearTeams().AddTeamIDs(req.Teams...)
	}
	if req.Services != nil {
		b.ClearServices().AddServiceIDs(req.Services...)
	}
	if req.Reports != nil {
		b.ClearReports().AddReportIDs(req.Reports...)
	}
	if req.Rounds != nil {
		b.ClearRounds().AddRoundIDs(req.Rounds...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Competition.Query().Where(competition.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewCompetitionUpdate(e), nil
}

// DeleteCompetition handles DELETE /competitions/{id} requests.
func (h *OgentHandler) DeleteCompetition(ctx context.Context, params DeleteCompetitionParams) (DeleteCompetitionRes, error) {
	err := h.client.Competition.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteCompetitionNoContent), nil

}

// ListCompetition handles GET /competitions requests.
func (h *OgentHandler) ListCompetition(ctx context.Context, params ListCompetitionParams) (ListCompetitionRes, error) {
	q := h.client.Competition.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewCompetitionLists(es)
	return (*ListCompetitionOKApplicationJSON)(&r), nil
}

// ListCompetitionTeams handles GET /competitions/{id}/teams requests.
func (h *OgentHandler) ListCompetitionTeams(ctx context.Context, params ListCompetitionTeamsParams) (ListCompetitionTeamsRes, error) {
	q := h.client.Competition.Query().Where(competition.IDEQ(params.ID)).QueryTeams()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewCompetitionTeamsLists(es)
	return (*ListCompetitionTeamsOKApplicationJSON)(&r), nil
}

// ListCompetitionServices handles GET /competitions/{id}/services requests.
func (h *OgentHandler) ListCompetitionServices(ctx context.Context, params ListCompetitionServicesParams) (ListCompetitionServicesRes, error) {
	q := h.client.Competition.Query().Where(competition.IDEQ(params.ID)).QueryServices()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewCompetitionServicesLists(es)
	return (*ListCompetitionServicesOKApplicationJSON)(&r), nil
}

// ListCompetitionReports handles GET /competitions/{id}/reports requests.
func (h *OgentHandler) ListCompetitionReports(ctx context.Context, params ListCompetitionReportsParams) (ListCompetitionReportsRes, error) {
	q := h.client.Competition.Query().Where(competition.IDEQ(params.ID)).QueryReports()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewCompetitionReportsLists(es)
	return (*ListCompetitionReportsOKApplicationJSON)(&r), nil
}

// ListCompetitionRounds handles GET /competitions/{id}/rounds requests.
func (h *OgentHandler) ListCompetitionRounds(ctx context.Context, params ListCompetitionRoundsParams) (ListCompetitionRoundsRes, error) {
	q := h.client.Competition.Query().Where(competition.IDEQ(params.ID)).QueryRounds()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewCompetitionRoundsLists(es)
	return (*ListCompetitionRoundsOKApplicationJSON)(&r), nil
}

// CreateHost handles POST /hosts requests.
func (h *OgentHandler) CreateHost(ctx context.Context, req *CreateHostReq) (CreateHostRes, error) {
	b := h.client.Host.Create()
	// Add all fields.
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	b.SetAddress(req.Address)
	b.SetTeamID(req.TeamID)
	// Add all edges.
	b.AddHostserviceIDs(req.Hostservices...)
	b.SetTeamID(req.Team)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Host.Query().Where(host.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewHostCreate(e), nil
}

// ReadHost handles GET /hosts/{id} requests.
func (h *OgentHandler) ReadHost(ctx context.Context, params ReadHostParams) (ReadHostRes, error) {
	q := h.client.Host.Query().Where(host.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewHostRead(e), nil
}

// UpdateHost handles PATCH /hosts/{id} requests.
func (h *OgentHandler) UpdateHost(ctx context.Context, req *UpdateHostReq, params UpdateHostParams) (UpdateHostRes, error) {
	b := h.client.Host.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	if v, ok := req.Address.Get(); ok {
		b.SetAddress(v)
	}
	// Add all edges.
	if req.Hostservices != nil {
		b.ClearHostservices().AddHostserviceIDs(req.Hostservices...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Host.Query().Where(host.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewHostUpdate(e), nil
}

// DeleteHost handles DELETE /hosts/{id} requests.
func (h *OgentHandler) DeleteHost(ctx context.Context, params DeleteHostParams) (DeleteHostRes, error) {
	err := h.client.Host.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteHostNoContent), nil

}

// ListHost handles GET /hosts requests.
func (h *OgentHandler) ListHost(ctx context.Context, params ListHostParams) (ListHostRes, error) {
	q := h.client.Host.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewHostLists(es)
	return (*ListHostOKApplicationJSON)(&r), nil
}

// ListHostHostservices handles GET /hosts/{id}/hostservices requests.
func (h *OgentHandler) ListHostHostservices(ctx context.Context, params ListHostHostservicesParams) (ListHostHostservicesRes, error) {
	q := h.client.Host.Query().Where(host.IDEQ(params.ID)).QueryHostservices()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewHostHostservicesLists(es)
	return (*ListHostHostservicesOKApplicationJSON)(&r), nil
}

// ReadHostTeam handles GET /hosts/{id}/team requests.
func (h *OgentHandler) ReadHostTeam(ctx context.Context, params ReadHostTeamParams) (ReadHostTeamRes, error) {
	q := h.client.Host.Query().Where(host.IDEQ(params.ID)).QueryTeam()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewHostTeamRead(e), nil
}

// CreateHostService handles POST /host-services requests.
func (h *OgentHandler) CreateHostService(ctx context.Context, req *CreateHostServiceReq) (CreateHostServiceRes, error) {
	b := h.client.HostService.Create()
	// Add all fields.
	b.SetName(req.Name)
	b.SetDisplayName(req.DisplayName)
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	b.SetWeight(req.Weight)
	b.SetPointBoost(req.PointBoost)
	b.SetRoundUnits(req.RoundUnits)
	b.SetRoundDelay(req.RoundDelay)
	b.SetHostID(req.HostID)
	b.SetTeamID(req.TeamID)
	// Add all edges.
	b.SetHostID(req.Host)
	b.AddCheckIDs(req.Checks...)
	b.AddPropertyIDs(req.Properties...)
	b.SetTeamID(req.Team)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.HostService.Query().Where(hostservice.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewHostServiceCreate(e), nil
}

// ReadHostService handles GET /host-services/{id} requests.
func (h *OgentHandler) ReadHostService(ctx context.Context, params ReadHostServiceParams) (ReadHostServiceRes, error) {
	q := h.client.HostService.Query().Where(hostservice.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewHostServiceRead(e), nil
}

// UpdateHostService handles PATCH /host-services/{id} requests.
func (h *OgentHandler) UpdateHostService(ctx context.Context, req *UpdateHostServiceReq, params UpdateHostServiceParams) (UpdateHostServiceRes, error) {
	b := h.client.HostService.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.DisplayName.Get(); ok {
		b.SetDisplayName(v)
	}
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	if v, ok := req.Weight.Get(); ok {
		b.SetWeight(v)
	}
	if v, ok := req.PointBoost.Get(); ok {
		b.SetPointBoost(v)
	}
	if v, ok := req.RoundUnits.Get(); ok {
		b.SetRoundUnits(v)
	}
	if v, ok := req.RoundDelay.Get(); ok {
		b.SetRoundDelay(v)
	}
	if v, ok := req.HostID.Get(); ok {
		b.SetHostID(v)
	}
	// Add all edges.
	if v, ok := req.Host.Get(); ok {
		b.SetHostID(v)
	}
	if req.Checks != nil {
		b.ClearChecks().AddCheckIDs(req.Checks...)
	}
	if req.Properties != nil {
		b.ClearProperties().AddPropertyIDs(req.Properties...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.HostService.Query().Where(hostservice.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewHostServiceUpdate(e), nil
}

// DeleteHostService handles DELETE /host-services/{id} requests.
func (h *OgentHandler) DeleteHostService(ctx context.Context, params DeleteHostServiceParams) (DeleteHostServiceRes, error) {
	err := h.client.HostService.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteHostServiceNoContent), nil

}

// ListHostService handles GET /host-services requests.
func (h *OgentHandler) ListHostService(ctx context.Context, params ListHostServiceParams) (ListHostServiceRes, error) {
	q := h.client.HostService.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewHostServiceLists(es)
	return (*ListHostServiceOKApplicationJSON)(&r), nil
}

// ReadHostServiceHost handles GET /host-services/{id}/host requests.
func (h *OgentHandler) ReadHostServiceHost(ctx context.Context, params ReadHostServiceHostParams) (ReadHostServiceHostRes, error) {
	q := h.client.HostService.Query().Where(hostservice.IDEQ(params.ID)).QueryHost()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewHostServiceHostRead(e), nil
}

// ListHostServiceChecks handles GET /host-services/{id}/checks requests.
func (h *OgentHandler) ListHostServiceChecks(ctx context.Context, params ListHostServiceChecksParams) (ListHostServiceChecksRes, error) {
	q := h.client.HostService.Query().Where(hostservice.IDEQ(params.ID)).QueryChecks()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewHostServiceChecksLists(es)
	return (*ListHostServiceChecksOKApplicationJSON)(&r), nil
}

// ListHostServiceProperties handles GET /host-services/{id}/properties requests.
func (h *OgentHandler) ListHostServiceProperties(ctx context.Context, params ListHostServicePropertiesParams) (ListHostServicePropertiesRes, error) {
	q := h.client.HostService.Query().Where(hostservice.IDEQ(params.ID)).QueryProperties()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewHostServicePropertiesLists(es)
	return (*ListHostServicePropertiesOKApplicationJSON)(&r), nil
}

// ReadHostServiceTeam handles GET /host-services/{id}/team requests.
func (h *OgentHandler) ReadHostServiceTeam(ctx context.Context, params ReadHostServiceTeamParams) (ReadHostServiceTeamRes, error) {
	q := h.client.HostService.Query().Where(hostservice.IDEQ(params.ID)).QueryTeam()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewHostServiceTeamRead(e), nil
}

// CreateProperty handles POST /properties requests.
func (h *OgentHandler) CreateProperty(ctx context.Context, req *CreatePropertyReq) (CreatePropertyRes, error) {
	b := h.client.Property.Create()
	// Add all fields.
	b.SetKey(req.Key)
	b.SetValue(req.Value)
	b.SetStatus(property.Status(req.Status))
	b.SetHostServiceID(req.HostServiceID)
	b.SetTeamID(req.TeamID)
	// Add all edges.
	b.SetHostserviceID(req.Hostservice)
	b.SetTeamID(req.Team)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Property.Query().Where(property.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewPropertyCreate(e), nil
}

// ReadProperty handles GET /properties/{id} requests.
func (h *OgentHandler) ReadProperty(ctx context.Context, params ReadPropertyParams) (ReadPropertyRes, error) {
	q := h.client.Property.Query().Where(property.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewPropertyRead(e), nil
}

// UpdateProperty handles PATCH /properties/{id} requests.
func (h *OgentHandler) UpdateProperty(ctx context.Context, req *UpdatePropertyReq, params UpdatePropertyParams) (UpdatePropertyRes, error) {
	b := h.client.Property.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Key.Get(); ok {
		b.SetKey(v)
	}
	if v, ok := req.Value.Get(); ok {
		b.SetValue(v)
	}
	if v, ok := req.Status.Get(); ok {
		b.SetStatus(property.Status(v))
	}
	if v, ok := req.HostServiceID.Get(); ok {
		b.SetHostServiceID(v)
	}
	// Add all edges.
	if v, ok := req.Hostservice.Get(); ok {
		b.SetHostserviceID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Property.Query().Where(property.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewPropertyUpdate(e), nil
}

// DeleteProperty handles DELETE /properties/{id} requests.
func (h *OgentHandler) DeleteProperty(ctx context.Context, params DeletePropertyParams) (DeletePropertyRes, error) {
	err := h.client.Property.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeletePropertyNoContent), nil

}

// ListProperty handles GET /properties requests.
func (h *OgentHandler) ListProperty(ctx context.Context, params ListPropertyParams) (ListPropertyRes, error) {
	q := h.client.Property.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewPropertyLists(es)
	return (*ListPropertyOKApplicationJSON)(&r), nil
}

// ReadPropertyHostservice handles GET /properties/{id}/hostservice requests.
func (h *OgentHandler) ReadPropertyHostservice(ctx context.Context, params ReadPropertyHostserviceParams) (ReadPropertyHostserviceRes, error) {
	q := h.client.Property.Query().Where(property.IDEQ(params.ID)).QueryHostservice()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewPropertyHostserviceRead(e), nil
}

// ReadPropertyTeam handles GET /properties/{id}/team requests.
func (h *OgentHandler) ReadPropertyTeam(ctx context.Context, params ReadPropertyTeamParams) (ReadPropertyTeamRes, error) {
	q := h.client.Property.Query().Where(property.IDEQ(params.ID)).QueryTeam()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewPropertyTeamRead(e), nil
}

// CreateReport handles POST /reports requests.
func (h *OgentHandler) CreateReport(ctx context.Context, req *CreateReportReq) (CreateReportRes, error) {
	b := h.client.Report.Create()
	// Add all fields.
	b.SetLog(req.Log)
	b.SetError(req.Error)
	b.SetCompetitionID(req.CompetitionID)
	// Add all edges.
	b.SetCompetitionID(req.Competition)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Report.Query().Where(report.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewReportCreate(e), nil
}

// ReadReport handles GET /reports/{id} requests.
func (h *OgentHandler) ReadReport(ctx context.Context, params ReadReportParams) (ReadReportRes, error) {
	q := h.client.Report.Query().Where(report.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewReportRead(e), nil
}

// UpdateReport handles PATCH /reports/{id} requests.
func (h *OgentHandler) UpdateReport(ctx context.Context, req *UpdateReportReq, params UpdateReportParams) (UpdateReportRes, error) {
	b := h.client.Report.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Log.Get(); ok {
		b.SetLog(v)
	}
	if v, ok := req.Error.Get(); ok {
		b.SetError(v)
	}
	// Add all edges.
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Report.Query().Where(report.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewReportUpdate(e), nil
}

// DeleteReport handles DELETE /reports/{id} requests.
func (h *OgentHandler) DeleteReport(ctx context.Context, params DeleteReportParams) (DeleteReportRes, error) {
	err := h.client.Report.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteReportNoContent), nil

}

// ListReport handles GET /reports requests.
func (h *OgentHandler) ListReport(ctx context.Context, params ListReportParams) (ListReportRes, error) {
	q := h.client.Report.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewReportLists(es)
	return (*ListReportOKApplicationJSON)(&r), nil
}

// ReadReportCompetition handles GET /reports/{id}/competition requests.
func (h *OgentHandler) ReadReportCompetition(ctx context.Context, params ReadReportCompetitionParams) (ReadReportCompetitionRes, error) {
	q := h.client.Report.Query().Where(report.IDEQ(params.ID)).QueryCompetition()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewReportCompetitionRead(e), nil
}

// CreateRound handles POST /rounds requests.
func (h *OgentHandler) CreateRound(ctx context.Context, req *CreateRoundReq) (CreateRoundRes, error) {
	b := h.client.Round.Create()
	// Add all fields.
	b.SetRoundNumber(req.RoundNumber)
	b.SetNote(req.Note)
	b.SetErr(req.Err)
	b.SetStartedAt(req.StartedAt)
	b.SetFinishedAt(req.FinishedAt)
	b.SetCompetitionID(req.CompetitionID)
	// Add all edges.
	b.AddCheckIDs(req.Checks...)
	b.SetCompetitionID(req.Competition)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Round.Query().Where(round.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewRoundCreate(e), nil
}

// ReadRound handles GET /rounds/{id} requests.
func (h *OgentHandler) ReadRound(ctx context.Context, params ReadRoundParams) (ReadRoundRes, error) {
	q := h.client.Round.Query().Where(round.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewRoundRead(e), nil
}

// UpdateRound handles PATCH /rounds/{id} requests.
func (h *OgentHandler) UpdateRound(ctx context.Context, req *UpdateRoundReq, params UpdateRoundParams) (UpdateRoundRes, error) {
	b := h.client.Round.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.RoundNumber.Get(); ok {
		b.SetRoundNumber(v)
	}
	if v, ok := req.Note.Get(); ok {
		b.SetNote(v)
	}
	if v, ok := req.Err.Get(); ok {
		b.SetErr(v)
	}
	if v, ok := req.StartedAt.Get(); ok {
		b.SetStartedAt(v)
	}
	if v, ok := req.FinishedAt.Get(); ok {
		b.SetFinishedAt(v)
	}
	// Add all edges.
	if req.Checks != nil {
		b.ClearChecks().AddCheckIDs(req.Checks...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Round.Query().Where(round.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewRoundUpdate(e), nil
}

// DeleteRound handles DELETE /rounds/{id} requests.
func (h *OgentHandler) DeleteRound(ctx context.Context, params DeleteRoundParams) (DeleteRoundRes, error) {
	err := h.client.Round.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteRoundNoContent), nil

}

// ListRound handles GET /rounds requests.
func (h *OgentHandler) ListRound(ctx context.Context, params ListRoundParams) (ListRoundRes, error) {
	q := h.client.Round.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewRoundLists(es)
	return (*ListRoundOKApplicationJSON)(&r), nil
}

// ListRoundChecks handles GET /rounds/{id}/checks requests.
func (h *OgentHandler) ListRoundChecks(ctx context.Context, params ListRoundChecksParams) (ListRoundChecksRes, error) {
	q := h.client.Round.Query().Where(round.IDEQ(params.ID)).QueryChecks()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewRoundChecksLists(es)
	return (*ListRoundChecksOKApplicationJSON)(&r), nil
}

// ReadRoundCompetition handles GET /rounds/{id}/competition requests.
func (h *OgentHandler) ReadRoundCompetition(ctx context.Context, params ReadRoundCompetitionParams) (ReadRoundCompetitionRes, error) {
	q := h.client.Round.Query().Where(round.IDEQ(params.ID)).QueryCompetition()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewRoundCompetitionRead(e), nil
}

// CreateService handles POST /services requests.
func (h *OgentHandler) CreateService(ctx context.Context, req *CreateServiceReq) (CreateServiceRes, error) {
	b := h.client.Service.Create()
	// Add all fields.
	b.SetName(req.Name)
	b.SetDisplayName(req.DisplayName)
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	b.SetCompetitionID(req.CompetitionID)
	// Add all edges.
	b.SetCompetitionID(req.Competition)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Service.Query().Where(service.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewServiceCreate(e), nil
}

// ReadService handles GET /services/{id} requests.
func (h *OgentHandler) ReadService(ctx context.Context, params ReadServiceParams) (ReadServiceRes, error) {
	q := h.client.Service.Query().Where(service.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewServiceRead(e), nil
}

// UpdateService handles PATCH /services/{id} requests.
func (h *OgentHandler) UpdateService(ctx context.Context, req *UpdateServiceReq, params UpdateServiceParams) (UpdateServiceRes, error) {
	b := h.client.Service.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.DisplayName.Get(); ok {
		b.SetDisplayName(v)
	}
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	// Add all edges.
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Service.Query().Where(service.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewServiceUpdate(e), nil
}

// DeleteService handles DELETE /services/{id} requests.
func (h *OgentHandler) DeleteService(ctx context.Context, params DeleteServiceParams) (DeleteServiceRes, error) {
	err := h.client.Service.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteServiceNoContent), nil

}

// ListService handles GET /services requests.
func (h *OgentHandler) ListService(ctx context.Context, params ListServiceParams) (ListServiceRes, error) {
	q := h.client.Service.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewServiceLists(es)
	return (*ListServiceOKApplicationJSON)(&r), nil
}

// ReadServiceCompetition handles GET /services/{id}/competition requests.
func (h *OgentHandler) ReadServiceCompetition(ctx context.Context, params ReadServiceCompetitionParams) (ReadServiceCompetitionRes, error) {
	q := h.client.Service.Query().Where(service.IDEQ(params.ID)).QueryCompetition()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewServiceCompetitionRead(e), nil
}

// CreateTeam handles POST /teams requests.
func (h *OgentHandler) CreateTeam(ctx context.Context, req *CreateTeamReq) (CreateTeamRes, error) {
	b := h.client.Team.Create()
	// Add all fields.
	b.SetName(req.Name)
	b.SetDisplayName(req.DisplayName)
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	b.SetNumber(req.Number)
	b.SetCompetitionID(req.CompetitionID)
	// Add all edges.
	b.AddHostIDs(req.Hosts...)
	b.AddHostserviceIDs(req.Hostservices...)
	b.AddCheckIDs(req.Checks...)
	b.AddPropertyIDs(req.Properties...)
	b.SetCompetitionID(req.Competition)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Team.Query().Where(team.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewTeamCreate(e), nil
}

// ReadTeam handles GET /teams/{id} requests.
func (h *OgentHandler) ReadTeam(ctx context.Context, params ReadTeamParams) (ReadTeamRes, error) {
	q := h.client.Team.Query().Where(team.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewTeamRead(e), nil
}

// UpdateTeam handles PATCH /teams/{id} requests.
func (h *OgentHandler) UpdateTeam(ctx context.Context, req *UpdateTeamReq, params UpdateTeamParams) (UpdateTeamRes, error) {
	b := h.client.Team.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.DisplayName.Get(); ok {
		b.SetDisplayName(v)
	}
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	if v, ok := req.Number.Get(); ok {
		b.SetNumber(v)
	}
	// Add all edges.
	if req.Hosts != nil {
		b.ClearHosts().AddHostIDs(req.Hosts...)
	}
	if req.Hostservices != nil {
		b.ClearHostservices().AddHostserviceIDs(req.Hostservices...)
	}
	if req.Checks != nil {
		b.ClearChecks().AddCheckIDs(req.Checks...)
	}
	if req.Properties != nil {
		b.ClearProperties().AddPropertyIDs(req.Properties...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Team.Query().Where(team.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewTeamUpdate(e), nil
}

// DeleteTeam handles DELETE /teams/{id} requests.
func (h *OgentHandler) DeleteTeam(ctx context.Context, params DeleteTeamParams) (DeleteTeamRes, error) {
	err := h.client.Team.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteTeamNoContent), nil

}

// ListTeam handles GET /teams requests.
func (h *OgentHandler) ListTeam(ctx context.Context, params ListTeamParams) (ListTeamRes, error) {
	q := h.client.Team.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewTeamLists(es)
	return (*ListTeamOKApplicationJSON)(&r), nil
}

// ListTeamHosts handles GET /teams/{id}/hosts requests.
func (h *OgentHandler) ListTeamHosts(ctx context.Context, params ListTeamHostsParams) (ListTeamHostsRes, error) {
	q := h.client.Team.Query().Where(team.IDEQ(params.ID)).QueryHosts()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewTeamHostsLists(es)
	return (*ListTeamHostsOKApplicationJSON)(&r), nil
}

// ListTeamHostservices handles GET /teams/{id}/hostservices requests.
func (h *OgentHandler) ListTeamHostservices(ctx context.Context, params ListTeamHostservicesParams) (ListTeamHostservicesRes, error) {
	q := h.client.Team.Query().Where(team.IDEQ(params.ID)).QueryHostservices()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewTeamHostservicesLists(es)
	return (*ListTeamHostservicesOKApplicationJSON)(&r), nil
}

// ListTeamChecks handles GET /teams/{id}/checks requests.
func (h *OgentHandler) ListTeamChecks(ctx context.Context, params ListTeamChecksParams) (ListTeamChecksRes, error) {
	q := h.client.Team.Query().Where(team.IDEQ(params.ID)).QueryChecks()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewTeamChecksLists(es)
	return (*ListTeamChecksOKApplicationJSON)(&r), nil
}

// ListTeamProperties handles GET /teams/{id}/properties requests.
func (h *OgentHandler) ListTeamProperties(ctx context.Context, params ListTeamPropertiesParams) (ListTeamPropertiesRes, error) {
	q := h.client.Team.Query().Where(team.IDEQ(params.ID)).QueryProperties()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewTeamPropertiesLists(es)
	return (*ListTeamPropertiesOKApplicationJSON)(&r), nil
}

// ReadTeamCompetition handles GET /teams/{id}/competition requests.
func (h *OgentHandler) ReadTeamCompetition(ctx context.Context, params ReadTeamCompetitionParams) (ReadTeamCompetitionRes, error) {
	q := h.client.Team.Query().Where(team.IDEQ(params.ID)).QueryCompetition()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewTeamCompetitionRead(e), nil
}
