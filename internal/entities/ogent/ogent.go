// Code generated by ent, DO NOT EDIT.

package ogent

import (
	"context"
	"net/http"

	"github.com/ScoreTrak/ScoreTrak/internal/entities"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/check"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/competition"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/host"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/hostgroup"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/property"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/report"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/round"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/service"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/team"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/user"
	"github.com/go-faster/jx"
)

// OgentHandler implements the ogen generated Handler interface and uses Ent as data layer.
type OgentHandler struct {
	client *entities.Client
}

// NewOgentHandler returns a new OgentHandler.
func NewOgentHandler(c *entities.Client) *OgentHandler { return &OgentHandler{c} }

// rawError renders err as json string.
func rawError(err error) jx.Raw {
	var e jx.Encoder
	e.Str(err.Error())
	return e.Bytes()
}

// CreateCheck handles POST /checks requests.
func (h *OgentHandler) CreateCheck(ctx context.Context, req *CreateCheckReq) (CreateCheckRes, error) {
	b := h.client.Check.Create()
	// Add all fields.
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	b.SetCompetitionID(req.CompetitionID)
	b.SetLog(req.Log)
	b.SetError(req.Error)
	b.SetPassed(req.Passed)
	// Add all edges.
	b.SetCompetitionID(req.Competition)
	b.SetRoundsID(req.Rounds)
	b.SetServicesID(req.Services)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Check.Query().Where(check.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewCheckCreate(e), nil
}

// ReadCheck handles GET /checks/{id} requests.
func (h *OgentHandler) ReadCheck(ctx context.Context, params ReadCheckParams) (ReadCheckRes, error) {
	q := h.client.Check.Query().Where(check.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewCheckRead(e), nil
}

// UpdateCheck handles PATCH /checks/{id} requests.
func (h *OgentHandler) UpdateCheck(ctx context.Context, req *UpdateCheckReq, params UpdateCheckParams) (UpdateCheckRes, error) {
	b := h.client.Check.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	if v, ok := req.Log.Get(); ok {
		b.SetLog(v)
	}
	if v, ok := req.Error.Get(); ok {
		b.SetError(v)
	}
	if v, ok := req.Passed.Get(); ok {
		b.SetPassed(v)
	}
	// Add all edges.
	if v, ok := req.Competition.Get(); ok {
		b.SetCompetitionID(v)
	}
	if v, ok := req.Rounds.Get(); ok {
		b.SetRoundsID(v)
	}
	if v, ok := req.Services.Get(); ok {
		b.SetServicesID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Check.Query().Where(check.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewCheckUpdate(e), nil
}

// DeleteCheck handles DELETE /checks/{id} requests.
func (h *OgentHandler) DeleteCheck(ctx context.Context, params DeleteCheckParams) (DeleteCheckRes, error) {
	err := h.client.Check.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteCheckNoContent), nil

}

// ListCheck handles GET /checks requests.
func (h *OgentHandler) ListCheck(ctx context.Context, params ListCheckParams) (ListCheckRes, error) {
	q := h.client.Check.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewCheckLists(es)
	return (*ListCheckOKApplicationJSON)(&r), nil
}

// ReadCheckCompetition handles GET /checks/{id}/competition requests.
func (h *OgentHandler) ReadCheckCompetition(ctx context.Context, params ReadCheckCompetitionParams) (ReadCheckCompetitionRes, error) {
	q := h.client.Check.Query().Where(check.IDEQ(params.ID)).QueryCompetition()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewCheckCompetitionRead(e), nil
}

// ReadCheckRounds handles GET /checks/{id}/rounds requests.
func (h *OgentHandler) ReadCheckRounds(ctx context.Context, params ReadCheckRoundsParams) (ReadCheckRoundsRes, error) {
	q := h.client.Check.Query().Where(check.IDEQ(params.ID)).QueryRounds()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewCheckRoundsRead(e), nil
}

// ReadCheckServices handles GET /checks/{id}/services requests.
func (h *OgentHandler) ReadCheckServices(ctx context.Context, params ReadCheckServicesParams) (ReadCheckServicesRes, error) {
	q := h.client.Check.Query().Where(check.IDEQ(params.ID)).QueryServices()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewCheckServicesRead(e), nil
}

// CreateCompetition handles POST /competitions requests.
func (h *OgentHandler) CreateCompetition(ctx context.Context, req *CreateCompetitionReq) (CreateCompetitionRes, error) {
	b := h.client.Competition.Create()
	// Add all fields.
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	b.SetName(req.Name)
	b.SetDisplayName(req.DisplayName)
	if v, ok := req.ViewableToPublic.Get(); ok {
		b.SetViewableToPublic(v)
	}
	if v, ok := req.ToBeStartedAt.Get(); ok {
		b.SetToBeStartedAt(v)
	}
	if v, ok := req.StartedAt.Get(); ok {
		b.SetStartedAt(v)
	}
	if v, ok := req.FinishedAt.Get(); ok {
		b.SetFinishedAt(v)
	}
	// Add all edges.
	b.AddTeamIDs(req.Teams...)
	b.AddUserIDs(req.Users...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Competition.Query().Where(competition.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewCompetitionCreate(e), nil
}

// ReadCompetition handles GET /competitions/{id} requests.
func (h *OgentHandler) ReadCompetition(ctx context.Context, params ReadCompetitionParams) (ReadCompetitionRes, error) {
	q := h.client.Competition.Query().Where(competition.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewCompetitionRead(e), nil
}

// UpdateCompetition handles PATCH /competitions/{id} requests.
func (h *OgentHandler) UpdateCompetition(ctx context.Context, req *UpdateCompetitionReq, params UpdateCompetitionParams) (UpdateCompetitionRes, error) {
	b := h.client.Competition.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.DisplayName.Get(); ok {
		b.SetDisplayName(v)
	}
	if v, ok := req.ViewableToPublic.Get(); ok {
		b.SetViewableToPublic(v)
	}
	if v, ok := req.ToBeStartedAt.Get(); ok {
		b.SetToBeStartedAt(v)
	}
	if v, ok := req.StartedAt.Get(); ok {
		b.SetStartedAt(v)
	}
	if v, ok := req.FinishedAt.Get(); ok {
		b.SetFinishedAt(v)
	}
	// Add all edges.
	if req.Teams != nil {
		b.ClearTeams().AddTeamIDs(req.Teams...)
	}
	if req.Users != nil {
		b.ClearUsers().AddUserIDs(req.Users...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Competition.Query().Where(competition.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewCompetitionUpdate(e), nil
}

// DeleteCompetition handles DELETE /competitions/{id} requests.
func (h *OgentHandler) DeleteCompetition(ctx context.Context, params DeleteCompetitionParams) (DeleteCompetitionRes, error) {
	err := h.client.Competition.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteCompetitionNoContent), nil

}

// ListCompetition handles GET /competitions requests.
func (h *OgentHandler) ListCompetition(ctx context.Context, params ListCompetitionParams) (ListCompetitionRes, error) {
	q := h.client.Competition.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewCompetitionLists(es)
	return (*ListCompetitionOKApplicationJSON)(&r), nil
}

// ListCompetitionTeams handles GET /competitions/{id}/teams requests.
func (h *OgentHandler) ListCompetitionTeams(ctx context.Context, params ListCompetitionTeamsParams) (ListCompetitionTeamsRes, error) {
	q := h.client.Competition.Query().Where(competition.IDEQ(params.ID)).QueryTeams()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewCompetitionTeamsLists(es)
	return (*ListCompetitionTeamsOKApplicationJSON)(&r), nil
}

// ListCompetitionUsers handles GET /competitions/{id}/users requests.
func (h *OgentHandler) ListCompetitionUsers(ctx context.Context, params ListCompetitionUsersParams) (ListCompetitionUsersRes, error) {
	q := h.client.Competition.Query().Where(competition.IDEQ(params.ID)).QueryUsers()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewCompetitionUsersLists(es)
	return (*ListCompetitionUsersOKApplicationJSON)(&r), nil
}

// CreateHost handles POST /hosts requests.
func (h *OgentHandler) CreateHost(ctx context.Context, req *CreateHostReq) (CreateHostRes, error) {
	b := h.client.Host.Create()
	// Add all fields.
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	b.SetCompetitionID(req.CompetitionID)
	b.SetTeamID(req.TeamID)
	b.SetAddress(req.Address)
	b.SetAddressListRange(req.AddressListRange)
	b.SetEditable(req.Editable)
	// Add all edges.
	b.SetCompetitionID(req.Competition)
	b.SetTeamID(req.Team)
	b.AddServiceIDs(req.Services...)
	b.SetHostGroupID(req.HostGroup)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Host.Query().Where(host.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewHostCreate(e), nil
}

// ReadHost handles GET /hosts/{id} requests.
func (h *OgentHandler) ReadHost(ctx context.Context, params ReadHostParams) (ReadHostRes, error) {
	q := h.client.Host.Query().Where(host.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewHostRead(e), nil
}

// UpdateHost handles PATCH /hosts/{id} requests.
func (h *OgentHandler) UpdateHost(ctx context.Context, req *UpdateHostReq, params UpdateHostParams) (UpdateHostRes, error) {
	b := h.client.Host.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	if v, ok := req.TeamID.Get(); ok {
		b.SetTeamID(v)
	}
	if v, ok := req.Address.Get(); ok {
		b.SetAddress(v)
	}
	if v, ok := req.AddressListRange.Get(); ok {
		b.SetAddressListRange(v)
	}
	if v, ok := req.Editable.Get(); ok {
		b.SetEditable(v)
	}
	// Add all edges.
	if v, ok := req.Competition.Get(); ok {
		b.SetCompetitionID(v)
	}
	if v, ok := req.Team.Get(); ok {
		b.SetTeamID(v)
	}
	if req.Services != nil {
		b.ClearServices().AddServiceIDs(req.Services...)
	}
	if v, ok := req.HostGroup.Get(); ok {
		b.SetHostGroupID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Host.Query().Where(host.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewHostUpdate(e), nil
}

// DeleteHost handles DELETE /hosts/{id} requests.
func (h *OgentHandler) DeleteHost(ctx context.Context, params DeleteHostParams) (DeleteHostRes, error) {
	err := h.client.Host.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteHostNoContent), nil

}

// ListHost handles GET /hosts requests.
func (h *OgentHandler) ListHost(ctx context.Context, params ListHostParams) (ListHostRes, error) {
	q := h.client.Host.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewHostLists(es)
	return (*ListHostOKApplicationJSON)(&r), nil
}

// ReadHostCompetition handles GET /hosts/{id}/competition requests.
func (h *OgentHandler) ReadHostCompetition(ctx context.Context, params ReadHostCompetitionParams) (ReadHostCompetitionRes, error) {
	q := h.client.Host.Query().Where(host.IDEQ(params.ID)).QueryCompetition()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewHostCompetitionRead(e), nil
}

// ReadHostTeam handles GET /hosts/{id}/team requests.
func (h *OgentHandler) ReadHostTeam(ctx context.Context, params ReadHostTeamParams) (ReadHostTeamRes, error) {
	q := h.client.Host.Query().Where(host.IDEQ(params.ID)).QueryTeam()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewHostTeamRead(e), nil
}

// ListHostServices handles GET /hosts/{id}/services requests.
func (h *OgentHandler) ListHostServices(ctx context.Context, params ListHostServicesParams) (ListHostServicesRes, error) {
	q := h.client.Host.Query().Where(host.IDEQ(params.ID)).QueryServices()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewHostServicesLists(es)
	return (*ListHostServicesOKApplicationJSON)(&r), nil
}

// ReadHostHostGroup handles GET /hosts/{id}/host-group requests.
func (h *OgentHandler) ReadHostHostGroup(ctx context.Context, params ReadHostHostGroupParams) (ReadHostHostGroupRes, error) {
	q := h.client.Host.Query().Where(host.IDEQ(params.ID)).QueryHostGroup()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewHostHostGroupRead(e), nil
}

// CreateHostGroup handles POST /host-groups requests.
func (h *OgentHandler) CreateHostGroup(ctx context.Context, req *CreateHostGroupReq) (CreateHostGroupRes, error) {
	b := h.client.HostGroup.Create()
	// Add all fields.
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	b.SetCompetitionID(req.CompetitionID)
	b.SetTeamID(req.TeamID)
	b.SetName(req.Name)
	// Add all edges.
	b.SetCompetitionID(req.Competition)
	b.SetTeamID(req.Team)
	b.AddHostIDs(req.Hosts...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.HostGroup.Query().Where(hostgroup.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewHostGroupCreate(e), nil
}

// ReadHostGroup handles GET /host-groups/{id} requests.
func (h *OgentHandler) ReadHostGroup(ctx context.Context, params ReadHostGroupParams) (ReadHostGroupRes, error) {
	q := h.client.HostGroup.Query().Where(hostgroup.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewHostGroupRead(e), nil
}

// UpdateHostGroup handles PATCH /host-groups/{id} requests.
func (h *OgentHandler) UpdateHostGroup(ctx context.Context, req *UpdateHostGroupReq, params UpdateHostGroupParams) (UpdateHostGroupRes, error) {
	b := h.client.HostGroup.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	if v, ok := req.TeamID.Get(); ok {
		b.SetTeamID(v)
	}
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	// Add all edges.
	if v, ok := req.Competition.Get(); ok {
		b.SetCompetitionID(v)
	}
	if v, ok := req.Team.Get(); ok {
		b.SetTeamID(v)
	}
	if req.Hosts != nil {
		b.ClearHosts().AddHostIDs(req.Hosts...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.HostGroup.Query().Where(hostgroup.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewHostGroupUpdate(e), nil
}

// DeleteHostGroup handles DELETE /host-groups/{id} requests.
func (h *OgentHandler) DeleteHostGroup(ctx context.Context, params DeleteHostGroupParams) (DeleteHostGroupRes, error) {
	err := h.client.HostGroup.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteHostGroupNoContent), nil

}

// ListHostGroup handles GET /host-groups requests.
func (h *OgentHandler) ListHostGroup(ctx context.Context, params ListHostGroupParams) (ListHostGroupRes, error) {
	q := h.client.HostGroup.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewHostGroupLists(es)
	return (*ListHostGroupOKApplicationJSON)(&r), nil
}

// ReadHostGroupCompetition handles GET /host-groups/{id}/competition requests.
func (h *OgentHandler) ReadHostGroupCompetition(ctx context.Context, params ReadHostGroupCompetitionParams) (ReadHostGroupCompetitionRes, error) {
	q := h.client.HostGroup.Query().Where(hostgroup.IDEQ(params.ID)).QueryCompetition()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewHostGroupCompetitionRead(e), nil
}

// ReadHostGroupTeam handles GET /host-groups/{id}/team requests.
func (h *OgentHandler) ReadHostGroupTeam(ctx context.Context, params ReadHostGroupTeamParams) (ReadHostGroupTeamRes, error) {
	q := h.client.HostGroup.Query().Where(hostgroup.IDEQ(params.ID)).QueryTeam()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewHostGroupTeamRead(e), nil
}

// ListHostGroupHosts handles GET /host-groups/{id}/hosts requests.
func (h *OgentHandler) ListHostGroupHosts(ctx context.Context, params ListHostGroupHostsParams) (ListHostGroupHostsRes, error) {
	q := h.client.HostGroup.Query().Where(hostgroup.IDEQ(params.ID)).QueryHosts()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewHostGroupHostsLists(es)
	return (*ListHostGroupHostsOKApplicationJSON)(&r), nil
}

// CreateProperty handles POST /properties requests.
func (h *OgentHandler) CreateProperty(ctx context.Context, req *CreatePropertyReq) (CreatePropertyRes, error) {
	b := h.client.Property.Create()
	// Add all fields.
	b.SetCompetitionID(req.CompetitionID)
	b.SetTeamID(req.TeamID)
	b.SetKey(req.Key)
	b.SetValue(req.Value)
	b.SetStatus(property.Status(req.Status))
	// Add all edges.
	b.SetCompetitionID(req.Competition)
	b.SetTeamID(req.Team)
	b.SetServicesID(req.Services)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Property.Query().Where(property.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewPropertyCreate(e), nil
}

// ReadProperty handles GET /properties/{id} requests.
func (h *OgentHandler) ReadProperty(ctx context.Context, params ReadPropertyParams) (ReadPropertyRes, error) {
	q := h.client.Property.Query().Where(property.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewPropertyRead(e), nil
}

// UpdateProperty handles PATCH /properties/{id} requests.
func (h *OgentHandler) UpdateProperty(ctx context.Context, req *UpdatePropertyReq, params UpdatePropertyParams) (UpdatePropertyRes, error) {
	b := h.client.Property.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.TeamID.Get(); ok {
		b.SetTeamID(v)
	}
	if v, ok := req.Key.Get(); ok {
		b.SetKey(v)
	}
	if v, ok := req.Value.Get(); ok {
		b.SetValue(v)
	}
	if v, ok := req.Status.Get(); ok {
		b.SetStatus(property.Status(v))
	}
	// Add all edges.
	if v, ok := req.Competition.Get(); ok {
		b.SetCompetitionID(v)
	}
	if v, ok := req.Team.Get(); ok {
		b.SetTeamID(v)
	}
	if v, ok := req.Services.Get(); ok {
		b.SetServicesID(v)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Property.Query().Where(property.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewPropertyUpdate(e), nil
}

// DeleteProperty handles DELETE /properties/{id} requests.
func (h *OgentHandler) DeleteProperty(ctx context.Context, params DeletePropertyParams) (DeletePropertyRes, error) {
	err := h.client.Property.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeletePropertyNoContent), nil

}

// ListProperty handles GET /properties requests.
func (h *OgentHandler) ListProperty(ctx context.Context, params ListPropertyParams) (ListPropertyRes, error) {
	q := h.client.Property.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewPropertyLists(es)
	return (*ListPropertyOKApplicationJSON)(&r), nil
}

// ReadPropertyCompetition handles GET /properties/{id}/competition requests.
func (h *OgentHandler) ReadPropertyCompetition(ctx context.Context, params ReadPropertyCompetitionParams) (ReadPropertyCompetitionRes, error) {
	q := h.client.Property.Query().Where(property.IDEQ(params.ID)).QueryCompetition()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewPropertyCompetitionRead(e), nil
}

// ReadPropertyTeam handles GET /properties/{id}/team requests.
func (h *OgentHandler) ReadPropertyTeam(ctx context.Context, params ReadPropertyTeamParams) (ReadPropertyTeamRes, error) {
	q := h.client.Property.Query().Where(property.IDEQ(params.ID)).QueryTeam()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewPropertyTeamRead(e), nil
}

// ReadPropertyServices handles GET /properties/{id}/services requests.
func (h *OgentHandler) ReadPropertyServices(ctx context.Context, params ReadPropertyServicesParams) (ReadPropertyServicesRes, error) {
	q := h.client.Property.Query().Where(property.IDEQ(params.ID)).QueryServices()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewPropertyServicesRead(e), nil
}

// CreateReport handles POST /reports requests.
func (h *OgentHandler) CreateReport(ctx context.Context, req *CreateReportReq) (CreateReportRes, error) {
	b := h.client.Report.Create()
	// Add all fields.
	b.SetLog(req.Log)
	b.SetError(req.Error)
	// Add all edges.
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Report.Query().Where(report.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewReportCreate(e), nil
}

// ReadReport handles GET /reports/{id} requests.
func (h *OgentHandler) ReadReport(ctx context.Context, params ReadReportParams) (ReadReportRes, error) {
	q := h.client.Report.Query().Where(report.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewReportRead(e), nil
}

// UpdateReport handles PATCH /reports/{id} requests.
func (h *OgentHandler) UpdateReport(ctx context.Context, req *UpdateReportReq, params UpdateReportParams) (UpdateReportRes, error) {
	b := h.client.Report.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Log.Get(); ok {
		b.SetLog(v)
	}
	if v, ok := req.Error.Get(); ok {
		b.SetError(v)
	}
	// Add all edges.
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Report.Query().Where(report.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewReportUpdate(e), nil
}

// DeleteReport handles DELETE /reports/{id} requests.
func (h *OgentHandler) DeleteReport(ctx context.Context, params DeleteReportParams) (DeleteReportRes, error) {
	err := h.client.Report.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteReportNoContent), nil

}

// ListReport handles GET /reports requests.
func (h *OgentHandler) ListReport(ctx context.Context, params ListReportParams) (ListReportRes, error) {
	q := h.client.Report.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewReportLists(es)
	return (*ListReportOKApplicationJSON)(&r), nil
}

// CreateRound handles POST /rounds requests.
func (h *OgentHandler) CreateRound(ctx context.Context, req *CreateRoundReq) (CreateRoundRes, error) {
	b := h.client.Round.Create()
	// Add all fields.
	b.SetCompetitionID(req.CompetitionID)
	b.SetRoundNumber(req.RoundNumber)
	b.SetNote(req.Note)
	b.SetErr(req.Err)
	b.SetStartedAt(req.StartedAt)
	b.SetFinishedAt(req.FinishedAt)
	// Add all edges.
	b.SetCompetitionID(req.Competition)
	b.AddCheckIDs(req.Checks...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Round.Query().Where(round.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewRoundCreate(e), nil
}

// ReadRound handles GET /rounds/{id} requests.
func (h *OgentHandler) ReadRound(ctx context.Context, params ReadRoundParams) (ReadRoundRes, error) {
	q := h.client.Round.Query().Where(round.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewRoundRead(e), nil
}

// UpdateRound handles PATCH /rounds/{id} requests.
func (h *OgentHandler) UpdateRound(ctx context.Context, req *UpdateRoundReq, params UpdateRoundParams) (UpdateRoundRes, error) {
	b := h.client.Round.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.RoundNumber.Get(); ok {
		b.SetRoundNumber(v)
	}
	if v, ok := req.Note.Get(); ok {
		b.SetNote(v)
	}
	if v, ok := req.Err.Get(); ok {
		b.SetErr(v)
	}
	if v, ok := req.StartedAt.Get(); ok {
		b.SetStartedAt(v)
	}
	if v, ok := req.FinishedAt.Get(); ok {
		b.SetFinishedAt(v)
	}
	// Add all edges.
	if v, ok := req.Competition.Get(); ok {
		b.SetCompetitionID(v)
	}
	if req.Checks != nil {
		b.ClearChecks().AddCheckIDs(req.Checks...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Round.Query().Where(round.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewRoundUpdate(e), nil
}

// DeleteRound handles DELETE /rounds/{id} requests.
func (h *OgentHandler) DeleteRound(ctx context.Context, params DeleteRoundParams) (DeleteRoundRes, error) {
	err := h.client.Round.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteRoundNoContent), nil

}

// ListRound handles GET /rounds requests.
func (h *OgentHandler) ListRound(ctx context.Context, params ListRoundParams) (ListRoundRes, error) {
	q := h.client.Round.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewRoundLists(es)
	return (*ListRoundOKApplicationJSON)(&r), nil
}

// ReadRoundCompetition handles GET /rounds/{id}/competition requests.
func (h *OgentHandler) ReadRoundCompetition(ctx context.Context, params ReadRoundCompetitionParams) (ReadRoundCompetitionRes, error) {
	q := h.client.Round.Query().Where(round.IDEQ(params.ID)).QueryCompetition()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewRoundCompetitionRead(e), nil
}

// ListRoundChecks handles GET /rounds/{id}/checks requests.
func (h *OgentHandler) ListRoundChecks(ctx context.Context, params ListRoundChecksParams) (ListRoundChecksRes, error) {
	q := h.client.Round.Query().Where(round.IDEQ(params.ID)).QueryChecks()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewRoundChecksLists(es)
	return (*ListRoundChecksOKApplicationJSON)(&r), nil
}

// CreateService handles POST /services requests.
func (h *OgentHandler) CreateService(ctx context.Context, req *CreateServiceReq) (CreateServiceRes, error) {
	b := h.client.Service.Create()
	// Add all fields.
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	b.SetCompetitionID(req.CompetitionID)
	b.SetTeamID(req.TeamID)
	b.SetName(req.Name)
	b.SetDisplayName(req.DisplayName)
	b.SetWeight(req.Weight)
	b.SetPointBoost(req.PointBoost)
	b.SetRoundUnits(req.RoundUnits)
	b.SetRoundDelay(req.RoundDelay)
	// Add all edges.
	b.SetCompetitionID(req.Competition)
	b.SetTeamID(req.Team)
	if v, ok := req.Hosts.Get(); ok {
		b.SetHostsID(v)
	}
	b.AddCheckIDs(req.Checks...)
	b.AddPropertyIDs(req.Properties...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Service.Query().Where(service.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewServiceCreate(e), nil
}

// ReadService handles GET /services/{id} requests.
func (h *OgentHandler) ReadService(ctx context.Context, params ReadServiceParams) (ReadServiceRes, error) {
	q := h.client.Service.Query().Where(service.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewServiceRead(e), nil
}

// UpdateService handles PATCH /services/{id} requests.
func (h *OgentHandler) UpdateService(ctx context.Context, req *UpdateServiceReq, params UpdateServiceParams) (UpdateServiceRes, error) {
	b := h.client.Service.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	if v, ok := req.TeamID.Get(); ok {
		b.SetTeamID(v)
	}
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.DisplayName.Get(); ok {
		b.SetDisplayName(v)
	}
	if v, ok := req.Weight.Get(); ok {
		b.SetWeight(v)
	}
	if v, ok := req.PointBoost.Get(); ok {
		b.SetPointBoost(v)
	}
	if v, ok := req.RoundUnits.Get(); ok {
		b.SetRoundUnits(v)
	}
	if v, ok := req.RoundDelay.Get(); ok {
		b.SetRoundDelay(v)
	}
	// Add all edges.
	if v, ok := req.Competition.Get(); ok {
		b.SetCompetitionID(v)
	}
	if v, ok := req.Team.Get(); ok {
		b.SetTeamID(v)
	}
	if v, ok := req.Hosts.Get(); ok {
		b.SetHostsID(v)
	}
	if req.Checks != nil {
		b.ClearChecks().AddCheckIDs(req.Checks...)
	}
	if req.Properties != nil {
		b.ClearProperties().AddPropertyIDs(req.Properties...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Service.Query().Where(service.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewServiceUpdate(e), nil
}

// DeleteService handles DELETE /services/{id} requests.
func (h *OgentHandler) DeleteService(ctx context.Context, params DeleteServiceParams) (DeleteServiceRes, error) {
	err := h.client.Service.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteServiceNoContent), nil

}

// ListService handles GET /services requests.
func (h *OgentHandler) ListService(ctx context.Context, params ListServiceParams) (ListServiceRes, error) {
	q := h.client.Service.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewServiceLists(es)
	return (*ListServiceOKApplicationJSON)(&r), nil
}

// ReadServiceCompetition handles GET /services/{id}/competition requests.
func (h *OgentHandler) ReadServiceCompetition(ctx context.Context, params ReadServiceCompetitionParams) (ReadServiceCompetitionRes, error) {
	q := h.client.Service.Query().Where(service.IDEQ(params.ID)).QueryCompetition()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewServiceCompetitionRead(e), nil
}

// ReadServiceTeam handles GET /services/{id}/team requests.
func (h *OgentHandler) ReadServiceTeam(ctx context.Context, params ReadServiceTeamParams) (ReadServiceTeamRes, error) {
	q := h.client.Service.Query().Where(service.IDEQ(params.ID)).QueryTeam()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewServiceTeamRead(e), nil
}

// ReadServiceHosts handles GET /services/{id}/hosts requests.
func (h *OgentHandler) ReadServiceHosts(ctx context.Context, params ReadServiceHostsParams) (ReadServiceHostsRes, error) {
	q := h.client.Service.Query().Where(service.IDEQ(params.ID)).QueryHosts()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewServiceHostsRead(e), nil
}

// ListServiceChecks handles GET /services/{id}/checks requests.
func (h *OgentHandler) ListServiceChecks(ctx context.Context, params ListServiceChecksParams) (ListServiceChecksRes, error) {
	q := h.client.Service.Query().Where(service.IDEQ(params.ID)).QueryChecks()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewServiceChecksLists(es)
	return (*ListServiceChecksOKApplicationJSON)(&r), nil
}

// ListServiceProperties handles GET /services/{id}/properties requests.
func (h *OgentHandler) ListServiceProperties(ctx context.Context, params ListServicePropertiesParams) (ListServicePropertiesRes, error) {
	q := h.client.Service.Query().Where(service.IDEQ(params.ID)).QueryProperties()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewServicePropertiesLists(es)
	return (*ListServicePropertiesOKApplicationJSON)(&r), nil
}

// CreateTeam handles POST /teams requests.
func (h *OgentHandler) CreateTeam(ctx context.Context, req *CreateTeamReq) (CreateTeamRes, error) {
	b := h.client.Team.Create()
	// Add all fields.
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	b.SetCompetitionID(req.CompetitionID)
	b.SetName(req.Name)
	if v, ok := req.Index.Get(); ok {
		b.SetIndex(v)
	}
	// Add all edges.
	b.SetCompetitionID(req.Competition)
	b.AddUserIDs(req.Users...)
	b.AddHostIDs(req.Hosts...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Team.Query().Where(team.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewTeamCreate(e), nil
}

// ReadTeam handles GET /teams/{id} requests.
func (h *OgentHandler) ReadTeam(ctx context.Context, params ReadTeamParams) (ReadTeamRes, error) {
	q := h.client.Team.Query().Where(team.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewTeamRead(e), nil
}

// UpdateTeam handles PATCH /teams/{id} requests.
func (h *OgentHandler) UpdateTeam(ctx context.Context, req *UpdateTeamReq, params UpdateTeamParams) (UpdateTeamRes, error) {
	b := h.client.Team.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Pause.Get(); ok {
		b.SetPause(v)
	}
	if v, ok := req.Hidden.Get(); ok {
		b.SetHidden(v)
	}
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.Index.Get(); ok {
		b.SetIndex(v)
	}
	// Add all edges.
	if v, ok := req.Competition.Get(); ok {
		b.SetCompetitionID(v)
	}
	if req.Users != nil {
		b.ClearUsers().AddUserIDs(req.Users...)
	}
	if req.Hosts != nil {
		b.ClearHosts().AddHostIDs(req.Hosts...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Team.Query().Where(team.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewTeamUpdate(e), nil
}

// DeleteTeam handles DELETE /teams/{id} requests.
func (h *OgentHandler) DeleteTeam(ctx context.Context, params DeleteTeamParams) (DeleteTeamRes, error) {
	err := h.client.Team.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteTeamNoContent), nil

}

// ListTeam handles GET /teams requests.
func (h *OgentHandler) ListTeam(ctx context.Context, params ListTeamParams) (ListTeamRes, error) {
	q := h.client.Team.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewTeamLists(es)
	return (*ListTeamOKApplicationJSON)(&r), nil
}

// ReadTeamCompetition handles GET /teams/{id}/competition requests.
func (h *OgentHandler) ReadTeamCompetition(ctx context.Context, params ReadTeamCompetitionParams) (ReadTeamCompetitionRes, error) {
	q := h.client.Team.Query().Where(team.IDEQ(params.ID)).QueryCompetition()
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewTeamCompetitionRead(e), nil
}

// ListTeamUsers handles GET /teams/{id}/users requests.
func (h *OgentHandler) ListTeamUsers(ctx context.Context, params ListTeamUsersParams) (ListTeamUsersRes, error) {
	q := h.client.Team.Query().Where(team.IDEQ(params.ID)).QueryUsers()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewTeamUsersLists(es)
	return (*ListTeamUsersOKApplicationJSON)(&r), nil
}

// ListTeamHosts handles GET /teams/{id}/hosts requests.
func (h *OgentHandler) ListTeamHosts(ctx context.Context, params ListTeamHostsParams) (ListTeamHostsRes, error) {
	q := h.client.Team.Query().Where(team.IDEQ(params.ID)).QueryHosts()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewTeamHostsLists(es)
	return (*ListTeamHostsOKApplicationJSON)(&r), nil
}

// CreateUser handles POST /users requests.
func (h *OgentHandler) CreateUser(ctx context.Context, req *CreateUserReq) (CreateUserRes, error) {
	b := h.client.User.Create()
	// Add all fields.
	if v, ok := req.CreateTime.Get(); ok {
		b.SetCreateTime(v)
	}
	if v, ok := req.UpdateTime.Get(); ok {
		b.SetUpdateTime(v)
	}
	b.SetUsername(req.Username)
	b.SetOryID(req.OryID)
	// Add all edges.
	b.AddTeamIDs(req.Teams...)
	b.AddCompetitionIDs(req.Competitions...)
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.User.Query().Where(user.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewUserCreate(e), nil
}

// ReadUser handles GET /users/{id} requests.
func (h *OgentHandler) ReadUser(ctx context.Context, params ReadUserParams) (ReadUserRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewUserRead(e), nil
}

// UpdateUser handles PATCH /users/{id} requests.
func (h *OgentHandler) UpdateUser(ctx context.Context, req *UpdateUserReq, params UpdateUserParams) (UpdateUserRes, error) {
	b := h.client.User.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.UpdateTime.Get(); ok {
		b.SetUpdateTime(v)
	}
	if v, ok := req.Username.Get(); ok {
		b.SetUsername(v)
	}
	// Add all edges.
	if req.Teams != nil {
		b.ClearTeams().AddTeamIDs(req.Teams...)
	}
	if req.Competitions != nil {
		b.ClearCompetitions().AddCompetitionIDs(req.Competitions...)
	}
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.User.Query().Where(user.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewUserUpdate(e), nil
}

// DeleteUser handles DELETE /users/{id} requests.
func (h *OgentHandler) DeleteUser(ctx context.Context, params DeleteUserParams) (DeleteUserRes, error) {
	err := h.client.User.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteUserNoContent), nil

}

// ListUser handles GET /users requests.
func (h *OgentHandler) ListUser(ctx context.Context, params ListUserParams) (ListUserRes, error) {
	q := h.client.User.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewUserLists(es)
	return (*ListUserOKApplicationJSON)(&r), nil
}

// ListUserTeams handles GET /users/{id}/teams requests.
func (h *OgentHandler) ListUserTeams(ctx context.Context, params ListUserTeamsParams) (ListUserTeamsRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID)).QueryTeams()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewUserTeamsLists(es)
	return (*ListUserTeamsOKApplicationJSON)(&r), nil
}

// ListUserCompetitions handles GET /users/{id}/competitions requests.
func (h *OgentHandler) ListUserCompetitions(ctx context.Context, params ListUserCompetitionsParams) (ListUserCompetitionsRes, error) {
	q := h.client.User.Query().Where(user.IDEQ(params.ID)).QueryCompetitions()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)
	es, err := q.All(ctx)
	if err != nil {
		switch {
		case entities.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case entities.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewUserCompetitionsLists(es)
	return (*ListUserCompetitionsOKApplicationJSON)(&r), nil
}
