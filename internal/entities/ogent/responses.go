// Code generated by ent, DO NOT EDIT.

package ogent

import "github.com/ScoreTrak/ScoreTrak/internal/entities"

func NewCheckCreate(e *entities.Check) *CheckCreate {
	if e == nil {
		return nil
	}
	var ret CheckCreate
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.Log = e.Log
	ret.Error = e.Error
	ret.Passed = e.Passed
	return &ret
}

func NewCheckCreates(es []*entities.Check) []CheckCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]CheckCreate, len(es))
	for i, e := range es {
		r[i] = NewCheckCreate(e).Elem()
	}
	return r
}

func (c *CheckCreate) Elem() CheckCreate {
	if c == nil {
		return CheckCreate{}
	}
	return *c
}

func NewCheckList(e *entities.Check) *CheckList {
	if e == nil {
		return nil
	}
	var ret CheckList
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.Log = e.Log
	ret.Error = e.Error
	ret.Passed = e.Passed
	return &ret
}

func NewCheckLists(es []*entities.Check) []CheckList {
	if len(es) == 0 {
		return nil
	}
	r := make([]CheckList, len(es))
	for i, e := range es {
		r[i] = NewCheckList(e).Elem()
	}
	return r
}

func (c *CheckList) Elem() CheckList {
	if c == nil {
		return CheckList{}
	}
	return *c
}

func NewCheckRead(e *entities.Check) *CheckRead {
	if e == nil {
		return nil
	}
	var ret CheckRead
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.Log = e.Log
	ret.Error = e.Error
	ret.Passed = e.Passed
	return &ret
}

func NewCheckReads(es []*entities.Check) []CheckRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]CheckRead, len(es))
	for i, e := range es {
		r[i] = NewCheckRead(e).Elem()
	}
	return r
}

func (c *CheckRead) Elem() CheckRead {
	if c == nil {
		return CheckRead{}
	}
	return *c
}

func NewCheckUpdate(e *entities.Check) *CheckUpdate {
	if e == nil {
		return nil
	}
	var ret CheckUpdate
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.Log = e.Log
	ret.Error = e.Error
	ret.Passed = e.Passed
	return &ret
}

func NewCheckUpdates(es []*entities.Check) []CheckUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]CheckUpdate, len(es))
	for i, e := range es {
		r[i] = NewCheckUpdate(e).Elem()
	}
	return r
}

func (c *CheckUpdate) Elem() CheckUpdate {
	if c == nil {
		return CheckUpdate{}
	}
	return *c
}

func NewCheckCompetitionRead(e *entities.Competition) *CheckCompetitionRead {
	if e == nil {
		return nil
	}
	var ret CheckCompetitionRead
	ret.ID = e.ID
	ret.Hidden = NewOptBool(e.Hidden)
	ret.Pause = NewOptBool(e.Pause)
	ret.Name = e.Name
	ret.DisplayName = e.DisplayName
	ret.ViewableToPublic = OptBool{}
	if e.ViewableToPublic != nil {
		ret.ViewableToPublic.SetTo(*e.ViewableToPublic)
	}
	ret.ToBeStartedAt = OptDateTime{}
	if e.ToBeStartedAt != nil {
		ret.ToBeStartedAt.SetTo(*e.ToBeStartedAt)
	}
	ret.StartedAt = OptDateTime{}
	if e.StartedAt != nil {
		ret.StartedAt.SetTo(*e.StartedAt)
	}
	ret.FinishedAt = OptDateTime{}
	if e.FinishedAt != nil {
		ret.FinishedAt.SetTo(*e.FinishedAt)
	}
	return &ret
}

func NewCheckCompetitionReads(es []*entities.Competition) []CheckCompetitionRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]CheckCompetitionRead, len(es))
	for i, e := range es {
		r[i] = NewCheckCompetitionRead(e).Elem()
	}
	return r
}

func (c *CheckCompetitionRead) Elem() CheckCompetitionRead {
	if c == nil {
		return CheckCompetitionRead{}
	}
	return *c
}

func NewCheckRoundsRead(e *entities.Round) *CheckRoundsRead {
	if e == nil {
		return nil
	}
	var ret CheckRoundsRead
	ret.ID = e.ID
	ret.CompetitionID = e.CompetitionID
	ret.RoundNumber = e.RoundNumber
	ret.Note = e.Note
	ret.Err = e.Err
	ret.StartedAt = e.StartedAt
	ret.FinishedAt = e.FinishedAt
	return &ret
}

func NewCheckRoundsReads(es []*entities.Round) []CheckRoundsRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]CheckRoundsRead, len(es))
	for i, e := range es {
		r[i] = NewCheckRoundsRead(e).Elem()
	}
	return r
}

func (r *CheckRoundsRead) Elem() CheckRoundsRead {
	if r == nil {
		return CheckRoundsRead{}
	}
	return *r
}

func NewCheckServicesRead(e *entities.Service) *CheckServicesRead {
	if e == nil {
		return nil
	}
	var ret CheckServicesRead
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.TeamID = e.TeamID
	ret.Name = e.Name
	ret.DisplayName = e.DisplayName
	ret.Weight = e.Weight
	ret.PointBoost = e.PointBoost
	ret.RoundUnits = e.RoundUnits
	ret.RoundDelay = e.RoundDelay
	return &ret
}

func NewCheckServicesReads(es []*entities.Service) []CheckServicesRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]CheckServicesRead, len(es))
	for i, e := range es {
		r[i] = NewCheckServicesRead(e).Elem()
	}
	return r
}

func (s *CheckServicesRead) Elem() CheckServicesRead {
	if s == nil {
		return CheckServicesRead{}
	}
	return *s
}

func NewCompetitionCreate(e *entities.Competition) *CompetitionCreate {
	if e == nil {
		return nil
	}
	var ret CompetitionCreate
	ret.ID = e.ID
	ret.Hidden = NewOptBool(e.Hidden)
	ret.Pause = NewOptBool(e.Pause)
	ret.Name = e.Name
	ret.DisplayName = e.DisplayName
	ret.ViewableToPublic = OptBool{}
	if e.ViewableToPublic != nil {
		ret.ViewableToPublic.SetTo(*e.ViewableToPublic)
	}
	ret.ToBeStartedAt = OptDateTime{}
	if e.ToBeStartedAt != nil {
		ret.ToBeStartedAt.SetTo(*e.ToBeStartedAt)
	}
	ret.StartedAt = OptDateTime{}
	if e.StartedAt != nil {
		ret.StartedAt.SetTo(*e.StartedAt)
	}
	ret.FinishedAt = OptDateTime{}
	if e.FinishedAt != nil {
		ret.FinishedAt.SetTo(*e.FinishedAt)
	}
	return &ret
}

func NewCompetitionCreates(es []*entities.Competition) []CompetitionCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]CompetitionCreate, len(es))
	for i, e := range es {
		r[i] = NewCompetitionCreate(e).Elem()
	}
	return r
}

func (c *CompetitionCreate) Elem() CompetitionCreate {
	if c == nil {
		return CompetitionCreate{}
	}
	return *c
}

func NewCompetitionList(e *entities.Competition) *CompetitionList {
	if e == nil {
		return nil
	}
	var ret CompetitionList
	ret.ID = e.ID
	ret.Hidden = NewOptBool(e.Hidden)
	ret.Pause = NewOptBool(e.Pause)
	ret.Name = e.Name
	ret.DisplayName = e.DisplayName
	ret.ViewableToPublic = OptBool{}
	if e.ViewableToPublic != nil {
		ret.ViewableToPublic.SetTo(*e.ViewableToPublic)
	}
	ret.ToBeStartedAt = OptDateTime{}
	if e.ToBeStartedAt != nil {
		ret.ToBeStartedAt.SetTo(*e.ToBeStartedAt)
	}
	ret.StartedAt = OptDateTime{}
	if e.StartedAt != nil {
		ret.StartedAt.SetTo(*e.StartedAt)
	}
	ret.FinishedAt = OptDateTime{}
	if e.FinishedAt != nil {
		ret.FinishedAt.SetTo(*e.FinishedAt)
	}
	return &ret
}

func NewCompetitionLists(es []*entities.Competition) []CompetitionList {
	if len(es) == 0 {
		return nil
	}
	r := make([]CompetitionList, len(es))
	for i, e := range es {
		r[i] = NewCompetitionList(e).Elem()
	}
	return r
}

func (c *CompetitionList) Elem() CompetitionList {
	if c == nil {
		return CompetitionList{}
	}
	return *c
}

func NewCompetitionRead(e *entities.Competition) *CompetitionRead {
	if e == nil {
		return nil
	}
	var ret CompetitionRead
	ret.ID = e.ID
	ret.Hidden = NewOptBool(e.Hidden)
	ret.Pause = NewOptBool(e.Pause)
	ret.Name = e.Name
	ret.DisplayName = e.DisplayName
	ret.ViewableToPublic = OptBool{}
	if e.ViewableToPublic != nil {
		ret.ViewableToPublic.SetTo(*e.ViewableToPublic)
	}
	ret.ToBeStartedAt = OptDateTime{}
	if e.ToBeStartedAt != nil {
		ret.ToBeStartedAt.SetTo(*e.ToBeStartedAt)
	}
	ret.StartedAt = OptDateTime{}
	if e.StartedAt != nil {
		ret.StartedAt.SetTo(*e.StartedAt)
	}
	ret.FinishedAt = OptDateTime{}
	if e.FinishedAt != nil {
		ret.FinishedAt.SetTo(*e.FinishedAt)
	}
	return &ret
}

func NewCompetitionReads(es []*entities.Competition) []CompetitionRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]CompetitionRead, len(es))
	for i, e := range es {
		r[i] = NewCompetitionRead(e).Elem()
	}
	return r
}

func (c *CompetitionRead) Elem() CompetitionRead {
	if c == nil {
		return CompetitionRead{}
	}
	return *c
}

func NewCompetitionUpdate(e *entities.Competition) *CompetitionUpdate {
	if e == nil {
		return nil
	}
	var ret CompetitionUpdate
	ret.ID = e.ID
	ret.Hidden = NewOptBool(e.Hidden)
	ret.Pause = NewOptBool(e.Pause)
	ret.Name = e.Name
	ret.DisplayName = e.DisplayName
	ret.ViewableToPublic = OptBool{}
	if e.ViewableToPublic != nil {
		ret.ViewableToPublic.SetTo(*e.ViewableToPublic)
	}
	ret.ToBeStartedAt = OptDateTime{}
	if e.ToBeStartedAt != nil {
		ret.ToBeStartedAt.SetTo(*e.ToBeStartedAt)
	}
	ret.StartedAt = OptDateTime{}
	if e.StartedAt != nil {
		ret.StartedAt.SetTo(*e.StartedAt)
	}
	ret.FinishedAt = OptDateTime{}
	if e.FinishedAt != nil {
		ret.FinishedAt.SetTo(*e.FinishedAt)
	}
	return &ret
}

func NewCompetitionUpdates(es []*entities.Competition) []CompetitionUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]CompetitionUpdate, len(es))
	for i, e := range es {
		r[i] = NewCompetitionUpdate(e).Elem()
	}
	return r
}

func (c *CompetitionUpdate) Elem() CompetitionUpdate {
	if c == nil {
		return CompetitionUpdate{}
	}
	return *c
}

func NewCompetitionTeamsList(e *entities.Team) *CompetitionTeamsList {
	if e == nil {
		return nil
	}
	var ret CompetitionTeamsList
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.Name = e.Name
	ret.Index = NewOptInt(e.Index)
	return &ret
}

func NewCompetitionTeamsLists(es []*entities.Team) []CompetitionTeamsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]CompetitionTeamsList, len(es))
	for i, e := range es {
		r[i] = NewCompetitionTeamsList(e).Elem()
	}
	return r
}

func (t *CompetitionTeamsList) Elem() CompetitionTeamsList {
	if t == nil {
		return CompetitionTeamsList{}
	}
	return *t
}

func NewCompetitionUsersList(e *entities.User) *CompetitionUsersList {
	if e == nil {
		return nil
	}
	var ret CompetitionUsersList
	ret.ID = e.ID
	ret.CreateTime = NewOptDateTime(e.CreateTime)
	ret.UpdateTime = NewOptDateTime(e.UpdateTime)
	ret.Username = e.Username
	ret.OryID = e.OryID
	return &ret
}

func NewCompetitionUsersLists(es []*entities.User) []CompetitionUsersList {
	if len(es) == 0 {
		return nil
	}
	r := make([]CompetitionUsersList, len(es))
	for i, e := range es {
		r[i] = NewCompetitionUsersList(e).Elem()
	}
	return r
}

func (u *CompetitionUsersList) Elem() CompetitionUsersList {
	if u == nil {
		return CompetitionUsersList{}
	}
	return *u
}

func NewHostCreate(e *entities.Host) *HostCreate {
	if e == nil {
		return nil
	}
	var ret HostCreate
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.TeamID = e.TeamID
	ret.Address = e.Address
	ret.AddressListRange = e.AddressListRange
	ret.Editable = e.Editable
	return &ret
}

func NewHostCreates(es []*entities.Host) []HostCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]HostCreate, len(es))
	for i, e := range es {
		r[i] = NewHostCreate(e).Elem()
	}
	return r
}

func (h *HostCreate) Elem() HostCreate {
	if h == nil {
		return HostCreate{}
	}
	return *h
}

func NewHostGroupCreate(e *entities.HostGroup) *HostGroupCreate {
	if e == nil {
		return nil
	}
	var ret HostGroupCreate
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.TeamID = e.TeamID
	ret.Name = e.Name
	return &ret
}

func NewHostGroupCreates(es []*entities.HostGroup) []HostGroupCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]HostGroupCreate, len(es))
	for i, e := range es {
		r[i] = NewHostGroupCreate(e).Elem()
	}
	return r
}

func (hg *HostGroupCreate) Elem() HostGroupCreate {
	if hg == nil {
		return HostGroupCreate{}
	}
	return *hg
}

func NewHostGroupList(e *entities.HostGroup) *HostGroupList {
	if e == nil {
		return nil
	}
	var ret HostGroupList
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.TeamID = e.TeamID
	ret.Name = e.Name
	return &ret
}

func NewHostGroupLists(es []*entities.HostGroup) []HostGroupList {
	if len(es) == 0 {
		return nil
	}
	r := make([]HostGroupList, len(es))
	for i, e := range es {
		r[i] = NewHostGroupList(e).Elem()
	}
	return r
}

func (hg *HostGroupList) Elem() HostGroupList {
	if hg == nil {
		return HostGroupList{}
	}
	return *hg
}

func NewHostGroupRead(e *entities.HostGroup) *HostGroupRead {
	if e == nil {
		return nil
	}
	var ret HostGroupRead
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.TeamID = e.TeamID
	ret.Name = e.Name
	return &ret
}

func NewHostGroupReads(es []*entities.HostGroup) []HostGroupRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]HostGroupRead, len(es))
	for i, e := range es {
		r[i] = NewHostGroupRead(e).Elem()
	}
	return r
}

func (hg *HostGroupRead) Elem() HostGroupRead {
	if hg == nil {
		return HostGroupRead{}
	}
	return *hg
}

func NewHostGroupUpdate(e *entities.HostGroup) *HostGroupUpdate {
	if e == nil {
		return nil
	}
	var ret HostGroupUpdate
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.TeamID = e.TeamID
	ret.Name = e.Name
	return &ret
}

func NewHostGroupUpdates(es []*entities.HostGroup) []HostGroupUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]HostGroupUpdate, len(es))
	for i, e := range es {
		r[i] = NewHostGroupUpdate(e).Elem()
	}
	return r
}

func (hg *HostGroupUpdate) Elem() HostGroupUpdate {
	if hg == nil {
		return HostGroupUpdate{}
	}
	return *hg
}

func NewHostGroupCompetitionRead(e *entities.Competition) *HostGroupCompetitionRead {
	if e == nil {
		return nil
	}
	var ret HostGroupCompetitionRead
	ret.ID = e.ID
	ret.Hidden = NewOptBool(e.Hidden)
	ret.Pause = NewOptBool(e.Pause)
	ret.Name = e.Name
	ret.DisplayName = e.DisplayName
	ret.ViewableToPublic = OptBool{}
	if e.ViewableToPublic != nil {
		ret.ViewableToPublic.SetTo(*e.ViewableToPublic)
	}
	ret.ToBeStartedAt = OptDateTime{}
	if e.ToBeStartedAt != nil {
		ret.ToBeStartedAt.SetTo(*e.ToBeStartedAt)
	}
	ret.StartedAt = OptDateTime{}
	if e.StartedAt != nil {
		ret.StartedAt.SetTo(*e.StartedAt)
	}
	ret.FinishedAt = OptDateTime{}
	if e.FinishedAt != nil {
		ret.FinishedAt.SetTo(*e.FinishedAt)
	}
	return &ret
}

func NewHostGroupCompetitionReads(es []*entities.Competition) []HostGroupCompetitionRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]HostGroupCompetitionRead, len(es))
	for i, e := range es {
		r[i] = NewHostGroupCompetitionRead(e).Elem()
	}
	return r
}

func (c *HostGroupCompetitionRead) Elem() HostGroupCompetitionRead {
	if c == nil {
		return HostGroupCompetitionRead{}
	}
	return *c
}

func NewHostGroupHostsList(e *entities.Host) *HostGroupHostsList {
	if e == nil {
		return nil
	}
	var ret HostGroupHostsList
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.TeamID = e.TeamID
	ret.Address = e.Address
	ret.AddressListRange = e.AddressListRange
	ret.Editable = e.Editable
	return &ret
}

func NewHostGroupHostsLists(es []*entities.Host) []HostGroupHostsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]HostGroupHostsList, len(es))
	for i, e := range es {
		r[i] = NewHostGroupHostsList(e).Elem()
	}
	return r
}

func (h *HostGroupHostsList) Elem() HostGroupHostsList {
	if h == nil {
		return HostGroupHostsList{}
	}
	return *h
}

func NewHostGroupTeamRead(e *entities.Team) *HostGroupTeamRead {
	if e == nil {
		return nil
	}
	var ret HostGroupTeamRead
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.Name = e.Name
	ret.Index = NewOptInt(e.Index)
	return &ret
}

func NewHostGroupTeamReads(es []*entities.Team) []HostGroupTeamRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]HostGroupTeamRead, len(es))
	for i, e := range es {
		r[i] = NewHostGroupTeamRead(e).Elem()
	}
	return r
}

func (t *HostGroupTeamRead) Elem() HostGroupTeamRead {
	if t == nil {
		return HostGroupTeamRead{}
	}
	return *t
}

func NewHostList(e *entities.Host) *HostList {
	if e == nil {
		return nil
	}
	var ret HostList
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.TeamID = e.TeamID
	ret.Address = e.Address
	ret.AddressListRange = e.AddressListRange
	ret.Editable = e.Editable
	return &ret
}

func NewHostLists(es []*entities.Host) []HostList {
	if len(es) == 0 {
		return nil
	}
	r := make([]HostList, len(es))
	for i, e := range es {
		r[i] = NewHostList(e).Elem()
	}
	return r
}

func (h *HostList) Elem() HostList {
	if h == nil {
		return HostList{}
	}
	return *h
}

func NewHostRead(e *entities.Host) *HostRead {
	if e == nil {
		return nil
	}
	var ret HostRead
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.TeamID = e.TeamID
	ret.Address = e.Address
	ret.AddressListRange = e.AddressListRange
	ret.Editable = e.Editable
	return &ret
}

func NewHostReads(es []*entities.Host) []HostRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]HostRead, len(es))
	for i, e := range es {
		r[i] = NewHostRead(e).Elem()
	}
	return r
}

func (h *HostRead) Elem() HostRead {
	if h == nil {
		return HostRead{}
	}
	return *h
}

func NewHostUpdate(e *entities.Host) *HostUpdate {
	if e == nil {
		return nil
	}
	var ret HostUpdate
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.TeamID = e.TeamID
	ret.Address = e.Address
	ret.AddressListRange = e.AddressListRange
	ret.Editable = e.Editable
	return &ret
}

func NewHostUpdates(es []*entities.Host) []HostUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]HostUpdate, len(es))
	for i, e := range es {
		r[i] = NewHostUpdate(e).Elem()
	}
	return r
}

func (h *HostUpdate) Elem() HostUpdate {
	if h == nil {
		return HostUpdate{}
	}
	return *h
}

func NewHostCompetitionRead(e *entities.Competition) *HostCompetitionRead {
	if e == nil {
		return nil
	}
	var ret HostCompetitionRead
	ret.ID = e.ID
	ret.Hidden = NewOptBool(e.Hidden)
	ret.Pause = NewOptBool(e.Pause)
	ret.Name = e.Name
	ret.DisplayName = e.DisplayName
	ret.ViewableToPublic = OptBool{}
	if e.ViewableToPublic != nil {
		ret.ViewableToPublic.SetTo(*e.ViewableToPublic)
	}
	ret.ToBeStartedAt = OptDateTime{}
	if e.ToBeStartedAt != nil {
		ret.ToBeStartedAt.SetTo(*e.ToBeStartedAt)
	}
	ret.StartedAt = OptDateTime{}
	if e.StartedAt != nil {
		ret.StartedAt.SetTo(*e.StartedAt)
	}
	ret.FinishedAt = OptDateTime{}
	if e.FinishedAt != nil {
		ret.FinishedAt.SetTo(*e.FinishedAt)
	}
	return &ret
}

func NewHostCompetitionReads(es []*entities.Competition) []HostCompetitionRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]HostCompetitionRead, len(es))
	for i, e := range es {
		r[i] = NewHostCompetitionRead(e).Elem()
	}
	return r
}

func (c *HostCompetitionRead) Elem() HostCompetitionRead {
	if c == nil {
		return HostCompetitionRead{}
	}
	return *c
}

func NewHostHostGroupRead(e *entities.HostGroup) *HostHostGroupRead {
	if e == nil {
		return nil
	}
	var ret HostHostGroupRead
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.TeamID = e.TeamID
	ret.Name = e.Name
	return &ret
}

func NewHostHostGroupReads(es []*entities.HostGroup) []HostHostGroupRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]HostHostGroupRead, len(es))
	for i, e := range es {
		r[i] = NewHostHostGroupRead(e).Elem()
	}
	return r
}

func (hg *HostHostGroupRead) Elem() HostHostGroupRead {
	if hg == nil {
		return HostHostGroupRead{}
	}
	return *hg
}

func NewHostServicesList(e *entities.Service) *HostServicesList {
	if e == nil {
		return nil
	}
	var ret HostServicesList
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.TeamID = e.TeamID
	ret.Name = e.Name
	ret.DisplayName = e.DisplayName
	ret.Weight = e.Weight
	ret.PointBoost = e.PointBoost
	ret.RoundUnits = e.RoundUnits
	ret.RoundDelay = e.RoundDelay
	return &ret
}

func NewHostServicesLists(es []*entities.Service) []HostServicesList {
	if len(es) == 0 {
		return nil
	}
	r := make([]HostServicesList, len(es))
	for i, e := range es {
		r[i] = NewHostServicesList(e).Elem()
	}
	return r
}

func (s *HostServicesList) Elem() HostServicesList {
	if s == nil {
		return HostServicesList{}
	}
	return *s
}

func NewHostTeamRead(e *entities.Team) *HostTeamRead {
	if e == nil {
		return nil
	}
	var ret HostTeamRead
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.Name = e.Name
	ret.Index = NewOptInt(e.Index)
	return &ret
}

func NewHostTeamReads(es []*entities.Team) []HostTeamRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]HostTeamRead, len(es))
	for i, e := range es {
		r[i] = NewHostTeamRead(e).Elem()
	}
	return r
}

func (t *HostTeamRead) Elem() HostTeamRead {
	if t == nil {
		return HostTeamRead{}
	}
	return *t
}

func NewPropertyCreate(e *entities.Property) *PropertyCreate {
	if e == nil {
		return nil
	}
	var ret PropertyCreate
	ret.ID = e.ID
	ret.CompetitionID = e.CompetitionID
	ret.TeamID = e.TeamID
	ret.Key = e.Key
	ret.Value = e.Value
	ret.Status = PropertyCreateStatus(e.Status)
	return &ret
}

func NewPropertyCreates(es []*entities.Property) []PropertyCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]PropertyCreate, len(es))
	for i, e := range es {
		r[i] = NewPropertyCreate(e).Elem()
	}
	return r
}

func (pr *PropertyCreate) Elem() PropertyCreate {
	if pr == nil {
		return PropertyCreate{}
	}
	return *pr
}

func NewPropertyList(e *entities.Property) *PropertyList {
	if e == nil {
		return nil
	}
	var ret PropertyList
	ret.ID = e.ID
	ret.CompetitionID = e.CompetitionID
	ret.TeamID = e.TeamID
	ret.Key = e.Key
	ret.Value = e.Value
	ret.Status = PropertyListStatus(e.Status)
	return &ret
}

func NewPropertyLists(es []*entities.Property) []PropertyList {
	if len(es) == 0 {
		return nil
	}
	r := make([]PropertyList, len(es))
	for i, e := range es {
		r[i] = NewPropertyList(e).Elem()
	}
	return r
}

func (pr *PropertyList) Elem() PropertyList {
	if pr == nil {
		return PropertyList{}
	}
	return *pr
}

func NewPropertyRead(e *entities.Property) *PropertyRead {
	if e == nil {
		return nil
	}
	var ret PropertyRead
	ret.ID = e.ID
	ret.CompetitionID = e.CompetitionID
	ret.TeamID = e.TeamID
	ret.Key = e.Key
	ret.Value = e.Value
	ret.Status = PropertyReadStatus(e.Status)
	return &ret
}

func NewPropertyReads(es []*entities.Property) []PropertyRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]PropertyRead, len(es))
	for i, e := range es {
		r[i] = NewPropertyRead(e).Elem()
	}
	return r
}

func (pr *PropertyRead) Elem() PropertyRead {
	if pr == nil {
		return PropertyRead{}
	}
	return *pr
}

func NewPropertyUpdate(e *entities.Property) *PropertyUpdate {
	if e == nil {
		return nil
	}
	var ret PropertyUpdate
	ret.ID = e.ID
	ret.CompetitionID = e.CompetitionID
	ret.TeamID = e.TeamID
	ret.Key = e.Key
	ret.Value = e.Value
	ret.Status = PropertyUpdateStatus(e.Status)
	return &ret
}

func NewPropertyUpdates(es []*entities.Property) []PropertyUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]PropertyUpdate, len(es))
	for i, e := range es {
		r[i] = NewPropertyUpdate(e).Elem()
	}
	return r
}

func (pr *PropertyUpdate) Elem() PropertyUpdate {
	if pr == nil {
		return PropertyUpdate{}
	}
	return *pr
}

func NewPropertyCompetitionRead(e *entities.Competition) *PropertyCompetitionRead {
	if e == nil {
		return nil
	}
	var ret PropertyCompetitionRead
	ret.ID = e.ID
	ret.Hidden = NewOptBool(e.Hidden)
	ret.Pause = NewOptBool(e.Pause)
	ret.Name = e.Name
	ret.DisplayName = e.DisplayName
	ret.ViewableToPublic = OptBool{}
	if e.ViewableToPublic != nil {
		ret.ViewableToPublic.SetTo(*e.ViewableToPublic)
	}
	ret.ToBeStartedAt = OptDateTime{}
	if e.ToBeStartedAt != nil {
		ret.ToBeStartedAt.SetTo(*e.ToBeStartedAt)
	}
	ret.StartedAt = OptDateTime{}
	if e.StartedAt != nil {
		ret.StartedAt.SetTo(*e.StartedAt)
	}
	ret.FinishedAt = OptDateTime{}
	if e.FinishedAt != nil {
		ret.FinishedAt.SetTo(*e.FinishedAt)
	}
	return &ret
}

func NewPropertyCompetitionReads(es []*entities.Competition) []PropertyCompetitionRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]PropertyCompetitionRead, len(es))
	for i, e := range es {
		r[i] = NewPropertyCompetitionRead(e).Elem()
	}
	return r
}

func (c *PropertyCompetitionRead) Elem() PropertyCompetitionRead {
	if c == nil {
		return PropertyCompetitionRead{}
	}
	return *c
}

func NewPropertyServicesRead(e *entities.Service) *PropertyServicesRead {
	if e == nil {
		return nil
	}
	var ret PropertyServicesRead
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.TeamID = e.TeamID
	ret.Name = e.Name
	ret.DisplayName = e.DisplayName
	ret.Weight = e.Weight
	ret.PointBoost = e.PointBoost
	ret.RoundUnits = e.RoundUnits
	ret.RoundDelay = e.RoundDelay
	return &ret
}

func NewPropertyServicesReads(es []*entities.Service) []PropertyServicesRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]PropertyServicesRead, len(es))
	for i, e := range es {
		r[i] = NewPropertyServicesRead(e).Elem()
	}
	return r
}

func (s *PropertyServicesRead) Elem() PropertyServicesRead {
	if s == nil {
		return PropertyServicesRead{}
	}
	return *s
}

func NewPropertyTeamRead(e *entities.Team) *PropertyTeamRead {
	if e == nil {
		return nil
	}
	var ret PropertyTeamRead
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.Name = e.Name
	ret.Index = NewOptInt(e.Index)
	return &ret
}

func NewPropertyTeamReads(es []*entities.Team) []PropertyTeamRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]PropertyTeamRead, len(es))
	for i, e := range es {
		r[i] = NewPropertyTeamRead(e).Elem()
	}
	return r
}

func (t *PropertyTeamRead) Elem() PropertyTeamRead {
	if t == nil {
		return PropertyTeamRead{}
	}
	return *t
}

func NewReportCreate(e *entities.Report) *ReportCreate {
	if e == nil {
		return nil
	}
	var ret ReportCreate
	ret.ID = e.ID
	ret.Log = e.Log
	ret.Error = e.Error
	return &ret
}

func NewReportCreates(es []*entities.Report) []ReportCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]ReportCreate, len(es))
	for i, e := range es {
		r[i] = NewReportCreate(e).Elem()
	}
	return r
}

func (r *ReportCreate) Elem() ReportCreate {
	if r == nil {
		return ReportCreate{}
	}
	return *r
}

func NewReportList(e *entities.Report) *ReportList {
	if e == nil {
		return nil
	}
	var ret ReportList
	ret.ID = e.ID
	ret.Log = e.Log
	ret.Error = e.Error
	return &ret
}

func NewReportLists(es []*entities.Report) []ReportList {
	if len(es) == 0 {
		return nil
	}
	r := make([]ReportList, len(es))
	for i, e := range es {
		r[i] = NewReportList(e).Elem()
	}
	return r
}

func (r *ReportList) Elem() ReportList {
	if r == nil {
		return ReportList{}
	}
	return *r
}

func NewReportRead(e *entities.Report) *ReportRead {
	if e == nil {
		return nil
	}
	var ret ReportRead
	ret.ID = e.ID
	ret.Log = e.Log
	ret.Error = e.Error
	return &ret
}

func NewReportReads(es []*entities.Report) []ReportRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]ReportRead, len(es))
	for i, e := range es {
		r[i] = NewReportRead(e).Elem()
	}
	return r
}

func (r *ReportRead) Elem() ReportRead {
	if r == nil {
		return ReportRead{}
	}
	return *r
}

func NewReportUpdate(e *entities.Report) *ReportUpdate {
	if e == nil {
		return nil
	}
	var ret ReportUpdate
	ret.ID = e.ID
	ret.Log = e.Log
	ret.Error = e.Error
	return &ret
}

func NewReportUpdates(es []*entities.Report) []ReportUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]ReportUpdate, len(es))
	for i, e := range es {
		r[i] = NewReportUpdate(e).Elem()
	}
	return r
}

func (r *ReportUpdate) Elem() ReportUpdate {
	if r == nil {
		return ReportUpdate{}
	}
	return *r
}

func NewRoundCreate(e *entities.Round) *RoundCreate {
	if e == nil {
		return nil
	}
	var ret RoundCreate
	ret.ID = e.ID
	ret.CompetitionID = e.CompetitionID
	ret.RoundNumber = e.RoundNumber
	ret.Note = e.Note
	ret.Err = e.Err
	ret.StartedAt = e.StartedAt
	ret.FinishedAt = e.FinishedAt
	return &ret
}

func NewRoundCreates(es []*entities.Round) []RoundCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]RoundCreate, len(es))
	for i, e := range es {
		r[i] = NewRoundCreate(e).Elem()
	}
	return r
}

func (r *RoundCreate) Elem() RoundCreate {
	if r == nil {
		return RoundCreate{}
	}
	return *r
}

func NewRoundList(e *entities.Round) *RoundList {
	if e == nil {
		return nil
	}
	var ret RoundList
	ret.ID = e.ID
	ret.CompetitionID = e.CompetitionID
	ret.RoundNumber = e.RoundNumber
	ret.Note = e.Note
	ret.Err = e.Err
	ret.StartedAt = e.StartedAt
	ret.FinishedAt = e.FinishedAt
	return &ret
}

func NewRoundLists(es []*entities.Round) []RoundList {
	if len(es) == 0 {
		return nil
	}
	r := make([]RoundList, len(es))
	for i, e := range es {
		r[i] = NewRoundList(e).Elem()
	}
	return r
}

func (r *RoundList) Elem() RoundList {
	if r == nil {
		return RoundList{}
	}
	return *r
}

func NewRoundRead(e *entities.Round) *RoundRead {
	if e == nil {
		return nil
	}
	var ret RoundRead
	ret.ID = e.ID
	ret.CompetitionID = e.CompetitionID
	ret.RoundNumber = e.RoundNumber
	ret.Note = e.Note
	ret.Err = e.Err
	ret.StartedAt = e.StartedAt
	ret.FinishedAt = e.FinishedAt
	return &ret
}

func NewRoundReads(es []*entities.Round) []RoundRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]RoundRead, len(es))
	for i, e := range es {
		r[i] = NewRoundRead(e).Elem()
	}
	return r
}

func (r *RoundRead) Elem() RoundRead {
	if r == nil {
		return RoundRead{}
	}
	return *r
}

func NewRoundUpdate(e *entities.Round) *RoundUpdate {
	if e == nil {
		return nil
	}
	var ret RoundUpdate
	ret.ID = e.ID
	ret.CompetitionID = e.CompetitionID
	ret.RoundNumber = e.RoundNumber
	ret.Note = e.Note
	ret.Err = e.Err
	ret.StartedAt = e.StartedAt
	ret.FinishedAt = e.FinishedAt
	return &ret
}

func NewRoundUpdates(es []*entities.Round) []RoundUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]RoundUpdate, len(es))
	for i, e := range es {
		r[i] = NewRoundUpdate(e).Elem()
	}
	return r
}

func (r *RoundUpdate) Elem() RoundUpdate {
	if r == nil {
		return RoundUpdate{}
	}
	return *r
}

func NewRoundChecksList(e *entities.Check) *RoundChecksList {
	if e == nil {
		return nil
	}
	var ret RoundChecksList
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.Log = e.Log
	ret.Error = e.Error
	ret.Passed = e.Passed
	return &ret
}

func NewRoundChecksLists(es []*entities.Check) []RoundChecksList {
	if len(es) == 0 {
		return nil
	}
	r := make([]RoundChecksList, len(es))
	for i, e := range es {
		r[i] = NewRoundChecksList(e).Elem()
	}
	return r
}

func (c *RoundChecksList) Elem() RoundChecksList {
	if c == nil {
		return RoundChecksList{}
	}
	return *c
}

func NewRoundCompetitionRead(e *entities.Competition) *RoundCompetitionRead {
	if e == nil {
		return nil
	}
	var ret RoundCompetitionRead
	ret.ID = e.ID
	ret.Hidden = NewOptBool(e.Hidden)
	ret.Pause = NewOptBool(e.Pause)
	ret.Name = e.Name
	ret.DisplayName = e.DisplayName
	ret.ViewableToPublic = OptBool{}
	if e.ViewableToPublic != nil {
		ret.ViewableToPublic.SetTo(*e.ViewableToPublic)
	}
	ret.ToBeStartedAt = OptDateTime{}
	if e.ToBeStartedAt != nil {
		ret.ToBeStartedAt.SetTo(*e.ToBeStartedAt)
	}
	ret.StartedAt = OptDateTime{}
	if e.StartedAt != nil {
		ret.StartedAt.SetTo(*e.StartedAt)
	}
	ret.FinishedAt = OptDateTime{}
	if e.FinishedAt != nil {
		ret.FinishedAt.SetTo(*e.FinishedAt)
	}
	return &ret
}

func NewRoundCompetitionReads(es []*entities.Competition) []RoundCompetitionRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]RoundCompetitionRead, len(es))
	for i, e := range es {
		r[i] = NewRoundCompetitionRead(e).Elem()
	}
	return r
}

func (c *RoundCompetitionRead) Elem() RoundCompetitionRead {
	if c == nil {
		return RoundCompetitionRead{}
	}
	return *c
}

func NewServiceCreate(e *entities.Service) *ServiceCreate {
	if e == nil {
		return nil
	}
	var ret ServiceCreate
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.TeamID = e.TeamID
	ret.Name = e.Name
	ret.DisplayName = e.DisplayName
	ret.Weight = e.Weight
	ret.PointBoost = e.PointBoost
	ret.RoundUnits = e.RoundUnits
	ret.RoundDelay = e.RoundDelay
	return &ret
}

func NewServiceCreates(es []*entities.Service) []ServiceCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]ServiceCreate, len(es))
	for i, e := range es {
		r[i] = NewServiceCreate(e).Elem()
	}
	return r
}

func (s *ServiceCreate) Elem() ServiceCreate {
	if s == nil {
		return ServiceCreate{}
	}
	return *s
}

func NewServiceList(e *entities.Service) *ServiceList {
	if e == nil {
		return nil
	}
	var ret ServiceList
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.TeamID = e.TeamID
	ret.Name = e.Name
	ret.DisplayName = e.DisplayName
	ret.Weight = e.Weight
	ret.PointBoost = e.PointBoost
	ret.RoundUnits = e.RoundUnits
	ret.RoundDelay = e.RoundDelay
	return &ret
}

func NewServiceLists(es []*entities.Service) []ServiceList {
	if len(es) == 0 {
		return nil
	}
	r := make([]ServiceList, len(es))
	for i, e := range es {
		r[i] = NewServiceList(e).Elem()
	}
	return r
}

func (s *ServiceList) Elem() ServiceList {
	if s == nil {
		return ServiceList{}
	}
	return *s
}

func NewServiceRead(e *entities.Service) *ServiceRead {
	if e == nil {
		return nil
	}
	var ret ServiceRead
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.TeamID = e.TeamID
	ret.Name = e.Name
	ret.DisplayName = e.DisplayName
	ret.Weight = e.Weight
	ret.PointBoost = e.PointBoost
	ret.RoundUnits = e.RoundUnits
	ret.RoundDelay = e.RoundDelay
	return &ret
}

func NewServiceReads(es []*entities.Service) []ServiceRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]ServiceRead, len(es))
	for i, e := range es {
		r[i] = NewServiceRead(e).Elem()
	}
	return r
}

func (s *ServiceRead) Elem() ServiceRead {
	if s == nil {
		return ServiceRead{}
	}
	return *s
}

func NewServiceUpdate(e *entities.Service) *ServiceUpdate {
	if e == nil {
		return nil
	}
	var ret ServiceUpdate
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.TeamID = e.TeamID
	ret.Name = e.Name
	ret.DisplayName = e.DisplayName
	ret.Weight = e.Weight
	ret.PointBoost = e.PointBoost
	ret.RoundUnits = e.RoundUnits
	ret.RoundDelay = e.RoundDelay
	return &ret
}

func NewServiceUpdates(es []*entities.Service) []ServiceUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]ServiceUpdate, len(es))
	for i, e := range es {
		r[i] = NewServiceUpdate(e).Elem()
	}
	return r
}

func (s *ServiceUpdate) Elem() ServiceUpdate {
	if s == nil {
		return ServiceUpdate{}
	}
	return *s
}

func NewServiceChecksList(e *entities.Check) *ServiceChecksList {
	if e == nil {
		return nil
	}
	var ret ServiceChecksList
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.Log = e.Log
	ret.Error = e.Error
	ret.Passed = e.Passed
	return &ret
}

func NewServiceChecksLists(es []*entities.Check) []ServiceChecksList {
	if len(es) == 0 {
		return nil
	}
	r := make([]ServiceChecksList, len(es))
	for i, e := range es {
		r[i] = NewServiceChecksList(e).Elem()
	}
	return r
}

func (c *ServiceChecksList) Elem() ServiceChecksList {
	if c == nil {
		return ServiceChecksList{}
	}
	return *c
}

func NewServiceCompetitionRead(e *entities.Competition) *ServiceCompetitionRead {
	if e == nil {
		return nil
	}
	var ret ServiceCompetitionRead
	ret.ID = e.ID
	ret.Hidden = NewOptBool(e.Hidden)
	ret.Pause = NewOptBool(e.Pause)
	ret.Name = e.Name
	ret.DisplayName = e.DisplayName
	ret.ViewableToPublic = OptBool{}
	if e.ViewableToPublic != nil {
		ret.ViewableToPublic.SetTo(*e.ViewableToPublic)
	}
	ret.ToBeStartedAt = OptDateTime{}
	if e.ToBeStartedAt != nil {
		ret.ToBeStartedAt.SetTo(*e.ToBeStartedAt)
	}
	ret.StartedAt = OptDateTime{}
	if e.StartedAt != nil {
		ret.StartedAt.SetTo(*e.StartedAt)
	}
	ret.FinishedAt = OptDateTime{}
	if e.FinishedAt != nil {
		ret.FinishedAt.SetTo(*e.FinishedAt)
	}
	return &ret
}

func NewServiceCompetitionReads(es []*entities.Competition) []ServiceCompetitionRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]ServiceCompetitionRead, len(es))
	for i, e := range es {
		r[i] = NewServiceCompetitionRead(e).Elem()
	}
	return r
}

func (c *ServiceCompetitionRead) Elem() ServiceCompetitionRead {
	if c == nil {
		return ServiceCompetitionRead{}
	}
	return *c
}

func NewServiceHostsRead(e *entities.Host) *ServiceHostsRead {
	if e == nil {
		return nil
	}
	var ret ServiceHostsRead
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.TeamID = e.TeamID
	ret.Address = e.Address
	ret.AddressListRange = e.AddressListRange
	ret.Editable = e.Editable
	return &ret
}

func NewServiceHostsReads(es []*entities.Host) []ServiceHostsRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]ServiceHostsRead, len(es))
	for i, e := range es {
		r[i] = NewServiceHostsRead(e).Elem()
	}
	return r
}

func (h *ServiceHostsRead) Elem() ServiceHostsRead {
	if h == nil {
		return ServiceHostsRead{}
	}
	return *h
}

func NewServicePropertiesList(e *entities.Property) *ServicePropertiesList {
	if e == nil {
		return nil
	}
	var ret ServicePropertiesList
	ret.ID = e.ID
	ret.CompetitionID = e.CompetitionID
	ret.TeamID = e.TeamID
	ret.Key = e.Key
	ret.Value = e.Value
	ret.Status = ServicePropertiesListStatus(e.Status)
	return &ret
}

func NewServicePropertiesLists(es []*entities.Property) []ServicePropertiesList {
	if len(es) == 0 {
		return nil
	}
	r := make([]ServicePropertiesList, len(es))
	for i, e := range es {
		r[i] = NewServicePropertiesList(e).Elem()
	}
	return r
}

func (pr *ServicePropertiesList) Elem() ServicePropertiesList {
	if pr == nil {
		return ServicePropertiesList{}
	}
	return *pr
}

func NewServiceTeamRead(e *entities.Team) *ServiceTeamRead {
	if e == nil {
		return nil
	}
	var ret ServiceTeamRead
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.Name = e.Name
	ret.Index = NewOptInt(e.Index)
	return &ret
}

func NewServiceTeamReads(es []*entities.Team) []ServiceTeamRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]ServiceTeamRead, len(es))
	for i, e := range es {
		r[i] = NewServiceTeamRead(e).Elem()
	}
	return r
}

func (t *ServiceTeamRead) Elem() ServiceTeamRead {
	if t == nil {
		return ServiceTeamRead{}
	}
	return *t
}

func NewTeamCreate(e *entities.Team) *TeamCreate {
	if e == nil {
		return nil
	}
	var ret TeamCreate
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.Name = e.Name
	ret.Index = NewOptInt(e.Index)
	return &ret
}

func NewTeamCreates(es []*entities.Team) []TeamCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]TeamCreate, len(es))
	for i, e := range es {
		r[i] = NewTeamCreate(e).Elem()
	}
	return r
}

func (t *TeamCreate) Elem() TeamCreate {
	if t == nil {
		return TeamCreate{}
	}
	return *t
}

func NewTeamList(e *entities.Team) *TeamList {
	if e == nil {
		return nil
	}
	var ret TeamList
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.Name = e.Name
	ret.Index = NewOptInt(e.Index)
	return &ret
}

func NewTeamLists(es []*entities.Team) []TeamList {
	if len(es) == 0 {
		return nil
	}
	r := make([]TeamList, len(es))
	for i, e := range es {
		r[i] = NewTeamList(e).Elem()
	}
	return r
}

func (t *TeamList) Elem() TeamList {
	if t == nil {
		return TeamList{}
	}
	return *t
}

func NewTeamRead(e *entities.Team) *TeamRead {
	if e == nil {
		return nil
	}
	var ret TeamRead
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.Name = e.Name
	ret.Index = NewOptInt(e.Index)
	return &ret
}

func NewTeamReads(es []*entities.Team) []TeamRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]TeamRead, len(es))
	for i, e := range es {
		r[i] = NewTeamRead(e).Elem()
	}
	return r
}

func (t *TeamRead) Elem() TeamRead {
	if t == nil {
		return TeamRead{}
	}
	return *t
}

func NewTeamUpdate(e *entities.Team) *TeamUpdate {
	if e == nil {
		return nil
	}
	var ret TeamUpdate
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.Name = e.Name
	ret.Index = NewOptInt(e.Index)
	return &ret
}

func NewTeamUpdates(es []*entities.Team) []TeamUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]TeamUpdate, len(es))
	for i, e := range es {
		r[i] = NewTeamUpdate(e).Elem()
	}
	return r
}

func (t *TeamUpdate) Elem() TeamUpdate {
	if t == nil {
		return TeamUpdate{}
	}
	return *t
}

func NewTeamCompetitionRead(e *entities.Competition) *TeamCompetitionRead {
	if e == nil {
		return nil
	}
	var ret TeamCompetitionRead
	ret.ID = e.ID
	ret.Hidden = NewOptBool(e.Hidden)
	ret.Pause = NewOptBool(e.Pause)
	ret.Name = e.Name
	ret.DisplayName = e.DisplayName
	ret.ViewableToPublic = OptBool{}
	if e.ViewableToPublic != nil {
		ret.ViewableToPublic.SetTo(*e.ViewableToPublic)
	}
	ret.ToBeStartedAt = OptDateTime{}
	if e.ToBeStartedAt != nil {
		ret.ToBeStartedAt.SetTo(*e.ToBeStartedAt)
	}
	ret.StartedAt = OptDateTime{}
	if e.StartedAt != nil {
		ret.StartedAt.SetTo(*e.StartedAt)
	}
	ret.FinishedAt = OptDateTime{}
	if e.FinishedAt != nil {
		ret.FinishedAt.SetTo(*e.FinishedAt)
	}
	return &ret
}

func NewTeamCompetitionReads(es []*entities.Competition) []TeamCompetitionRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]TeamCompetitionRead, len(es))
	for i, e := range es {
		r[i] = NewTeamCompetitionRead(e).Elem()
	}
	return r
}

func (c *TeamCompetitionRead) Elem() TeamCompetitionRead {
	if c == nil {
		return TeamCompetitionRead{}
	}
	return *c
}

func NewTeamHostsList(e *entities.Host) *TeamHostsList {
	if e == nil {
		return nil
	}
	var ret TeamHostsList
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.TeamID = e.TeamID
	ret.Address = e.Address
	ret.AddressListRange = e.AddressListRange
	ret.Editable = e.Editable
	return &ret
}

func NewTeamHostsLists(es []*entities.Host) []TeamHostsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]TeamHostsList, len(es))
	for i, e := range es {
		r[i] = NewTeamHostsList(e).Elem()
	}
	return r
}

func (h *TeamHostsList) Elem() TeamHostsList {
	if h == nil {
		return TeamHostsList{}
	}
	return *h
}

func NewTeamUsersList(e *entities.User) *TeamUsersList {
	if e == nil {
		return nil
	}
	var ret TeamUsersList
	ret.ID = e.ID
	ret.CreateTime = NewOptDateTime(e.CreateTime)
	ret.UpdateTime = NewOptDateTime(e.UpdateTime)
	ret.Username = e.Username
	ret.OryID = e.OryID
	return &ret
}

func NewTeamUsersLists(es []*entities.User) []TeamUsersList {
	if len(es) == 0 {
		return nil
	}
	r := make([]TeamUsersList, len(es))
	for i, e := range es {
		r[i] = NewTeamUsersList(e).Elem()
	}
	return r
}

func (u *TeamUsersList) Elem() TeamUsersList {
	if u == nil {
		return TeamUsersList{}
	}
	return *u
}

func NewUserCreate(e *entities.User) *UserCreate {
	if e == nil {
		return nil
	}
	var ret UserCreate
	ret.ID = e.ID
	ret.CreateTime = NewOptDateTime(e.CreateTime)
	ret.UpdateTime = NewOptDateTime(e.UpdateTime)
	ret.Username = e.Username
	ret.OryID = e.OryID
	return &ret
}

func NewUserCreates(es []*entities.User) []UserCreate {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserCreate, len(es))
	for i, e := range es {
		r[i] = NewUserCreate(e).Elem()
	}
	return r
}

func (u *UserCreate) Elem() UserCreate {
	if u == nil {
		return UserCreate{}
	}
	return *u
}

func NewUserList(e *entities.User) *UserList {
	if e == nil {
		return nil
	}
	var ret UserList
	ret.ID = e.ID
	ret.CreateTime = NewOptDateTime(e.CreateTime)
	ret.UpdateTime = NewOptDateTime(e.UpdateTime)
	ret.Username = e.Username
	ret.OryID = e.OryID
	return &ret
}

func NewUserLists(es []*entities.User) []UserList {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserList, len(es))
	for i, e := range es {
		r[i] = NewUserList(e).Elem()
	}
	return r
}

func (u *UserList) Elem() UserList {
	if u == nil {
		return UserList{}
	}
	return *u
}

func NewUserRead(e *entities.User) *UserRead {
	if e == nil {
		return nil
	}
	var ret UserRead
	ret.ID = e.ID
	ret.CreateTime = NewOptDateTime(e.CreateTime)
	ret.UpdateTime = NewOptDateTime(e.UpdateTime)
	ret.Username = e.Username
	ret.OryID = e.OryID
	return &ret
}

func NewUserReads(es []*entities.User) []UserRead {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserRead, len(es))
	for i, e := range es {
		r[i] = NewUserRead(e).Elem()
	}
	return r
}

func (u *UserRead) Elem() UserRead {
	if u == nil {
		return UserRead{}
	}
	return *u
}

func NewUserUpdate(e *entities.User) *UserUpdate {
	if e == nil {
		return nil
	}
	var ret UserUpdate
	ret.ID = e.ID
	ret.CreateTime = NewOptDateTime(e.CreateTime)
	ret.UpdateTime = NewOptDateTime(e.UpdateTime)
	ret.Username = e.Username
	ret.OryID = e.OryID
	return &ret
}

func NewUserUpdates(es []*entities.User) []UserUpdate {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserUpdate, len(es))
	for i, e := range es {
		r[i] = NewUserUpdate(e).Elem()
	}
	return r
}

func (u *UserUpdate) Elem() UserUpdate {
	if u == nil {
		return UserUpdate{}
	}
	return *u
}

func NewUserCompetitionsList(e *entities.Competition) *UserCompetitionsList {
	if e == nil {
		return nil
	}
	var ret UserCompetitionsList
	ret.ID = e.ID
	ret.Hidden = NewOptBool(e.Hidden)
	ret.Pause = NewOptBool(e.Pause)
	ret.Name = e.Name
	ret.DisplayName = e.DisplayName
	ret.ViewableToPublic = OptBool{}
	if e.ViewableToPublic != nil {
		ret.ViewableToPublic.SetTo(*e.ViewableToPublic)
	}
	ret.ToBeStartedAt = OptDateTime{}
	if e.ToBeStartedAt != nil {
		ret.ToBeStartedAt.SetTo(*e.ToBeStartedAt)
	}
	ret.StartedAt = OptDateTime{}
	if e.StartedAt != nil {
		ret.StartedAt.SetTo(*e.StartedAt)
	}
	ret.FinishedAt = OptDateTime{}
	if e.FinishedAt != nil {
		ret.FinishedAt.SetTo(*e.FinishedAt)
	}
	return &ret
}

func NewUserCompetitionsLists(es []*entities.Competition) []UserCompetitionsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserCompetitionsList, len(es))
	for i, e := range es {
		r[i] = NewUserCompetitionsList(e).Elem()
	}
	return r
}

func (c *UserCompetitionsList) Elem() UserCompetitionsList {
	if c == nil {
		return UserCompetitionsList{}
	}
	return *c
}

func NewUserTeamsList(e *entities.Team) *UserTeamsList {
	if e == nil {
		return nil
	}
	var ret UserTeamsList
	ret.ID = e.ID
	ret.Pause = NewOptBool(e.Pause)
	ret.Hidden = NewOptBool(e.Hidden)
	ret.CompetitionID = e.CompetitionID
	ret.Name = e.Name
	ret.Index = NewOptInt(e.Index)
	return &ret
}

func NewUserTeamsLists(es []*entities.Team) []UserTeamsList {
	if len(es) == 0 {
		return nil
	}
	r := make([]UserTeamsList, len(es))
	for i, e := range es {
		r[i] = NewUserTeamsList(e).Elem()
	}
	return r
}

func (t *UserTeamsList) Elem() UserTeamsList {
	if t == nil {
		return UserTeamsList{}
	}
	return *t
}
