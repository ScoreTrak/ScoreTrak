// Code generated by ent, DO NOT EDIT.

package entities

import (
	"github.com/ScoreTrak/ScoreTrak/internal/entities/check"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/competition"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/host"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/hostgroup"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/predicate"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/property"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/report"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/round"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/service"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/team"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/user"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/entql"
	"entgo.io/ent/schema/field"
)

// schemaGraph holds a representation of ent/schema at runtime.
var schemaGraph = func() *sqlgraph.Schema {
	graph := &sqlgraph.Schema{Nodes: make([]*sqlgraph.Node, 10)}
	graph.Nodes[0] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   check.Table,
			Columns: check.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: check.FieldID,
			},
		},
		Type: "Check",
		Fields: map[string]*sqlgraph.FieldSpec{
			check.FieldPause:         {Type: field.TypeBool, Column: check.FieldPause},
			check.FieldHidden:        {Type: field.TypeBool, Column: check.FieldHidden},
			check.FieldCompetitionID: {Type: field.TypeString, Column: check.FieldCompetitionID},
			check.FieldLog:           {Type: field.TypeString, Column: check.FieldLog},
			check.FieldError:         {Type: field.TypeString, Column: check.FieldError},
			check.FieldPassed:        {Type: field.TypeBool, Column: check.FieldPassed},
		},
	}
	graph.Nodes[1] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   competition.Table,
			Columns: competition.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: competition.FieldID,
			},
		},
		Type: "Competition",
		Fields: map[string]*sqlgraph.FieldSpec{
			competition.FieldHidden:           {Type: field.TypeBool, Column: competition.FieldHidden},
			competition.FieldPause:            {Type: field.TypeBool, Column: competition.FieldPause},
			competition.FieldName:             {Type: field.TypeString, Column: competition.FieldName},
			competition.FieldDisplayName:      {Type: field.TypeString, Column: competition.FieldDisplayName},
			competition.FieldViewableToPublic: {Type: field.TypeBool, Column: competition.FieldViewableToPublic},
			competition.FieldToBeStartedAt:    {Type: field.TypeTime, Column: competition.FieldToBeStartedAt},
			competition.FieldStartedAt:        {Type: field.TypeTime, Column: competition.FieldStartedAt},
			competition.FieldFinishedAt:       {Type: field.TypeTime, Column: competition.FieldFinishedAt},
		},
	}
	graph.Nodes[2] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   host.Table,
			Columns: host.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: host.FieldID,
			},
		},
		Type: "Host",
		Fields: map[string]*sqlgraph.FieldSpec{
			host.FieldPause:            {Type: field.TypeBool, Column: host.FieldPause},
			host.FieldHidden:           {Type: field.TypeBool, Column: host.FieldHidden},
			host.FieldCompetitionID:    {Type: field.TypeString, Column: host.FieldCompetitionID},
			host.FieldTeamID:           {Type: field.TypeString, Column: host.FieldTeamID},
			host.FieldAddress:          {Type: field.TypeString, Column: host.FieldAddress},
			host.FieldAddressListRange: {Type: field.TypeString, Column: host.FieldAddressListRange},
			host.FieldEditable:         {Type: field.TypeBool, Column: host.FieldEditable},
		},
	}
	graph.Nodes[3] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   hostgroup.Table,
			Columns: hostgroup.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: hostgroup.FieldID,
			},
		},
		Type: "HostGroup",
		Fields: map[string]*sqlgraph.FieldSpec{
			hostgroup.FieldPause:         {Type: field.TypeBool, Column: hostgroup.FieldPause},
			hostgroup.FieldHidden:        {Type: field.TypeBool, Column: hostgroup.FieldHidden},
			hostgroup.FieldCompetitionID: {Type: field.TypeString, Column: hostgroup.FieldCompetitionID},
			hostgroup.FieldTeamID:        {Type: field.TypeString, Column: hostgroup.FieldTeamID},
			hostgroup.FieldName:          {Type: field.TypeString, Column: hostgroup.FieldName},
		},
	}
	graph.Nodes[4] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   property.Table,
			Columns: property.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: property.FieldID,
			},
		},
		Type: "Property",
		Fields: map[string]*sqlgraph.FieldSpec{
			property.FieldCompetitionID: {Type: field.TypeString, Column: property.FieldCompetitionID},
			property.FieldTeamID:        {Type: field.TypeString, Column: property.FieldTeamID},
			property.FieldKey:           {Type: field.TypeString, Column: property.FieldKey},
			property.FieldValue:         {Type: field.TypeString, Column: property.FieldValue},
			property.FieldStatus:        {Type: field.TypeEnum, Column: property.FieldStatus},
		},
	}
	graph.Nodes[5] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   report.Table,
			Columns: report.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: report.FieldID,
			},
		},
		Type: "Report",
		Fields: map[string]*sqlgraph.FieldSpec{
			report.FieldLog:   {Type: field.TypeString, Column: report.FieldLog},
			report.FieldError: {Type: field.TypeString, Column: report.FieldError},
		},
	}
	graph.Nodes[6] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   round.Table,
			Columns: round.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: round.FieldID,
			},
		},
		Type: "Round",
		Fields: map[string]*sqlgraph.FieldSpec{
			round.FieldCompetitionID: {Type: field.TypeString, Column: round.FieldCompetitionID},
			round.FieldRoundNumber:   {Type: field.TypeInt, Column: round.FieldRoundNumber},
			round.FieldNote:          {Type: field.TypeString, Column: round.FieldNote},
			round.FieldErr:           {Type: field.TypeString, Column: round.FieldErr},
			round.FieldStartedAt:     {Type: field.TypeTime, Column: round.FieldStartedAt},
			round.FieldFinishedAt:    {Type: field.TypeTime, Column: round.FieldFinishedAt},
		},
	}
	graph.Nodes[7] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   service.Table,
			Columns: service.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: service.FieldID,
			},
		},
		Type: "Service",
		Fields: map[string]*sqlgraph.FieldSpec{
			service.FieldPause:         {Type: field.TypeBool, Column: service.FieldPause},
			service.FieldHidden:        {Type: field.TypeBool, Column: service.FieldHidden},
			service.FieldCompetitionID: {Type: field.TypeString, Column: service.FieldCompetitionID},
			service.FieldTeamID:        {Type: field.TypeString, Column: service.FieldTeamID},
			service.FieldName:          {Type: field.TypeString, Column: service.FieldName},
			service.FieldDisplayName:   {Type: field.TypeString, Column: service.FieldDisplayName},
			service.FieldWeight:        {Type: field.TypeInt, Column: service.FieldWeight},
			service.FieldPointBoost:    {Type: field.TypeInt, Column: service.FieldPointBoost},
			service.FieldRoundUnits:    {Type: field.TypeInt, Column: service.FieldRoundUnits},
			service.FieldRoundDelay:    {Type: field.TypeInt, Column: service.FieldRoundDelay},
		},
	}
	graph.Nodes[8] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   team.Table,
			Columns: team.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: team.FieldID,
			},
		},
		Type: "Team",
		Fields: map[string]*sqlgraph.FieldSpec{
			team.FieldPause:         {Type: field.TypeBool, Column: team.FieldPause},
			team.FieldHidden:        {Type: field.TypeBool, Column: team.FieldHidden},
			team.FieldCompetitionID: {Type: field.TypeString, Column: team.FieldCompetitionID},
			team.FieldName:          {Type: field.TypeString, Column: team.FieldName},
			team.FieldIndex:         {Type: field.TypeInt, Column: team.FieldIndex},
		},
	}
	graph.Nodes[9] = &sqlgraph.Node{
		NodeSpec: sqlgraph.NodeSpec{
			Table:   user.Table,
			Columns: user.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeString,
				Column: user.FieldID,
			},
		},
		Type: "User",
		Fields: map[string]*sqlgraph.FieldSpec{
			user.FieldCreateTime: {Type: field.TypeTime, Column: user.FieldCreateTime},
			user.FieldUpdateTime: {Type: field.TypeTime, Column: user.FieldUpdateTime},
			user.FieldUsername:   {Type: field.TypeString, Column: user.FieldUsername},
			user.FieldOryID:      {Type: field.TypeUUID, Column: user.FieldOryID},
		},
	}
	graph.MustAddE(
		"competition",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   check.CompetitionTable,
			Columns: []string{check.CompetitionColumn},
			Bidi:    false,
		},
		"Check",
		"Competition",
	)
	graph.MustAddE(
		"rounds",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   check.RoundsTable,
			Columns: []string{check.RoundsColumn},
			Bidi:    false,
		},
		"Check",
		"Round",
	)
	graph.MustAddE(
		"services",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   check.ServicesTable,
			Columns: []string{check.ServicesColumn},
			Bidi:    false,
		},
		"Check",
		"Service",
	)
	graph.MustAddE(
		"teams",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   competition.TeamsTable,
			Columns: []string{competition.TeamsColumn},
			Bidi:    false,
		},
		"Competition",
		"Team",
	)
	graph.MustAddE(
		"users",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   competition.UsersTable,
			Columns: competition.UsersPrimaryKey,
			Bidi:    false,
		},
		"Competition",
		"User",
	)
	graph.MustAddE(
		"competition",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   host.CompetitionTable,
			Columns: []string{host.CompetitionColumn},
			Bidi:    false,
		},
		"Host",
		"Competition",
	)
	graph.MustAddE(
		"team",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   host.TeamTable,
			Columns: []string{host.TeamColumn},
			Bidi:    false,
		},
		"Host",
		"Team",
	)
	graph.MustAddE(
		"services",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   host.ServicesTable,
			Columns: []string{host.ServicesColumn},
			Bidi:    false,
		},
		"Host",
		"Service",
	)
	graph.MustAddE(
		"host_group",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   host.HostGroupTable,
			Columns: []string{host.HostGroupColumn},
			Bidi:    false,
		},
		"Host",
		"HostGroup",
	)
	graph.MustAddE(
		"competition",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   hostgroup.CompetitionTable,
			Columns: []string{hostgroup.CompetitionColumn},
			Bidi:    false,
		},
		"HostGroup",
		"Competition",
	)
	graph.MustAddE(
		"team",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   hostgroup.TeamTable,
			Columns: []string{hostgroup.TeamColumn},
			Bidi:    false,
		},
		"HostGroup",
		"Team",
	)
	graph.MustAddE(
		"hosts",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   hostgroup.HostsTable,
			Columns: []string{hostgroup.HostsColumn},
			Bidi:    false,
		},
		"HostGroup",
		"Host",
	)
	graph.MustAddE(
		"competition",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   property.CompetitionTable,
			Columns: []string{property.CompetitionColumn},
			Bidi:    false,
		},
		"Property",
		"Competition",
	)
	graph.MustAddE(
		"team",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   property.TeamTable,
			Columns: []string{property.TeamColumn},
			Bidi:    false,
		},
		"Property",
		"Team",
	)
	graph.MustAddE(
		"services",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   property.ServicesTable,
			Columns: []string{property.ServicesColumn},
			Bidi:    false,
		},
		"Property",
		"Service",
	)
	graph.MustAddE(
		"competition",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   round.CompetitionTable,
			Columns: []string{round.CompetitionColumn},
			Bidi:    false,
		},
		"Round",
		"Competition",
	)
	graph.MustAddE(
		"checks",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   round.ChecksTable,
			Columns: []string{round.ChecksColumn},
			Bidi:    false,
		},
		"Round",
		"Check",
	)
	graph.MustAddE(
		"competition",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   service.CompetitionTable,
			Columns: []string{service.CompetitionColumn},
			Bidi:    false,
		},
		"Service",
		"Competition",
	)
	graph.MustAddE(
		"team",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   service.TeamTable,
			Columns: []string{service.TeamColumn},
			Bidi:    false,
		},
		"Service",
		"Team",
	)
	graph.MustAddE(
		"hosts",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   service.HostsTable,
			Columns: []string{service.HostsColumn},
			Bidi:    false,
		},
		"Service",
		"Host",
	)
	graph.MustAddE(
		"checks",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   service.ChecksTable,
			Columns: []string{service.ChecksColumn},
			Bidi:    false,
		},
		"Service",
		"Check",
	)
	graph.MustAddE(
		"properties",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   service.PropertiesTable,
			Columns: []string{service.PropertiesColumn},
			Bidi:    false,
		},
		"Service",
		"Property",
	)
	graph.MustAddE(
		"competition",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: false,
			Table:   team.CompetitionTable,
			Columns: []string{team.CompetitionColumn},
			Bidi:    false,
		},
		"Team",
		"Competition",
	)
	graph.MustAddE(
		"users",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   team.UsersTable,
			Columns: team.UsersPrimaryKey,
			Bidi:    false,
		},
		"Team",
		"User",
	)
	graph.MustAddE(
		"hosts",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   team.HostsTable,
			Columns: []string{team.HostsColumn},
			Bidi:    false,
		},
		"Team",
		"Host",
	)
	graph.MustAddE(
		"teams",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   user.TeamsTable,
			Columns: user.TeamsPrimaryKey,
			Bidi:    false,
		},
		"User",
		"Team",
	)
	graph.MustAddE(
		"competitions",
		&sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   user.CompetitionsTable,
			Columns: user.CompetitionsPrimaryKey,
			Bidi:    false,
		},
		"User",
		"Competition",
	)
	return graph
}()

// predicateAdder wraps the addPredicate method.
// All update, update-one and query builders implement this interface.
type predicateAdder interface {
	addPredicate(func(s *sql.Selector))
}

// addPredicate implements the predicateAdder interface.
func (cq *CheckQuery) addPredicate(pred func(s *sql.Selector)) {
	cq.predicates = append(cq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the CheckQuery builder.
func (cq *CheckQuery) Filter() *CheckFilter {
	return &CheckFilter{config: cq.config, predicateAdder: cq}
}

// addPredicate implements the predicateAdder interface.
func (m *CheckMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the CheckMutation builder.
func (m *CheckMutation) Filter() *CheckFilter {
	return &CheckFilter{config: m.config, predicateAdder: m}
}

// CheckFilter provides a generic filtering capability at runtime for CheckQuery.
type CheckFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *CheckFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[0].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *CheckFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(check.FieldID))
}

// WherePause applies the entql bool predicate on the pause field.
func (f *CheckFilter) WherePause(p entql.BoolP) {
	f.Where(p.Field(check.FieldPause))
}

// WhereHidden applies the entql bool predicate on the hidden field.
func (f *CheckFilter) WhereHidden(p entql.BoolP) {
	f.Where(p.Field(check.FieldHidden))
}

// WhereCompetitionID applies the entql string predicate on the competition_id field.
func (f *CheckFilter) WhereCompetitionID(p entql.StringP) {
	f.Where(p.Field(check.FieldCompetitionID))
}

// WhereLog applies the entql string predicate on the log field.
func (f *CheckFilter) WhereLog(p entql.StringP) {
	f.Where(p.Field(check.FieldLog))
}

// WhereError applies the entql string predicate on the error field.
func (f *CheckFilter) WhereError(p entql.StringP) {
	f.Where(p.Field(check.FieldError))
}

// WherePassed applies the entql bool predicate on the passed field.
func (f *CheckFilter) WherePassed(p entql.BoolP) {
	f.Where(p.Field(check.FieldPassed))
}

// WhereHasCompetition applies a predicate to check if query has an edge competition.
func (f *CheckFilter) WhereHasCompetition() {
	f.Where(entql.HasEdge("competition"))
}

// WhereHasCompetitionWith applies a predicate to check if query has an edge competition with a given conditions (other predicates).
func (f *CheckFilter) WhereHasCompetitionWith(preds ...predicate.Competition) {
	f.Where(entql.HasEdgeWith("competition", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasRounds applies a predicate to check if query has an edge rounds.
func (f *CheckFilter) WhereHasRounds() {
	f.Where(entql.HasEdge("rounds"))
}

// WhereHasRoundsWith applies a predicate to check if query has an edge rounds with a given conditions (other predicates).
func (f *CheckFilter) WhereHasRoundsWith(preds ...predicate.Round) {
	f.Where(entql.HasEdgeWith("rounds", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasServices applies a predicate to check if query has an edge services.
func (f *CheckFilter) WhereHasServices() {
	f.Where(entql.HasEdge("services"))
}

// WhereHasServicesWith applies a predicate to check if query has an edge services with a given conditions (other predicates).
func (f *CheckFilter) WhereHasServicesWith(preds ...predicate.Service) {
	f.Where(entql.HasEdgeWith("services", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (cq *CompetitionQuery) addPredicate(pred func(s *sql.Selector)) {
	cq.predicates = append(cq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the CompetitionQuery builder.
func (cq *CompetitionQuery) Filter() *CompetitionFilter {
	return &CompetitionFilter{config: cq.config, predicateAdder: cq}
}

// addPredicate implements the predicateAdder interface.
func (m *CompetitionMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the CompetitionMutation builder.
func (m *CompetitionMutation) Filter() *CompetitionFilter {
	return &CompetitionFilter{config: m.config, predicateAdder: m}
}

// CompetitionFilter provides a generic filtering capability at runtime for CompetitionQuery.
type CompetitionFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *CompetitionFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[1].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *CompetitionFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(competition.FieldID))
}

// WhereHidden applies the entql bool predicate on the hidden field.
func (f *CompetitionFilter) WhereHidden(p entql.BoolP) {
	f.Where(p.Field(competition.FieldHidden))
}

// WherePause applies the entql bool predicate on the pause field.
func (f *CompetitionFilter) WherePause(p entql.BoolP) {
	f.Where(p.Field(competition.FieldPause))
}

// WhereName applies the entql string predicate on the name field.
func (f *CompetitionFilter) WhereName(p entql.StringP) {
	f.Where(p.Field(competition.FieldName))
}

// WhereDisplayName applies the entql string predicate on the display_name field.
func (f *CompetitionFilter) WhereDisplayName(p entql.StringP) {
	f.Where(p.Field(competition.FieldDisplayName))
}

// WhereViewableToPublic applies the entql bool predicate on the viewable_to_public field.
func (f *CompetitionFilter) WhereViewableToPublic(p entql.BoolP) {
	f.Where(p.Field(competition.FieldViewableToPublic))
}

// WhereToBeStartedAt applies the entql time.Time predicate on the to_be_started_at field.
func (f *CompetitionFilter) WhereToBeStartedAt(p entql.TimeP) {
	f.Where(p.Field(competition.FieldToBeStartedAt))
}

// WhereStartedAt applies the entql time.Time predicate on the started_at field.
func (f *CompetitionFilter) WhereStartedAt(p entql.TimeP) {
	f.Where(p.Field(competition.FieldStartedAt))
}

// WhereFinishedAt applies the entql time.Time predicate on the finished_at field.
func (f *CompetitionFilter) WhereFinishedAt(p entql.TimeP) {
	f.Where(p.Field(competition.FieldFinishedAt))
}

// WhereHasTeams applies a predicate to check if query has an edge teams.
func (f *CompetitionFilter) WhereHasTeams() {
	f.Where(entql.HasEdge("teams"))
}

// WhereHasTeamsWith applies a predicate to check if query has an edge teams with a given conditions (other predicates).
func (f *CompetitionFilter) WhereHasTeamsWith(preds ...predicate.Team) {
	f.Where(entql.HasEdgeWith("teams", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasUsers applies a predicate to check if query has an edge users.
func (f *CompetitionFilter) WhereHasUsers() {
	f.Where(entql.HasEdge("users"))
}

// WhereHasUsersWith applies a predicate to check if query has an edge users with a given conditions (other predicates).
func (f *CompetitionFilter) WhereHasUsersWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("users", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (hq *HostQuery) addPredicate(pred func(s *sql.Selector)) {
	hq.predicates = append(hq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the HostQuery builder.
func (hq *HostQuery) Filter() *HostFilter {
	return &HostFilter{config: hq.config, predicateAdder: hq}
}

// addPredicate implements the predicateAdder interface.
func (m *HostMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the HostMutation builder.
func (m *HostMutation) Filter() *HostFilter {
	return &HostFilter{config: m.config, predicateAdder: m}
}

// HostFilter provides a generic filtering capability at runtime for HostQuery.
type HostFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *HostFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[2].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *HostFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(host.FieldID))
}

// WherePause applies the entql bool predicate on the pause field.
func (f *HostFilter) WherePause(p entql.BoolP) {
	f.Where(p.Field(host.FieldPause))
}

// WhereHidden applies the entql bool predicate on the hidden field.
func (f *HostFilter) WhereHidden(p entql.BoolP) {
	f.Where(p.Field(host.FieldHidden))
}

// WhereCompetitionID applies the entql string predicate on the competition_id field.
func (f *HostFilter) WhereCompetitionID(p entql.StringP) {
	f.Where(p.Field(host.FieldCompetitionID))
}

// WhereTeamID applies the entql string predicate on the team_id field.
func (f *HostFilter) WhereTeamID(p entql.StringP) {
	f.Where(p.Field(host.FieldTeamID))
}

// WhereAddress applies the entql string predicate on the address field.
func (f *HostFilter) WhereAddress(p entql.StringP) {
	f.Where(p.Field(host.FieldAddress))
}

// WhereAddressListRange applies the entql string predicate on the address_list_range field.
func (f *HostFilter) WhereAddressListRange(p entql.StringP) {
	f.Where(p.Field(host.FieldAddressListRange))
}

// WhereEditable applies the entql bool predicate on the editable field.
func (f *HostFilter) WhereEditable(p entql.BoolP) {
	f.Where(p.Field(host.FieldEditable))
}

// WhereHasCompetition applies a predicate to check if query has an edge competition.
func (f *HostFilter) WhereHasCompetition() {
	f.Where(entql.HasEdge("competition"))
}

// WhereHasCompetitionWith applies a predicate to check if query has an edge competition with a given conditions (other predicates).
func (f *HostFilter) WhereHasCompetitionWith(preds ...predicate.Competition) {
	f.Where(entql.HasEdgeWith("competition", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasTeam applies a predicate to check if query has an edge team.
func (f *HostFilter) WhereHasTeam() {
	f.Where(entql.HasEdge("team"))
}

// WhereHasTeamWith applies a predicate to check if query has an edge team with a given conditions (other predicates).
func (f *HostFilter) WhereHasTeamWith(preds ...predicate.Team) {
	f.Where(entql.HasEdgeWith("team", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasServices applies a predicate to check if query has an edge services.
func (f *HostFilter) WhereHasServices() {
	f.Where(entql.HasEdge("services"))
}

// WhereHasServicesWith applies a predicate to check if query has an edge services with a given conditions (other predicates).
func (f *HostFilter) WhereHasServicesWith(preds ...predicate.Service) {
	f.Where(entql.HasEdgeWith("services", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasHostGroup applies a predicate to check if query has an edge host_group.
func (f *HostFilter) WhereHasHostGroup() {
	f.Where(entql.HasEdge("host_group"))
}

// WhereHasHostGroupWith applies a predicate to check if query has an edge host_group with a given conditions (other predicates).
func (f *HostFilter) WhereHasHostGroupWith(preds ...predicate.HostGroup) {
	f.Where(entql.HasEdgeWith("host_group", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (hgq *HostGroupQuery) addPredicate(pred func(s *sql.Selector)) {
	hgq.predicates = append(hgq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the HostGroupQuery builder.
func (hgq *HostGroupQuery) Filter() *HostGroupFilter {
	return &HostGroupFilter{config: hgq.config, predicateAdder: hgq}
}

// addPredicate implements the predicateAdder interface.
func (m *HostGroupMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the HostGroupMutation builder.
func (m *HostGroupMutation) Filter() *HostGroupFilter {
	return &HostGroupFilter{config: m.config, predicateAdder: m}
}

// HostGroupFilter provides a generic filtering capability at runtime for HostGroupQuery.
type HostGroupFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *HostGroupFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[3].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *HostGroupFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(hostgroup.FieldID))
}

// WherePause applies the entql bool predicate on the pause field.
func (f *HostGroupFilter) WherePause(p entql.BoolP) {
	f.Where(p.Field(hostgroup.FieldPause))
}

// WhereHidden applies the entql bool predicate on the hidden field.
func (f *HostGroupFilter) WhereHidden(p entql.BoolP) {
	f.Where(p.Field(hostgroup.FieldHidden))
}

// WhereCompetitionID applies the entql string predicate on the competition_id field.
func (f *HostGroupFilter) WhereCompetitionID(p entql.StringP) {
	f.Where(p.Field(hostgroup.FieldCompetitionID))
}

// WhereTeamID applies the entql string predicate on the team_id field.
func (f *HostGroupFilter) WhereTeamID(p entql.StringP) {
	f.Where(p.Field(hostgroup.FieldTeamID))
}

// WhereName applies the entql string predicate on the name field.
func (f *HostGroupFilter) WhereName(p entql.StringP) {
	f.Where(p.Field(hostgroup.FieldName))
}

// WhereHasCompetition applies a predicate to check if query has an edge competition.
func (f *HostGroupFilter) WhereHasCompetition() {
	f.Where(entql.HasEdge("competition"))
}

// WhereHasCompetitionWith applies a predicate to check if query has an edge competition with a given conditions (other predicates).
func (f *HostGroupFilter) WhereHasCompetitionWith(preds ...predicate.Competition) {
	f.Where(entql.HasEdgeWith("competition", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasTeam applies a predicate to check if query has an edge team.
func (f *HostGroupFilter) WhereHasTeam() {
	f.Where(entql.HasEdge("team"))
}

// WhereHasTeamWith applies a predicate to check if query has an edge team with a given conditions (other predicates).
func (f *HostGroupFilter) WhereHasTeamWith(preds ...predicate.Team) {
	f.Where(entql.HasEdgeWith("team", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasHosts applies a predicate to check if query has an edge hosts.
func (f *HostGroupFilter) WhereHasHosts() {
	f.Where(entql.HasEdge("hosts"))
}

// WhereHasHostsWith applies a predicate to check if query has an edge hosts with a given conditions (other predicates).
func (f *HostGroupFilter) WhereHasHostsWith(preds ...predicate.Host) {
	f.Where(entql.HasEdgeWith("hosts", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (pq *PropertyQuery) addPredicate(pred func(s *sql.Selector)) {
	pq.predicates = append(pq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the PropertyQuery builder.
func (pq *PropertyQuery) Filter() *PropertyFilter {
	return &PropertyFilter{config: pq.config, predicateAdder: pq}
}

// addPredicate implements the predicateAdder interface.
func (m *PropertyMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the PropertyMutation builder.
func (m *PropertyMutation) Filter() *PropertyFilter {
	return &PropertyFilter{config: m.config, predicateAdder: m}
}

// PropertyFilter provides a generic filtering capability at runtime for PropertyQuery.
type PropertyFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *PropertyFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[4].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *PropertyFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(property.FieldID))
}

// WhereCompetitionID applies the entql string predicate on the competition_id field.
func (f *PropertyFilter) WhereCompetitionID(p entql.StringP) {
	f.Where(p.Field(property.FieldCompetitionID))
}

// WhereTeamID applies the entql string predicate on the team_id field.
func (f *PropertyFilter) WhereTeamID(p entql.StringP) {
	f.Where(p.Field(property.FieldTeamID))
}

// WhereKey applies the entql string predicate on the key field.
func (f *PropertyFilter) WhereKey(p entql.StringP) {
	f.Where(p.Field(property.FieldKey))
}

// WhereValue applies the entql string predicate on the value field.
func (f *PropertyFilter) WhereValue(p entql.StringP) {
	f.Where(p.Field(property.FieldValue))
}

// WhereStatus applies the entql string predicate on the status field.
func (f *PropertyFilter) WhereStatus(p entql.StringP) {
	f.Where(p.Field(property.FieldStatus))
}

// WhereHasCompetition applies a predicate to check if query has an edge competition.
func (f *PropertyFilter) WhereHasCompetition() {
	f.Where(entql.HasEdge("competition"))
}

// WhereHasCompetitionWith applies a predicate to check if query has an edge competition with a given conditions (other predicates).
func (f *PropertyFilter) WhereHasCompetitionWith(preds ...predicate.Competition) {
	f.Where(entql.HasEdgeWith("competition", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasTeam applies a predicate to check if query has an edge team.
func (f *PropertyFilter) WhereHasTeam() {
	f.Where(entql.HasEdge("team"))
}

// WhereHasTeamWith applies a predicate to check if query has an edge team with a given conditions (other predicates).
func (f *PropertyFilter) WhereHasTeamWith(preds ...predicate.Team) {
	f.Where(entql.HasEdgeWith("team", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasServices applies a predicate to check if query has an edge services.
func (f *PropertyFilter) WhereHasServices() {
	f.Where(entql.HasEdge("services"))
}

// WhereHasServicesWith applies a predicate to check if query has an edge services with a given conditions (other predicates).
func (f *PropertyFilter) WhereHasServicesWith(preds ...predicate.Service) {
	f.Where(entql.HasEdgeWith("services", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (rq *ReportQuery) addPredicate(pred func(s *sql.Selector)) {
	rq.predicates = append(rq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the ReportQuery builder.
func (rq *ReportQuery) Filter() *ReportFilter {
	return &ReportFilter{config: rq.config, predicateAdder: rq}
}

// addPredicate implements the predicateAdder interface.
func (m *ReportMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the ReportMutation builder.
func (m *ReportMutation) Filter() *ReportFilter {
	return &ReportFilter{config: m.config, predicateAdder: m}
}

// ReportFilter provides a generic filtering capability at runtime for ReportQuery.
type ReportFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *ReportFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[5].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql int predicate on the id field.
func (f *ReportFilter) WhereID(p entql.IntP) {
	f.Where(p.Field(report.FieldID))
}

// WhereLog applies the entql string predicate on the log field.
func (f *ReportFilter) WhereLog(p entql.StringP) {
	f.Where(p.Field(report.FieldLog))
}

// WhereError applies the entql string predicate on the error field.
func (f *ReportFilter) WhereError(p entql.StringP) {
	f.Where(p.Field(report.FieldError))
}

// addPredicate implements the predicateAdder interface.
func (rq *RoundQuery) addPredicate(pred func(s *sql.Selector)) {
	rq.predicates = append(rq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the RoundQuery builder.
func (rq *RoundQuery) Filter() *RoundFilter {
	return &RoundFilter{config: rq.config, predicateAdder: rq}
}

// addPredicate implements the predicateAdder interface.
func (m *RoundMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the RoundMutation builder.
func (m *RoundMutation) Filter() *RoundFilter {
	return &RoundFilter{config: m.config, predicateAdder: m}
}

// RoundFilter provides a generic filtering capability at runtime for RoundQuery.
type RoundFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *RoundFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[6].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *RoundFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(round.FieldID))
}

// WhereCompetitionID applies the entql string predicate on the competition_id field.
func (f *RoundFilter) WhereCompetitionID(p entql.StringP) {
	f.Where(p.Field(round.FieldCompetitionID))
}

// WhereRoundNumber applies the entql int predicate on the round_number field.
func (f *RoundFilter) WhereRoundNumber(p entql.IntP) {
	f.Where(p.Field(round.FieldRoundNumber))
}

// WhereNote applies the entql string predicate on the note field.
func (f *RoundFilter) WhereNote(p entql.StringP) {
	f.Where(p.Field(round.FieldNote))
}

// WhereErr applies the entql string predicate on the err field.
func (f *RoundFilter) WhereErr(p entql.StringP) {
	f.Where(p.Field(round.FieldErr))
}

// WhereStartedAt applies the entql time.Time predicate on the started_at field.
func (f *RoundFilter) WhereStartedAt(p entql.TimeP) {
	f.Where(p.Field(round.FieldStartedAt))
}

// WhereFinishedAt applies the entql time.Time predicate on the finished_at field.
func (f *RoundFilter) WhereFinishedAt(p entql.TimeP) {
	f.Where(p.Field(round.FieldFinishedAt))
}

// WhereHasCompetition applies a predicate to check if query has an edge competition.
func (f *RoundFilter) WhereHasCompetition() {
	f.Where(entql.HasEdge("competition"))
}

// WhereHasCompetitionWith applies a predicate to check if query has an edge competition with a given conditions (other predicates).
func (f *RoundFilter) WhereHasCompetitionWith(preds ...predicate.Competition) {
	f.Where(entql.HasEdgeWith("competition", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasChecks applies a predicate to check if query has an edge checks.
func (f *RoundFilter) WhereHasChecks() {
	f.Where(entql.HasEdge("checks"))
}

// WhereHasChecksWith applies a predicate to check if query has an edge checks with a given conditions (other predicates).
func (f *RoundFilter) WhereHasChecksWith(preds ...predicate.Check) {
	f.Where(entql.HasEdgeWith("checks", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (sq *ServiceQuery) addPredicate(pred func(s *sql.Selector)) {
	sq.predicates = append(sq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the ServiceQuery builder.
func (sq *ServiceQuery) Filter() *ServiceFilter {
	return &ServiceFilter{config: sq.config, predicateAdder: sq}
}

// addPredicate implements the predicateAdder interface.
func (m *ServiceMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the ServiceMutation builder.
func (m *ServiceMutation) Filter() *ServiceFilter {
	return &ServiceFilter{config: m.config, predicateAdder: m}
}

// ServiceFilter provides a generic filtering capability at runtime for ServiceQuery.
type ServiceFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *ServiceFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[7].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *ServiceFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(service.FieldID))
}

// WherePause applies the entql bool predicate on the pause field.
func (f *ServiceFilter) WherePause(p entql.BoolP) {
	f.Where(p.Field(service.FieldPause))
}

// WhereHidden applies the entql bool predicate on the hidden field.
func (f *ServiceFilter) WhereHidden(p entql.BoolP) {
	f.Where(p.Field(service.FieldHidden))
}

// WhereCompetitionID applies the entql string predicate on the competition_id field.
func (f *ServiceFilter) WhereCompetitionID(p entql.StringP) {
	f.Where(p.Field(service.FieldCompetitionID))
}

// WhereTeamID applies the entql string predicate on the team_id field.
func (f *ServiceFilter) WhereTeamID(p entql.StringP) {
	f.Where(p.Field(service.FieldTeamID))
}

// WhereName applies the entql string predicate on the name field.
func (f *ServiceFilter) WhereName(p entql.StringP) {
	f.Where(p.Field(service.FieldName))
}

// WhereDisplayName applies the entql string predicate on the display_name field.
func (f *ServiceFilter) WhereDisplayName(p entql.StringP) {
	f.Where(p.Field(service.FieldDisplayName))
}

// WhereWeight applies the entql int predicate on the weight field.
func (f *ServiceFilter) WhereWeight(p entql.IntP) {
	f.Where(p.Field(service.FieldWeight))
}

// WherePointBoost applies the entql int predicate on the point_boost field.
func (f *ServiceFilter) WherePointBoost(p entql.IntP) {
	f.Where(p.Field(service.FieldPointBoost))
}

// WhereRoundUnits applies the entql int predicate on the round_units field.
func (f *ServiceFilter) WhereRoundUnits(p entql.IntP) {
	f.Where(p.Field(service.FieldRoundUnits))
}

// WhereRoundDelay applies the entql int predicate on the round_delay field.
func (f *ServiceFilter) WhereRoundDelay(p entql.IntP) {
	f.Where(p.Field(service.FieldRoundDelay))
}

// WhereHasCompetition applies a predicate to check if query has an edge competition.
func (f *ServiceFilter) WhereHasCompetition() {
	f.Where(entql.HasEdge("competition"))
}

// WhereHasCompetitionWith applies a predicate to check if query has an edge competition with a given conditions (other predicates).
func (f *ServiceFilter) WhereHasCompetitionWith(preds ...predicate.Competition) {
	f.Where(entql.HasEdgeWith("competition", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasTeam applies a predicate to check if query has an edge team.
func (f *ServiceFilter) WhereHasTeam() {
	f.Where(entql.HasEdge("team"))
}

// WhereHasTeamWith applies a predicate to check if query has an edge team with a given conditions (other predicates).
func (f *ServiceFilter) WhereHasTeamWith(preds ...predicate.Team) {
	f.Where(entql.HasEdgeWith("team", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasHosts applies a predicate to check if query has an edge hosts.
func (f *ServiceFilter) WhereHasHosts() {
	f.Where(entql.HasEdge("hosts"))
}

// WhereHasHostsWith applies a predicate to check if query has an edge hosts with a given conditions (other predicates).
func (f *ServiceFilter) WhereHasHostsWith(preds ...predicate.Host) {
	f.Where(entql.HasEdgeWith("hosts", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasChecks applies a predicate to check if query has an edge checks.
func (f *ServiceFilter) WhereHasChecks() {
	f.Where(entql.HasEdge("checks"))
}

// WhereHasChecksWith applies a predicate to check if query has an edge checks with a given conditions (other predicates).
func (f *ServiceFilter) WhereHasChecksWith(preds ...predicate.Check) {
	f.Where(entql.HasEdgeWith("checks", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasProperties applies a predicate to check if query has an edge properties.
func (f *ServiceFilter) WhereHasProperties() {
	f.Where(entql.HasEdge("properties"))
}

// WhereHasPropertiesWith applies a predicate to check if query has an edge properties with a given conditions (other predicates).
func (f *ServiceFilter) WhereHasPropertiesWith(preds ...predicate.Property) {
	f.Where(entql.HasEdgeWith("properties", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (tq *TeamQuery) addPredicate(pred func(s *sql.Selector)) {
	tq.predicates = append(tq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the TeamQuery builder.
func (tq *TeamQuery) Filter() *TeamFilter {
	return &TeamFilter{config: tq.config, predicateAdder: tq}
}

// addPredicate implements the predicateAdder interface.
func (m *TeamMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the TeamMutation builder.
func (m *TeamMutation) Filter() *TeamFilter {
	return &TeamFilter{config: m.config, predicateAdder: m}
}

// TeamFilter provides a generic filtering capability at runtime for TeamQuery.
type TeamFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *TeamFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[8].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *TeamFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(team.FieldID))
}

// WherePause applies the entql bool predicate on the pause field.
func (f *TeamFilter) WherePause(p entql.BoolP) {
	f.Where(p.Field(team.FieldPause))
}

// WhereHidden applies the entql bool predicate on the hidden field.
func (f *TeamFilter) WhereHidden(p entql.BoolP) {
	f.Where(p.Field(team.FieldHidden))
}

// WhereCompetitionID applies the entql string predicate on the competition_id field.
func (f *TeamFilter) WhereCompetitionID(p entql.StringP) {
	f.Where(p.Field(team.FieldCompetitionID))
}

// WhereName applies the entql string predicate on the name field.
func (f *TeamFilter) WhereName(p entql.StringP) {
	f.Where(p.Field(team.FieldName))
}

// WhereIndex applies the entql int predicate on the index field.
func (f *TeamFilter) WhereIndex(p entql.IntP) {
	f.Where(p.Field(team.FieldIndex))
}

// WhereHasCompetition applies a predicate to check if query has an edge competition.
func (f *TeamFilter) WhereHasCompetition() {
	f.Where(entql.HasEdge("competition"))
}

// WhereHasCompetitionWith applies a predicate to check if query has an edge competition with a given conditions (other predicates).
func (f *TeamFilter) WhereHasCompetitionWith(preds ...predicate.Competition) {
	f.Where(entql.HasEdgeWith("competition", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasUsers applies a predicate to check if query has an edge users.
func (f *TeamFilter) WhereHasUsers() {
	f.Where(entql.HasEdge("users"))
}

// WhereHasUsersWith applies a predicate to check if query has an edge users with a given conditions (other predicates).
func (f *TeamFilter) WhereHasUsersWith(preds ...predicate.User) {
	f.Where(entql.HasEdgeWith("users", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasHosts applies a predicate to check if query has an edge hosts.
func (f *TeamFilter) WhereHasHosts() {
	f.Where(entql.HasEdge("hosts"))
}

// WhereHasHostsWith applies a predicate to check if query has an edge hosts with a given conditions (other predicates).
func (f *TeamFilter) WhereHasHostsWith(preds ...predicate.Host) {
	f.Where(entql.HasEdgeWith("hosts", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// addPredicate implements the predicateAdder interface.
func (uq *UserQuery) addPredicate(pred func(s *sql.Selector)) {
	uq.predicates = append(uq.predicates, pred)
}

// Filter returns a Filter implementation to apply filters on the UserQuery builder.
func (uq *UserQuery) Filter() *UserFilter {
	return &UserFilter{config: uq.config, predicateAdder: uq}
}

// addPredicate implements the predicateAdder interface.
func (m *UserMutation) addPredicate(pred func(s *sql.Selector)) {
	m.predicates = append(m.predicates, pred)
}

// Filter returns an entql.Where implementation to apply filters on the UserMutation builder.
func (m *UserMutation) Filter() *UserFilter {
	return &UserFilter{config: m.config, predicateAdder: m}
}

// UserFilter provides a generic filtering capability at runtime for UserQuery.
type UserFilter struct {
	predicateAdder
	config
}

// Where applies the entql predicate on the query filter.
func (f *UserFilter) Where(p entql.P) {
	f.addPredicate(func(s *sql.Selector) {
		if err := schemaGraph.EvalP(schemaGraph.Nodes[9].Type, p, s); err != nil {
			s.AddError(err)
		}
	})
}

// WhereID applies the entql string predicate on the id field.
func (f *UserFilter) WhereID(p entql.StringP) {
	f.Where(p.Field(user.FieldID))
}

// WhereCreateTime applies the entql time.Time predicate on the create_time field.
func (f *UserFilter) WhereCreateTime(p entql.TimeP) {
	f.Where(p.Field(user.FieldCreateTime))
}

// WhereUpdateTime applies the entql time.Time predicate on the update_time field.
func (f *UserFilter) WhereUpdateTime(p entql.TimeP) {
	f.Where(p.Field(user.FieldUpdateTime))
}

// WhereUsername applies the entql string predicate on the username field.
func (f *UserFilter) WhereUsername(p entql.StringP) {
	f.Where(p.Field(user.FieldUsername))
}

// WhereOryID applies the entql [16]byte predicate on the ory_id field.
func (f *UserFilter) WhereOryID(p entql.ValueP) {
	f.Where(p.Field(user.FieldOryID))
}

// WhereHasTeams applies a predicate to check if query has an edge teams.
func (f *UserFilter) WhereHasTeams() {
	f.Where(entql.HasEdge("teams"))
}

// WhereHasTeamsWith applies a predicate to check if query has an edge teams with a given conditions (other predicates).
func (f *UserFilter) WhereHasTeamsWith(preds ...predicate.Team) {
	f.Where(entql.HasEdgeWith("teams", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}

// WhereHasCompetitions applies a predicate to check if query has an edge competitions.
func (f *UserFilter) WhereHasCompetitions() {
	f.Where(entql.HasEdge("competitions"))
}

// WhereHasCompetitionsWith applies a predicate to check if query has an edge competitions with a given conditions (other predicates).
func (f *UserFilter) WhereHasCompetitionsWith(preds ...predicate.Competition) {
	f.Where(entql.HasEdgeWith("competitions", sqlgraph.WrapFunc(func(s *sql.Selector) {
		for _, p := range preds {
			p(s)
		}
	})))
}
