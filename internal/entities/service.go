// Code generated by ent, DO NOT EDIT.

package entities

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/scoretrak/scoretrak/internal/entities/service"
	"github.com/scoretrak/scoretrak/pkg/scorer"
)

// Service is the model entity for the Service schema.
type Service struct {
	config `json:"-"`
	// ID of the ent.
	ID string `json:"id,omitempty"`
	// Name holds the value of the "name" field.
	Name string `json:"name,omitempty"`
	// DisplayName holds the value of the "display_name" field.
	DisplayName string `json:"display_name,omitempty"`
	// Pause holds the value of the "pause" field.
	Pause bool `json:"pause,omitempty"`
	// Hidden holds the value of the "hidden" field.
	Hidden bool `json:"hidden,omitempty"`
	// CreateTime holds the value of the "create_time" field.
	CreateTime time.Time `json:"create_time,omitempty"`
	// UpdateTime holds the value of the "update_time" field.
	UpdateTime time.Time `json:"update_time,omitempty"`
	// Type holds the value of the "type" field.
	Type scorer.ServiceType `json:"type,omitempty"`
	// Weight holds the value of the "weight" field.
	Weight int `json:"weight,omitempty"`
	// PointBoost holds the value of the "point_boost" field.
	PointBoost int `json:"point_boost,omitempty"`
	// The number of times to score every x round. If you round freq is 1, it will be scored every round. If it is 3, it will be scored, every three rounds. Ex. 1 not scored, 2 not scored, 3 scored, 4 not scored.
	RoundFrequency int `json:"round_frequency,omitempty"`
	// The number of rounds to delay a round by. Round numbers start at 1. If your round delay is 0, it will start scoring in round 1. If you round delay is 3, it will start scoring on the 4th round.
	RoundDelay int `json:"round_delay,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the ServiceQuery when eager-loading is set.
	Edges        ServiceEdges `json:"edges"`
	selectValues sql.SelectValues
}

// ServiceEdges holds the relations/edges for other nodes in the graph.
type ServiceEdges struct {
	// Hostservices holds the value of the hostservices edge.
	Hostservices []*HostService `json:"hostservices,omitempty"`
	// Hostservicereports holds the value of the hostservicereports edge.
	Hostservicereports []*HostServiceReport `json:"hostservicereports,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [2]bool
}

// HostservicesOrErr returns the Hostservices value or an error if the edge
// was not loaded in eager-loading.
func (e ServiceEdges) HostservicesOrErr() ([]*HostService, error) {
	if e.loadedTypes[0] {
		return e.Hostservices, nil
	}
	return nil, &NotLoadedError{edge: "hostservices"}
}

// HostservicereportsOrErr returns the Hostservicereports value or an error if the edge
// was not loaded in eager-loading.
func (e ServiceEdges) HostservicereportsOrErr() ([]*HostServiceReport, error) {
	if e.loadedTypes[1] {
		return e.Hostservicereports, nil
	}
	return nil, &NotLoadedError{edge: "hostservicereports"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Service) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case service.FieldPause, service.FieldHidden:
			values[i] = new(sql.NullBool)
		case service.FieldWeight, service.FieldPointBoost, service.FieldRoundFrequency, service.FieldRoundDelay:
			values[i] = new(sql.NullInt64)
		case service.FieldID, service.FieldName, service.FieldDisplayName, service.FieldType:
			values[i] = new(sql.NullString)
		case service.FieldCreateTime, service.FieldUpdateTime:
			values[i] = new(sql.NullTime)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Service fields.
func (s *Service) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case service.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				s.ID = value.String
			}
		case service.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				s.Name = value.String
			}
		case service.FieldDisplayName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field display_name", values[i])
			} else if value.Valid {
				s.DisplayName = value.String
			}
		case service.FieldPause:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field pause", values[i])
			} else if value.Valid {
				s.Pause = value.Bool
			}
		case service.FieldHidden:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field hidden", values[i])
			} else if value.Valid {
				s.Hidden = value.Bool
			}
		case service.FieldCreateTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field create_time", values[i])
			} else if value.Valid {
				s.CreateTime = value.Time
			}
		case service.FieldUpdateTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field update_time", values[i])
			} else if value.Valid {
				s.UpdateTime = value.Time
			}
		case service.FieldType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field type", values[i])
			} else if value.Valid {
				s.Type = scorer.ServiceType(value.String)
			}
		case service.FieldWeight:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field weight", values[i])
			} else if value.Valid {
				s.Weight = int(value.Int64)
			}
		case service.FieldPointBoost:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field point_boost", values[i])
			} else if value.Valid {
				s.PointBoost = int(value.Int64)
			}
		case service.FieldRoundFrequency:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field round_frequency", values[i])
			} else if value.Valid {
				s.RoundFrequency = int(value.Int64)
			}
		case service.FieldRoundDelay:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field round_delay", values[i])
			} else if value.Valid {
				s.RoundDelay = int(value.Int64)
			}
		default:
			s.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Service.
// This includes values selected through modifiers, order, etc.
func (s *Service) Value(name string) (ent.Value, error) {
	return s.selectValues.Get(name)
}

// QueryHostservices queries the "hostservices" edge of the Service entity.
func (s *Service) QueryHostservices() *HostServiceQuery {
	return NewServiceClient(s.config).QueryHostservices(s)
}

// QueryHostservicereports queries the "hostservicereports" edge of the Service entity.
func (s *Service) QueryHostservicereports() *HostServiceReportQuery {
	return NewServiceClient(s.config).QueryHostservicereports(s)
}

// Update returns a builder for updating this Service.
// Note that you need to call Service.Unwrap() before calling this method if this Service
// was returned from a transaction, and the transaction was committed or rolled back.
func (s *Service) Update() *ServiceUpdateOne {
	return NewServiceClient(s.config).UpdateOne(s)
}

// Unwrap unwraps the Service entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (s *Service) Unwrap() *Service {
	_tx, ok := s.config.driver.(*txDriver)
	if !ok {
		panic("entities: Service is not a transactional entity")
	}
	s.config.driver = _tx.drv
	return s
}

// String implements the fmt.Stringer.
func (s *Service) String() string {
	var builder strings.Builder
	builder.WriteString("Service(")
	builder.WriteString(fmt.Sprintf("id=%v, ", s.ID))
	builder.WriteString("name=")
	builder.WriteString(s.Name)
	builder.WriteString(", ")
	builder.WriteString("display_name=")
	builder.WriteString(s.DisplayName)
	builder.WriteString(", ")
	builder.WriteString("pause=")
	builder.WriteString(fmt.Sprintf("%v", s.Pause))
	builder.WriteString(", ")
	builder.WriteString("hidden=")
	builder.WriteString(fmt.Sprintf("%v", s.Hidden))
	builder.WriteString(", ")
	builder.WriteString("create_time=")
	builder.WriteString(s.CreateTime.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("update_time=")
	builder.WriteString(s.UpdateTime.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("type=")
	builder.WriteString(fmt.Sprintf("%v", s.Type))
	builder.WriteString(", ")
	builder.WriteString("weight=")
	builder.WriteString(fmt.Sprintf("%v", s.Weight))
	builder.WriteString(", ")
	builder.WriteString("point_boost=")
	builder.WriteString(fmt.Sprintf("%v", s.PointBoost))
	builder.WriteString(", ")
	builder.WriteString("round_frequency=")
	builder.WriteString(fmt.Sprintf("%v", s.RoundFrequency))
	builder.WriteString(", ")
	builder.WriteString("round_delay=")
	builder.WriteString(fmt.Sprintf("%v", s.RoundDelay))
	builder.WriteByte(')')
	return builder.String()
}

// Services is a parsable slice of Service.
type Services []*Service
