// Code generated by ent, DO NOT EDIT.

package entities

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/check"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/competition"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/host"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/hostgroup"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/predicate"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/property"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/round"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/service"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/team"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCheck       = "Check"
	TypeCompetition = "Competition"
	TypeHost        = "Host"
	TypeHostGroup   = "HostGroup"
	TypeProperty    = "Property"
	TypeRound       = "Round"
	TypeService     = "Service"
	TypeTeam        = "Team"
	TypeUser        = "User"
)

// CheckMutation represents an operation that mutates the Check nodes in the graph.
type CheckMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	create_time        *time.Time
	update_time        *time.Time
	pause              *bool
	hidden             *bool
	log                *string
	error              *string
	passed             *bool
	clearedFields      map[string]struct{}
	competition        *int
	clearedcompetition bool
	rounds             *int
	clearedrounds      bool
	services           *int
	clearedservices    bool
	done               bool
	oldValue           func(context.Context) (*Check, error)
	predicates         []predicate.Check
}

var _ ent.Mutation = (*CheckMutation)(nil)

// checkOption allows management of the mutation configuration using functional options.
type checkOption func(*CheckMutation)

// newCheckMutation creates new mutation for the Check entity.
func newCheckMutation(c config, op Op, opts ...checkOption) *CheckMutation {
	m := &CheckMutation{
		config:        c,
		op:            op,
		typ:           TypeCheck,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCheckID sets the ID field of the mutation.
func withCheckID(id int) checkOption {
	return func(m *CheckMutation) {
		var (
			err   error
			once  sync.Once
			value *Check
		)
		m.oldValue = func(ctx context.Context) (*Check, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Check.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCheck sets the old Check of the mutation.
func withCheck(node *Check) checkOption {
	return func(m *CheckMutation) {
		m.oldValue = func(context.Context) (*Check, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CheckMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CheckMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entities: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CheckMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CheckMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Check.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CheckMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CheckMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CheckMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CheckMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CheckMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CheckMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetPause sets the "pause" field.
func (m *CheckMutation) SetPause(b bool) {
	m.pause = &b
}

// Pause returns the value of the "pause" field in the mutation.
func (m *CheckMutation) Pause() (r bool, exists bool) {
	v := m.pause
	if v == nil {
		return
	}
	return *v, true
}

// OldPause returns the old "pause" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldPause(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPause is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPause requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPause: %w", err)
	}
	return oldValue.Pause, nil
}

// ResetPause resets all changes to the "pause" field.
func (m *CheckMutation) ResetPause() {
	m.pause = nil
}

// SetHidden sets the "hidden" field.
func (m *CheckMutation) SetHidden(b bool) {
	m.hidden = &b
}

// Hidden returns the value of the "hidden" field in the mutation.
func (m *CheckMutation) Hidden() (r bool, exists bool) {
	v := m.hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldHidden returns the old "hidden" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHidden: %w", err)
	}
	return oldValue.Hidden, nil
}

// ResetHidden resets all changes to the "hidden" field.
func (m *CheckMutation) ResetHidden() {
	m.hidden = nil
}

// SetCompetitionID sets the "competition_id" field.
func (m *CheckMutation) SetCompetitionID(i int) {
	m.competition = &i
}

// CompetitionID returns the value of the "competition_id" field in the mutation.
func (m *CheckMutation) CompetitionID() (r int, exists bool) {
	v := m.competition
	if v == nil {
		return
	}
	return *v, true
}

// OldCompetitionID returns the old "competition_id" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldCompetitionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompetitionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompetitionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompetitionID: %w", err)
	}
	return oldValue.CompetitionID, nil
}

// ResetCompetitionID resets all changes to the "competition_id" field.
func (m *CheckMutation) ResetCompetitionID() {
	m.competition = nil
}

// SetLog sets the "log" field.
func (m *CheckMutation) SetLog(s string) {
	m.log = &s
}

// Log returns the value of the "log" field in the mutation.
func (m *CheckMutation) Log() (r string, exists bool) {
	v := m.log
	if v == nil {
		return
	}
	return *v, true
}

// OldLog returns the old "log" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldLog(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLog is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLog requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLog: %w", err)
	}
	return oldValue.Log, nil
}

// ResetLog resets all changes to the "log" field.
func (m *CheckMutation) ResetLog() {
	m.log = nil
}

// SetError sets the "error" field.
func (m *CheckMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *CheckMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ResetError resets all changes to the "error" field.
func (m *CheckMutation) ResetError() {
	m.error = nil
}

// SetPassed sets the "passed" field.
func (m *CheckMutation) SetPassed(b bool) {
	m.passed = &b
}

// Passed returns the value of the "passed" field in the mutation.
func (m *CheckMutation) Passed() (r bool, exists bool) {
	v := m.passed
	if v == nil {
		return
	}
	return *v, true
}

// OldPassed returns the old "passed" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldPassed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassed: %w", err)
	}
	return oldValue.Passed, nil
}

// ResetPassed resets all changes to the "passed" field.
func (m *CheckMutation) ResetPassed() {
	m.passed = nil
}

// ClearCompetition clears the "competition" edge to the Competition entity.
func (m *CheckMutation) ClearCompetition() {
	m.clearedcompetition = true
}

// CompetitionCleared reports if the "competition" edge to the Competition entity was cleared.
func (m *CheckMutation) CompetitionCleared() bool {
	return m.clearedcompetition
}

// CompetitionIDs returns the "competition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompetitionID instead. It exists only for internal usage by the builders.
func (m *CheckMutation) CompetitionIDs() (ids []int) {
	if id := m.competition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompetition resets all changes to the "competition" edge.
func (m *CheckMutation) ResetCompetition() {
	m.competition = nil
	m.clearedcompetition = false
}

// SetRoundsID sets the "rounds" edge to the Round entity by id.
func (m *CheckMutation) SetRoundsID(id int) {
	m.rounds = &id
}

// ClearRounds clears the "rounds" edge to the Round entity.
func (m *CheckMutation) ClearRounds() {
	m.clearedrounds = true
}

// RoundsCleared reports if the "rounds" edge to the Round entity was cleared.
func (m *CheckMutation) RoundsCleared() bool {
	return m.clearedrounds
}

// RoundsID returns the "rounds" edge ID in the mutation.
func (m *CheckMutation) RoundsID() (id int, exists bool) {
	if m.rounds != nil {
		return *m.rounds, true
	}
	return
}

// RoundsIDs returns the "rounds" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoundsID instead. It exists only for internal usage by the builders.
func (m *CheckMutation) RoundsIDs() (ids []int) {
	if id := m.rounds; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRounds resets all changes to the "rounds" edge.
func (m *CheckMutation) ResetRounds() {
	m.rounds = nil
	m.clearedrounds = false
}

// SetServicesID sets the "services" edge to the Service entity by id.
func (m *CheckMutation) SetServicesID(id int) {
	m.services = &id
}

// ClearServices clears the "services" edge to the Service entity.
func (m *CheckMutation) ClearServices() {
	m.clearedservices = true
}

// ServicesCleared reports if the "services" edge to the Service entity was cleared.
func (m *CheckMutation) ServicesCleared() bool {
	return m.clearedservices
}

// ServicesID returns the "services" edge ID in the mutation.
func (m *CheckMutation) ServicesID() (id int, exists bool) {
	if m.services != nil {
		return *m.services, true
	}
	return
}

// ServicesIDs returns the "services" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServicesID instead. It exists only for internal usage by the builders.
func (m *CheckMutation) ServicesIDs() (ids []int) {
	if id := m.services; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServices resets all changes to the "services" edge.
func (m *CheckMutation) ResetServices() {
	m.services = nil
	m.clearedservices = false
}

// Where appends a list predicates to the CheckMutation builder.
func (m *CheckMutation) Where(ps ...predicate.Check) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CheckMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CheckMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Check, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CheckMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CheckMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Check).
func (m *CheckMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CheckMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, check.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, check.FieldUpdateTime)
	}
	if m.pause != nil {
		fields = append(fields, check.FieldPause)
	}
	if m.hidden != nil {
		fields = append(fields, check.FieldHidden)
	}
	if m.competition != nil {
		fields = append(fields, check.FieldCompetitionID)
	}
	if m.log != nil {
		fields = append(fields, check.FieldLog)
	}
	if m.error != nil {
		fields = append(fields, check.FieldError)
	}
	if m.passed != nil {
		fields = append(fields, check.FieldPassed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CheckMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case check.FieldCreateTime:
		return m.CreateTime()
	case check.FieldUpdateTime:
		return m.UpdateTime()
	case check.FieldPause:
		return m.Pause()
	case check.FieldHidden:
		return m.Hidden()
	case check.FieldCompetitionID:
		return m.CompetitionID()
	case check.FieldLog:
		return m.Log()
	case check.FieldError:
		return m.Error()
	case check.FieldPassed:
		return m.Passed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CheckMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case check.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case check.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case check.FieldPause:
		return m.OldPause(ctx)
	case check.FieldHidden:
		return m.OldHidden(ctx)
	case check.FieldCompetitionID:
		return m.OldCompetitionID(ctx)
	case check.FieldLog:
		return m.OldLog(ctx)
	case check.FieldError:
		return m.OldError(ctx)
	case check.FieldPassed:
		return m.OldPassed(ctx)
	}
	return nil, fmt.Errorf("unknown Check field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CheckMutation) SetField(name string, value ent.Value) error {
	switch name {
	case check.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case check.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case check.FieldPause:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPause(v)
		return nil
	case check.FieldHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHidden(v)
		return nil
	case check.FieldCompetitionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompetitionID(v)
		return nil
	case check.FieldLog:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLog(v)
		return nil
	case check.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case check.FieldPassed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassed(v)
		return nil
	}
	return fmt.Errorf("unknown Check field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CheckMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CheckMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CheckMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Check numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CheckMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CheckMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CheckMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Check nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CheckMutation) ResetField(name string) error {
	switch name {
	case check.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case check.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case check.FieldPause:
		m.ResetPause()
		return nil
	case check.FieldHidden:
		m.ResetHidden()
		return nil
	case check.FieldCompetitionID:
		m.ResetCompetitionID()
		return nil
	case check.FieldLog:
		m.ResetLog()
		return nil
	case check.FieldError:
		m.ResetError()
		return nil
	case check.FieldPassed:
		m.ResetPassed()
		return nil
	}
	return fmt.Errorf("unknown Check field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CheckMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.competition != nil {
		edges = append(edges, check.EdgeCompetition)
	}
	if m.rounds != nil {
		edges = append(edges, check.EdgeRounds)
	}
	if m.services != nil {
		edges = append(edges, check.EdgeServices)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CheckMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case check.EdgeCompetition:
		if id := m.competition; id != nil {
			return []ent.Value{*id}
		}
	case check.EdgeRounds:
		if id := m.rounds; id != nil {
			return []ent.Value{*id}
		}
	case check.EdgeServices:
		if id := m.services; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CheckMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CheckMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CheckMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcompetition {
		edges = append(edges, check.EdgeCompetition)
	}
	if m.clearedrounds {
		edges = append(edges, check.EdgeRounds)
	}
	if m.clearedservices {
		edges = append(edges, check.EdgeServices)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CheckMutation) EdgeCleared(name string) bool {
	switch name {
	case check.EdgeCompetition:
		return m.clearedcompetition
	case check.EdgeRounds:
		return m.clearedrounds
	case check.EdgeServices:
		return m.clearedservices
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CheckMutation) ClearEdge(name string) error {
	switch name {
	case check.EdgeCompetition:
		m.ClearCompetition()
		return nil
	case check.EdgeRounds:
		m.ClearRounds()
		return nil
	case check.EdgeServices:
		m.ClearServices()
		return nil
	}
	return fmt.Errorf("unknown Check unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CheckMutation) ResetEdge(name string) error {
	switch name {
	case check.EdgeCompetition:
		m.ResetCompetition()
		return nil
	case check.EdgeRounds:
		m.ResetRounds()
		return nil
	case check.EdgeServices:
		m.ResetServices()
		return nil
	}
	return fmt.Errorf("unknown Check edge %s", name)
}

// CompetitionMutation represents an operation that mutates the Competition nodes in the graph.
type CompetitionMutation struct {
	config
	op                Op
	typ               string
	id                *int
	create_time       *time.Time
	update_time       *time.Time
	hidden            *bool
	pause             *bool
	name              *string
	display_name      *string
	round_duration    *float64
	addround_duration *float64
	to_be_started_at  *time.Time
	started_at        *time.Time
	finished_at       *time.Time
	clearedFields     map[string]struct{}
	teams             map[int]struct{}
	removedteams      map[int]struct{}
	clearedteams      bool
	users             map[int]struct{}
	removedusers      map[int]struct{}
	clearedusers      bool
	done              bool
	oldValue          func(context.Context) (*Competition, error)
	predicates        []predicate.Competition
}

var _ ent.Mutation = (*CompetitionMutation)(nil)

// competitionOption allows management of the mutation configuration using functional options.
type competitionOption func(*CompetitionMutation)

// newCompetitionMutation creates new mutation for the Competition entity.
func newCompetitionMutation(c config, op Op, opts ...competitionOption) *CompetitionMutation {
	m := &CompetitionMutation{
		config:        c,
		op:            op,
		typ:           TypeCompetition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompetitionID sets the ID field of the mutation.
func withCompetitionID(id int) competitionOption {
	return func(m *CompetitionMutation) {
		var (
			err   error
			once  sync.Once
			value *Competition
		)
		m.oldValue = func(ctx context.Context) (*Competition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Competition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompetition sets the old Competition of the mutation.
func withCompetition(node *Competition) competitionOption {
	return func(m *CompetitionMutation) {
		m.oldValue = func(context.Context) (*Competition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompetitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompetitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entities: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompetitionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompetitionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Competition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CompetitionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CompetitionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CompetitionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CompetitionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CompetitionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CompetitionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetHidden sets the "hidden" field.
func (m *CompetitionMutation) SetHidden(b bool) {
	m.hidden = &b
}

// Hidden returns the value of the "hidden" field in the mutation.
func (m *CompetitionMutation) Hidden() (r bool, exists bool) {
	v := m.hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldHidden returns the old "hidden" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHidden: %w", err)
	}
	return oldValue.Hidden, nil
}

// ResetHidden resets all changes to the "hidden" field.
func (m *CompetitionMutation) ResetHidden() {
	m.hidden = nil
}

// SetPause sets the "pause" field.
func (m *CompetitionMutation) SetPause(b bool) {
	m.pause = &b
}

// Pause returns the value of the "pause" field in the mutation.
func (m *CompetitionMutation) Pause() (r bool, exists bool) {
	v := m.pause
	if v == nil {
		return
	}
	return *v, true
}

// OldPause returns the old "pause" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldPause(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPause is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPause requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPause: %w", err)
	}
	return oldValue.Pause, nil
}

// ResetPause resets all changes to the "pause" field.
func (m *CompetitionMutation) ResetPause() {
	m.pause = nil
}

// SetName sets the "name" field.
func (m *CompetitionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CompetitionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CompetitionMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *CompetitionMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *CompetitionMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *CompetitionMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetRoundDuration sets the "round_duration" field.
func (m *CompetitionMutation) SetRoundDuration(f float64) {
	m.round_duration = &f
	m.addround_duration = nil
}

// RoundDuration returns the value of the "round_duration" field in the mutation.
func (m *CompetitionMutation) RoundDuration() (r float64, exists bool) {
	v := m.round_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldRoundDuration returns the old "round_duration" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldRoundDuration(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoundDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoundDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoundDuration: %w", err)
	}
	return oldValue.RoundDuration, nil
}

// AddRoundDuration adds f to the "round_duration" field.
func (m *CompetitionMutation) AddRoundDuration(f float64) {
	if m.addround_duration != nil {
		*m.addround_duration += f
	} else {
		m.addround_duration = &f
	}
}

// AddedRoundDuration returns the value that was added to the "round_duration" field in this mutation.
func (m *CompetitionMutation) AddedRoundDuration() (r float64, exists bool) {
	v := m.addround_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoundDuration resets all changes to the "round_duration" field.
func (m *CompetitionMutation) ResetRoundDuration() {
	m.round_duration = nil
	m.addround_duration = nil
}

// SetToBeStartedAt sets the "to_be_started_at" field.
func (m *CompetitionMutation) SetToBeStartedAt(t time.Time) {
	m.to_be_started_at = &t
}

// ToBeStartedAt returns the value of the "to_be_started_at" field in the mutation.
func (m *CompetitionMutation) ToBeStartedAt() (r time.Time, exists bool) {
	v := m.to_be_started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldToBeStartedAt returns the old "to_be_started_at" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldToBeStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToBeStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToBeStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToBeStartedAt: %w", err)
	}
	return oldValue.ToBeStartedAt, nil
}

// ClearToBeStartedAt clears the value of the "to_be_started_at" field.
func (m *CompetitionMutation) ClearToBeStartedAt() {
	m.to_be_started_at = nil
	m.clearedFields[competition.FieldToBeStartedAt] = struct{}{}
}

// ToBeStartedAtCleared returns if the "to_be_started_at" field was cleared in this mutation.
func (m *CompetitionMutation) ToBeStartedAtCleared() bool {
	_, ok := m.clearedFields[competition.FieldToBeStartedAt]
	return ok
}

// ResetToBeStartedAt resets all changes to the "to_be_started_at" field.
func (m *CompetitionMutation) ResetToBeStartedAt() {
	m.to_be_started_at = nil
	delete(m.clearedFields, competition.FieldToBeStartedAt)
}

// SetStartedAt sets the "started_at" field.
func (m *CompetitionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *CompetitionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *CompetitionMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[competition.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *CompetitionMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[competition.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *CompetitionMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, competition.FieldStartedAt)
}

// SetFinishedAt sets the "finished_at" field.
func (m *CompetitionMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *CompetitionMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldFinishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ClearFinishedAt clears the value of the "finished_at" field.
func (m *CompetitionMutation) ClearFinishedAt() {
	m.finished_at = nil
	m.clearedFields[competition.FieldFinishedAt] = struct{}{}
}

// FinishedAtCleared returns if the "finished_at" field was cleared in this mutation.
func (m *CompetitionMutation) FinishedAtCleared() bool {
	_, ok := m.clearedFields[competition.FieldFinishedAt]
	return ok
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *CompetitionMutation) ResetFinishedAt() {
	m.finished_at = nil
	delete(m.clearedFields, competition.FieldFinishedAt)
}

// AddTeamIDs adds the "teams" edge to the Team entity by ids.
func (m *CompetitionMutation) AddTeamIDs(ids ...int) {
	if m.teams == nil {
		m.teams = make(map[int]struct{})
	}
	for i := range ids {
		m.teams[ids[i]] = struct{}{}
	}
}

// ClearTeams clears the "teams" edge to the Team entity.
func (m *CompetitionMutation) ClearTeams() {
	m.clearedteams = true
}

// TeamsCleared reports if the "teams" edge to the Team entity was cleared.
func (m *CompetitionMutation) TeamsCleared() bool {
	return m.clearedteams
}

// RemoveTeamIDs removes the "teams" edge to the Team entity by IDs.
func (m *CompetitionMutation) RemoveTeamIDs(ids ...int) {
	if m.removedteams == nil {
		m.removedteams = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.teams, ids[i])
		m.removedteams[ids[i]] = struct{}{}
	}
}

// RemovedTeams returns the removed IDs of the "teams" edge to the Team entity.
func (m *CompetitionMutation) RemovedTeamsIDs() (ids []int) {
	for id := range m.removedteams {
		ids = append(ids, id)
	}
	return
}

// TeamsIDs returns the "teams" edge IDs in the mutation.
func (m *CompetitionMutation) TeamsIDs() (ids []int) {
	for id := range m.teams {
		ids = append(ids, id)
	}
	return
}

// ResetTeams resets all changes to the "teams" edge.
func (m *CompetitionMutation) ResetTeams() {
	m.teams = nil
	m.clearedteams = false
	m.removedteams = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *CompetitionMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *CompetitionMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *CompetitionMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *CompetitionMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *CompetitionMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *CompetitionMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *CompetitionMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the CompetitionMutation builder.
func (m *CompetitionMutation) Where(ps ...predicate.Competition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompetitionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompetitionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Competition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompetitionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompetitionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Competition).
func (m *CompetitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompetitionMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, competition.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, competition.FieldUpdateTime)
	}
	if m.hidden != nil {
		fields = append(fields, competition.FieldHidden)
	}
	if m.pause != nil {
		fields = append(fields, competition.FieldPause)
	}
	if m.name != nil {
		fields = append(fields, competition.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, competition.FieldDisplayName)
	}
	if m.round_duration != nil {
		fields = append(fields, competition.FieldRoundDuration)
	}
	if m.to_be_started_at != nil {
		fields = append(fields, competition.FieldToBeStartedAt)
	}
	if m.started_at != nil {
		fields = append(fields, competition.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, competition.FieldFinishedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompetitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case competition.FieldCreateTime:
		return m.CreateTime()
	case competition.FieldUpdateTime:
		return m.UpdateTime()
	case competition.FieldHidden:
		return m.Hidden()
	case competition.FieldPause:
		return m.Pause()
	case competition.FieldName:
		return m.Name()
	case competition.FieldDisplayName:
		return m.DisplayName()
	case competition.FieldRoundDuration:
		return m.RoundDuration()
	case competition.FieldToBeStartedAt:
		return m.ToBeStartedAt()
	case competition.FieldStartedAt:
		return m.StartedAt()
	case competition.FieldFinishedAt:
		return m.FinishedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompetitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case competition.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case competition.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case competition.FieldHidden:
		return m.OldHidden(ctx)
	case competition.FieldPause:
		return m.OldPause(ctx)
	case competition.FieldName:
		return m.OldName(ctx)
	case competition.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case competition.FieldRoundDuration:
		return m.OldRoundDuration(ctx)
	case competition.FieldToBeStartedAt:
		return m.OldToBeStartedAt(ctx)
	case competition.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case competition.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Competition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompetitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case competition.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case competition.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case competition.FieldHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHidden(v)
		return nil
	case competition.FieldPause:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPause(v)
		return nil
	case competition.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case competition.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case competition.FieldRoundDuration:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoundDuration(v)
		return nil
	case competition.FieldToBeStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToBeStartedAt(v)
		return nil
	case competition.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case competition.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Competition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompetitionMutation) AddedFields() []string {
	var fields []string
	if m.addround_duration != nil {
		fields = append(fields, competition.FieldRoundDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompetitionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case competition.FieldRoundDuration:
		return m.AddedRoundDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompetitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case competition.FieldRoundDuration:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoundDuration(v)
		return nil
	}
	return fmt.Errorf("unknown Competition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompetitionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(competition.FieldToBeStartedAt) {
		fields = append(fields, competition.FieldToBeStartedAt)
	}
	if m.FieldCleared(competition.FieldStartedAt) {
		fields = append(fields, competition.FieldStartedAt)
	}
	if m.FieldCleared(competition.FieldFinishedAt) {
		fields = append(fields, competition.FieldFinishedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompetitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompetitionMutation) ClearField(name string) error {
	switch name {
	case competition.FieldToBeStartedAt:
		m.ClearToBeStartedAt()
		return nil
	case competition.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case competition.FieldFinishedAt:
		m.ClearFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown Competition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompetitionMutation) ResetField(name string) error {
	switch name {
	case competition.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case competition.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case competition.FieldHidden:
		m.ResetHidden()
		return nil
	case competition.FieldPause:
		m.ResetPause()
		return nil
	case competition.FieldName:
		m.ResetName()
		return nil
	case competition.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case competition.FieldRoundDuration:
		m.ResetRoundDuration()
		return nil
	case competition.FieldToBeStartedAt:
		m.ResetToBeStartedAt()
		return nil
	case competition.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case competition.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown Competition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompetitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.teams != nil {
		edges = append(edges, competition.EdgeTeams)
	}
	if m.users != nil {
		edges = append(edges, competition.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompetitionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case competition.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.teams))
		for id := range m.teams {
			ids = append(ids, id)
		}
		return ids
	case competition.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompetitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedteams != nil {
		edges = append(edges, competition.EdgeTeams)
	}
	if m.removedusers != nil {
		edges = append(edges, competition.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompetitionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case competition.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.removedteams))
		for id := range m.removedteams {
			ids = append(ids, id)
		}
		return ids
	case competition.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompetitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedteams {
		edges = append(edges, competition.EdgeTeams)
	}
	if m.clearedusers {
		edges = append(edges, competition.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompetitionMutation) EdgeCleared(name string) bool {
	switch name {
	case competition.EdgeTeams:
		return m.clearedteams
	case competition.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompetitionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Competition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompetitionMutation) ResetEdge(name string) error {
	switch name {
	case competition.EdgeTeams:
		m.ResetTeams()
		return nil
	case competition.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Competition edge %s", name)
}

// HostMutation represents an operation that mutates the Host nodes in the graph.
type HostMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	create_time        *time.Time
	update_time        *time.Time
	pause              *bool
	hidden             *bool
	address            *string
	address_list_range *string
	editable           *bool
	clearedFields      map[string]struct{}
	competition        *int
	clearedcompetition bool
	team               *int
	clearedteam        bool
	services           map[int]struct{}
	removedservices    map[int]struct{}
	clearedservices    bool
	host_group         *int
	clearedhost_group  bool
	done               bool
	oldValue           func(context.Context) (*Host, error)
	predicates         []predicate.Host
}

var _ ent.Mutation = (*HostMutation)(nil)

// hostOption allows management of the mutation configuration using functional options.
type hostOption func(*HostMutation)

// newHostMutation creates new mutation for the Host entity.
func newHostMutation(c config, op Op, opts ...hostOption) *HostMutation {
	m := &HostMutation{
		config:        c,
		op:            op,
		typ:           TypeHost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHostID sets the ID field of the mutation.
func withHostID(id int) hostOption {
	return func(m *HostMutation) {
		var (
			err   error
			once  sync.Once
			value *Host
		)
		m.oldValue = func(ctx context.Context) (*Host, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Host.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHost sets the old Host of the mutation.
func withHost(node *Host) hostOption {
	return func(m *HostMutation) {
		m.oldValue = func(context.Context) (*Host, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entities: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HostMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HostMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Host.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *HostMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *HostMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *HostMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *HostMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *HostMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *HostMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetPause sets the "pause" field.
func (m *HostMutation) SetPause(b bool) {
	m.pause = &b
}

// Pause returns the value of the "pause" field in the mutation.
func (m *HostMutation) Pause() (r bool, exists bool) {
	v := m.pause
	if v == nil {
		return
	}
	return *v, true
}

// OldPause returns the old "pause" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldPause(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPause is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPause requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPause: %w", err)
	}
	return oldValue.Pause, nil
}

// ResetPause resets all changes to the "pause" field.
func (m *HostMutation) ResetPause() {
	m.pause = nil
}

// SetHidden sets the "hidden" field.
func (m *HostMutation) SetHidden(b bool) {
	m.hidden = &b
}

// Hidden returns the value of the "hidden" field in the mutation.
func (m *HostMutation) Hidden() (r bool, exists bool) {
	v := m.hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldHidden returns the old "hidden" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHidden: %w", err)
	}
	return oldValue.Hidden, nil
}

// ResetHidden resets all changes to the "hidden" field.
func (m *HostMutation) ResetHidden() {
	m.hidden = nil
}

// SetCompetitionID sets the "competition_id" field.
func (m *HostMutation) SetCompetitionID(i int) {
	m.competition = &i
}

// CompetitionID returns the value of the "competition_id" field in the mutation.
func (m *HostMutation) CompetitionID() (r int, exists bool) {
	v := m.competition
	if v == nil {
		return
	}
	return *v, true
}

// OldCompetitionID returns the old "competition_id" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldCompetitionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompetitionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompetitionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompetitionID: %w", err)
	}
	return oldValue.CompetitionID, nil
}

// ResetCompetitionID resets all changes to the "competition_id" field.
func (m *HostMutation) ResetCompetitionID() {
	m.competition = nil
}

// SetTeamID sets the "team_id" field.
func (m *HostMutation) SetTeamID(i int) {
	m.team = &i
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *HostMutation) TeamID() (r int, exists bool) {
	v := m.team
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldTeamID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *HostMutation) ResetTeamID() {
	m.team = nil
}

// SetAddress sets the "address" field.
func (m *HostMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *HostMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *HostMutation) ResetAddress() {
	m.address = nil
}

// SetAddressListRange sets the "address_list_range" field.
func (m *HostMutation) SetAddressListRange(s string) {
	m.address_list_range = &s
}

// AddressListRange returns the value of the "address_list_range" field in the mutation.
func (m *HostMutation) AddressListRange() (r string, exists bool) {
	v := m.address_list_range
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressListRange returns the old "address_list_range" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldAddressListRange(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressListRange is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressListRange requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressListRange: %w", err)
	}
	return oldValue.AddressListRange, nil
}

// ResetAddressListRange resets all changes to the "address_list_range" field.
func (m *HostMutation) ResetAddressListRange() {
	m.address_list_range = nil
}

// SetEditable sets the "editable" field.
func (m *HostMutation) SetEditable(b bool) {
	m.editable = &b
}

// Editable returns the value of the "editable" field in the mutation.
func (m *HostMutation) Editable() (r bool, exists bool) {
	v := m.editable
	if v == nil {
		return
	}
	return *v, true
}

// OldEditable returns the old "editable" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldEditable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEditable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEditable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEditable: %w", err)
	}
	return oldValue.Editable, nil
}

// ResetEditable resets all changes to the "editable" field.
func (m *HostMutation) ResetEditable() {
	m.editable = nil
}

// ClearCompetition clears the "competition" edge to the Competition entity.
func (m *HostMutation) ClearCompetition() {
	m.clearedcompetition = true
}

// CompetitionCleared reports if the "competition" edge to the Competition entity was cleared.
func (m *HostMutation) CompetitionCleared() bool {
	return m.clearedcompetition
}

// CompetitionIDs returns the "competition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompetitionID instead. It exists only for internal usage by the builders.
func (m *HostMutation) CompetitionIDs() (ids []int) {
	if id := m.competition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompetition resets all changes to the "competition" edge.
func (m *HostMutation) ResetCompetition() {
	m.competition = nil
	m.clearedcompetition = false
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *HostMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *HostMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *HostMutation) TeamIDs() (ids []int) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *HostMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// AddServiceIDs adds the "services" edge to the Service entity by ids.
func (m *HostMutation) AddServiceIDs(ids ...int) {
	if m.services == nil {
		m.services = make(map[int]struct{})
	}
	for i := range ids {
		m.services[ids[i]] = struct{}{}
	}
}

// ClearServices clears the "services" edge to the Service entity.
func (m *HostMutation) ClearServices() {
	m.clearedservices = true
}

// ServicesCleared reports if the "services" edge to the Service entity was cleared.
func (m *HostMutation) ServicesCleared() bool {
	return m.clearedservices
}

// RemoveServiceIDs removes the "services" edge to the Service entity by IDs.
func (m *HostMutation) RemoveServiceIDs(ids ...int) {
	if m.removedservices == nil {
		m.removedservices = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.services, ids[i])
		m.removedservices[ids[i]] = struct{}{}
	}
}

// RemovedServices returns the removed IDs of the "services" edge to the Service entity.
func (m *HostMutation) RemovedServicesIDs() (ids []int) {
	for id := range m.removedservices {
		ids = append(ids, id)
	}
	return
}

// ServicesIDs returns the "services" edge IDs in the mutation.
func (m *HostMutation) ServicesIDs() (ids []int) {
	for id := range m.services {
		ids = append(ids, id)
	}
	return
}

// ResetServices resets all changes to the "services" edge.
func (m *HostMutation) ResetServices() {
	m.services = nil
	m.clearedservices = false
	m.removedservices = nil
}

// SetHostGroupID sets the "host_group" edge to the HostGroup entity by id.
func (m *HostMutation) SetHostGroupID(id int) {
	m.host_group = &id
}

// ClearHostGroup clears the "host_group" edge to the HostGroup entity.
func (m *HostMutation) ClearHostGroup() {
	m.clearedhost_group = true
}

// HostGroupCleared reports if the "host_group" edge to the HostGroup entity was cleared.
func (m *HostMutation) HostGroupCleared() bool {
	return m.clearedhost_group
}

// HostGroupID returns the "host_group" edge ID in the mutation.
func (m *HostMutation) HostGroupID() (id int, exists bool) {
	if m.host_group != nil {
		return *m.host_group, true
	}
	return
}

// HostGroupIDs returns the "host_group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostGroupID instead. It exists only for internal usage by the builders.
func (m *HostMutation) HostGroupIDs() (ids []int) {
	if id := m.host_group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHostGroup resets all changes to the "host_group" edge.
func (m *HostMutation) ResetHostGroup() {
	m.host_group = nil
	m.clearedhost_group = false
}

// Where appends a list predicates to the HostMutation builder.
func (m *HostMutation) Where(ps ...predicate.Host) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Host, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Host).
func (m *HostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HostMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, host.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, host.FieldUpdateTime)
	}
	if m.pause != nil {
		fields = append(fields, host.FieldPause)
	}
	if m.hidden != nil {
		fields = append(fields, host.FieldHidden)
	}
	if m.competition != nil {
		fields = append(fields, host.FieldCompetitionID)
	}
	if m.team != nil {
		fields = append(fields, host.FieldTeamID)
	}
	if m.address != nil {
		fields = append(fields, host.FieldAddress)
	}
	if m.address_list_range != nil {
		fields = append(fields, host.FieldAddressListRange)
	}
	if m.editable != nil {
		fields = append(fields, host.FieldEditable)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case host.FieldCreateTime:
		return m.CreateTime()
	case host.FieldUpdateTime:
		return m.UpdateTime()
	case host.FieldPause:
		return m.Pause()
	case host.FieldHidden:
		return m.Hidden()
	case host.FieldCompetitionID:
		return m.CompetitionID()
	case host.FieldTeamID:
		return m.TeamID()
	case host.FieldAddress:
		return m.Address()
	case host.FieldAddressListRange:
		return m.AddressListRange()
	case host.FieldEditable:
		return m.Editable()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case host.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case host.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case host.FieldPause:
		return m.OldPause(ctx)
	case host.FieldHidden:
		return m.OldHidden(ctx)
	case host.FieldCompetitionID:
		return m.OldCompetitionID(ctx)
	case host.FieldTeamID:
		return m.OldTeamID(ctx)
	case host.FieldAddress:
		return m.OldAddress(ctx)
	case host.FieldAddressListRange:
		return m.OldAddressListRange(ctx)
	case host.FieldEditable:
		return m.OldEditable(ctx)
	}
	return nil, fmt.Errorf("unknown Host field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case host.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case host.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case host.FieldPause:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPause(v)
		return nil
	case host.FieldHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHidden(v)
		return nil
	case host.FieldCompetitionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompetitionID(v)
		return nil
	case host.FieldTeamID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	case host.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case host.FieldAddressListRange:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressListRange(v)
		return nil
	case host.FieldEditable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEditable(v)
		return nil
	}
	return fmt.Errorf("unknown Host field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HostMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Host numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HostMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HostMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Host nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HostMutation) ResetField(name string) error {
	switch name {
	case host.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case host.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case host.FieldPause:
		m.ResetPause()
		return nil
	case host.FieldHidden:
		m.ResetHidden()
		return nil
	case host.FieldCompetitionID:
		m.ResetCompetitionID()
		return nil
	case host.FieldTeamID:
		m.ResetTeamID()
		return nil
	case host.FieldAddress:
		m.ResetAddress()
		return nil
	case host.FieldAddressListRange:
		m.ResetAddressListRange()
		return nil
	case host.FieldEditable:
		m.ResetEditable()
		return nil
	}
	return fmt.Errorf("unknown Host field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HostMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.competition != nil {
		edges = append(edges, host.EdgeCompetition)
	}
	if m.team != nil {
		edges = append(edges, host.EdgeTeam)
	}
	if m.services != nil {
		edges = append(edges, host.EdgeServices)
	}
	if m.host_group != nil {
		edges = append(edges, host.EdgeHostGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case host.EdgeCompetition:
		if id := m.competition; id != nil {
			return []ent.Value{*id}
		}
	case host.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	case host.EdgeServices:
		ids := make([]ent.Value, 0, len(m.services))
		for id := range m.services {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeHostGroup:
		if id := m.host_group; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedservices != nil {
		edges = append(edges, host.EdgeServices)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case host.EdgeServices:
		ids := make([]ent.Value, 0, len(m.removedservices))
		for id := range m.removedservices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcompetition {
		edges = append(edges, host.EdgeCompetition)
	}
	if m.clearedteam {
		edges = append(edges, host.EdgeTeam)
	}
	if m.clearedservices {
		edges = append(edges, host.EdgeServices)
	}
	if m.clearedhost_group {
		edges = append(edges, host.EdgeHostGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HostMutation) EdgeCleared(name string) bool {
	switch name {
	case host.EdgeCompetition:
		return m.clearedcompetition
	case host.EdgeTeam:
		return m.clearedteam
	case host.EdgeServices:
		return m.clearedservices
	case host.EdgeHostGroup:
		return m.clearedhost_group
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HostMutation) ClearEdge(name string) error {
	switch name {
	case host.EdgeCompetition:
		m.ClearCompetition()
		return nil
	case host.EdgeTeam:
		m.ClearTeam()
		return nil
	case host.EdgeHostGroup:
		m.ClearHostGroup()
		return nil
	}
	return fmt.Errorf("unknown Host unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HostMutation) ResetEdge(name string) error {
	switch name {
	case host.EdgeCompetition:
		m.ResetCompetition()
		return nil
	case host.EdgeTeam:
		m.ResetTeam()
		return nil
	case host.EdgeServices:
		m.ResetServices()
		return nil
	case host.EdgeHostGroup:
		m.ResetHostGroup()
		return nil
	}
	return fmt.Errorf("unknown Host edge %s", name)
}

// HostGroupMutation represents an operation that mutates the HostGroup nodes in the graph.
type HostGroupMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	create_time        *time.Time
	update_time        *time.Time
	pause              *bool
	hidden             *bool
	name               *string
	clearedFields      map[string]struct{}
	competition        *int
	clearedcompetition bool
	team               *int
	clearedteam        bool
	hosts              map[int]struct{}
	removedhosts       map[int]struct{}
	clearedhosts       bool
	done               bool
	oldValue           func(context.Context) (*HostGroup, error)
	predicates         []predicate.HostGroup
}

var _ ent.Mutation = (*HostGroupMutation)(nil)

// hostgroupOption allows management of the mutation configuration using functional options.
type hostgroupOption func(*HostGroupMutation)

// newHostGroupMutation creates new mutation for the HostGroup entity.
func newHostGroupMutation(c config, op Op, opts ...hostgroupOption) *HostGroupMutation {
	m := &HostGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeHostGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHostGroupID sets the ID field of the mutation.
func withHostGroupID(id int) hostgroupOption {
	return func(m *HostGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *HostGroup
		)
		m.oldValue = func(ctx context.Context) (*HostGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HostGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHostGroup sets the old HostGroup of the mutation.
func withHostGroup(node *HostGroup) hostgroupOption {
	return func(m *HostGroupMutation) {
		m.oldValue = func(context.Context) (*HostGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HostGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HostGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entities: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HostGroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HostGroupMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HostGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *HostGroupMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *HostGroupMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the HostGroup entity.
// If the HostGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostGroupMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *HostGroupMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *HostGroupMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *HostGroupMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the HostGroup entity.
// If the HostGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostGroupMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *HostGroupMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetPause sets the "pause" field.
func (m *HostGroupMutation) SetPause(b bool) {
	m.pause = &b
}

// Pause returns the value of the "pause" field in the mutation.
func (m *HostGroupMutation) Pause() (r bool, exists bool) {
	v := m.pause
	if v == nil {
		return
	}
	return *v, true
}

// OldPause returns the old "pause" field's value of the HostGroup entity.
// If the HostGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostGroupMutation) OldPause(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPause is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPause requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPause: %w", err)
	}
	return oldValue.Pause, nil
}

// ResetPause resets all changes to the "pause" field.
func (m *HostGroupMutation) ResetPause() {
	m.pause = nil
}

// SetHidden sets the "hidden" field.
func (m *HostGroupMutation) SetHidden(b bool) {
	m.hidden = &b
}

// Hidden returns the value of the "hidden" field in the mutation.
func (m *HostGroupMutation) Hidden() (r bool, exists bool) {
	v := m.hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldHidden returns the old "hidden" field's value of the HostGroup entity.
// If the HostGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostGroupMutation) OldHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHidden: %w", err)
	}
	return oldValue.Hidden, nil
}

// ResetHidden resets all changes to the "hidden" field.
func (m *HostGroupMutation) ResetHidden() {
	m.hidden = nil
}

// SetCompetitionID sets the "competition_id" field.
func (m *HostGroupMutation) SetCompetitionID(i int) {
	m.competition = &i
}

// CompetitionID returns the value of the "competition_id" field in the mutation.
func (m *HostGroupMutation) CompetitionID() (r int, exists bool) {
	v := m.competition
	if v == nil {
		return
	}
	return *v, true
}

// OldCompetitionID returns the old "competition_id" field's value of the HostGroup entity.
// If the HostGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostGroupMutation) OldCompetitionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompetitionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompetitionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompetitionID: %w", err)
	}
	return oldValue.CompetitionID, nil
}

// ResetCompetitionID resets all changes to the "competition_id" field.
func (m *HostGroupMutation) ResetCompetitionID() {
	m.competition = nil
}

// SetTeamID sets the "team_id" field.
func (m *HostGroupMutation) SetTeamID(i int) {
	m.team = &i
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *HostGroupMutation) TeamID() (r int, exists bool) {
	v := m.team
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the HostGroup entity.
// If the HostGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostGroupMutation) OldTeamID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *HostGroupMutation) ResetTeamID() {
	m.team = nil
}

// SetName sets the "name" field.
func (m *HostGroupMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HostGroupMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the HostGroup entity.
// If the HostGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostGroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *HostGroupMutation) ResetName() {
	m.name = nil
}

// ClearCompetition clears the "competition" edge to the Competition entity.
func (m *HostGroupMutation) ClearCompetition() {
	m.clearedcompetition = true
}

// CompetitionCleared reports if the "competition" edge to the Competition entity was cleared.
func (m *HostGroupMutation) CompetitionCleared() bool {
	return m.clearedcompetition
}

// CompetitionIDs returns the "competition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompetitionID instead. It exists only for internal usage by the builders.
func (m *HostGroupMutation) CompetitionIDs() (ids []int) {
	if id := m.competition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompetition resets all changes to the "competition" edge.
func (m *HostGroupMutation) ResetCompetition() {
	m.competition = nil
	m.clearedcompetition = false
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *HostGroupMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *HostGroupMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *HostGroupMutation) TeamIDs() (ids []int) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *HostGroupMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// AddHostIDs adds the "hosts" edge to the Host entity by ids.
func (m *HostGroupMutation) AddHostIDs(ids ...int) {
	if m.hosts == nil {
		m.hosts = make(map[int]struct{})
	}
	for i := range ids {
		m.hosts[ids[i]] = struct{}{}
	}
}

// ClearHosts clears the "hosts" edge to the Host entity.
func (m *HostGroupMutation) ClearHosts() {
	m.clearedhosts = true
}

// HostsCleared reports if the "hosts" edge to the Host entity was cleared.
func (m *HostGroupMutation) HostsCleared() bool {
	return m.clearedhosts
}

// RemoveHostIDs removes the "hosts" edge to the Host entity by IDs.
func (m *HostGroupMutation) RemoveHostIDs(ids ...int) {
	if m.removedhosts == nil {
		m.removedhosts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.hosts, ids[i])
		m.removedhosts[ids[i]] = struct{}{}
	}
}

// RemovedHosts returns the removed IDs of the "hosts" edge to the Host entity.
func (m *HostGroupMutation) RemovedHostsIDs() (ids []int) {
	for id := range m.removedhosts {
		ids = append(ids, id)
	}
	return
}

// HostsIDs returns the "hosts" edge IDs in the mutation.
func (m *HostGroupMutation) HostsIDs() (ids []int) {
	for id := range m.hosts {
		ids = append(ids, id)
	}
	return
}

// ResetHosts resets all changes to the "hosts" edge.
func (m *HostGroupMutation) ResetHosts() {
	m.hosts = nil
	m.clearedhosts = false
	m.removedhosts = nil
}

// Where appends a list predicates to the HostGroupMutation builder.
func (m *HostGroupMutation) Where(ps ...predicate.HostGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HostGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HostGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HostGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HostGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HostGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HostGroup).
func (m *HostGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HostGroupMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, hostgroup.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, hostgroup.FieldUpdateTime)
	}
	if m.pause != nil {
		fields = append(fields, hostgroup.FieldPause)
	}
	if m.hidden != nil {
		fields = append(fields, hostgroup.FieldHidden)
	}
	if m.competition != nil {
		fields = append(fields, hostgroup.FieldCompetitionID)
	}
	if m.team != nil {
		fields = append(fields, hostgroup.FieldTeamID)
	}
	if m.name != nil {
		fields = append(fields, hostgroup.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HostGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hostgroup.FieldCreateTime:
		return m.CreateTime()
	case hostgroup.FieldUpdateTime:
		return m.UpdateTime()
	case hostgroup.FieldPause:
		return m.Pause()
	case hostgroup.FieldHidden:
		return m.Hidden()
	case hostgroup.FieldCompetitionID:
		return m.CompetitionID()
	case hostgroup.FieldTeamID:
		return m.TeamID()
	case hostgroup.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HostGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hostgroup.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case hostgroup.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case hostgroup.FieldPause:
		return m.OldPause(ctx)
	case hostgroup.FieldHidden:
		return m.OldHidden(ctx)
	case hostgroup.FieldCompetitionID:
		return m.OldCompetitionID(ctx)
	case hostgroup.FieldTeamID:
		return m.OldTeamID(ctx)
	case hostgroup.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown HostGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hostgroup.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case hostgroup.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case hostgroup.FieldPause:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPause(v)
		return nil
	case hostgroup.FieldHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHidden(v)
		return nil
	case hostgroup.FieldCompetitionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompetitionID(v)
		return nil
	case hostgroup.FieldTeamID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	case hostgroup.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown HostGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HostGroupMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HostGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HostGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HostGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HostGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HostGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown HostGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HostGroupMutation) ResetField(name string) error {
	switch name {
	case hostgroup.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case hostgroup.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case hostgroup.FieldPause:
		m.ResetPause()
		return nil
	case hostgroup.FieldHidden:
		m.ResetHidden()
		return nil
	case hostgroup.FieldCompetitionID:
		m.ResetCompetitionID()
		return nil
	case hostgroup.FieldTeamID:
		m.ResetTeamID()
		return nil
	case hostgroup.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown HostGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HostGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.competition != nil {
		edges = append(edges, hostgroup.EdgeCompetition)
	}
	if m.team != nil {
		edges = append(edges, hostgroup.EdgeTeam)
	}
	if m.hosts != nil {
		edges = append(edges, hostgroup.EdgeHosts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HostGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hostgroup.EdgeCompetition:
		if id := m.competition; id != nil {
			return []ent.Value{*id}
		}
	case hostgroup.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	case hostgroup.EdgeHosts:
		ids := make([]ent.Value, 0, len(m.hosts))
		for id := range m.hosts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HostGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedhosts != nil {
		edges = append(edges, hostgroup.EdgeHosts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HostGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hostgroup.EdgeHosts:
		ids := make([]ent.Value, 0, len(m.removedhosts))
		for id := range m.removedhosts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HostGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcompetition {
		edges = append(edges, hostgroup.EdgeCompetition)
	}
	if m.clearedteam {
		edges = append(edges, hostgroup.EdgeTeam)
	}
	if m.clearedhosts {
		edges = append(edges, hostgroup.EdgeHosts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HostGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case hostgroup.EdgeCompetition:
		return m.clearedcompetition
	case hostgroup.EdgeTeam:
		return m.clearedteam
	case hostgroup.EdgeHosts:
		return m.clearedhosts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HostGroupMutation) ClearEdge(name string) error {
	switch name {
	case hostgroup.EdgeCompetition:
		m.ClearCompetition()
		return nil
	case hostgroup.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown HostGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HostGroupMutation) ResetEdge(name string) error {
	switch name {
	case hostgroup.EdgeCompetition:
		m.ResetCompetition()
		return nil
	case hostgroup.EdgeTeam:
		m.ResetTeam()
		return nil
	case hostgroup.EdgeHosts:
		m.ResetHosts()
		return nil
	}
	return fmt.Errorf("unknown HostGroup edge %s", name)
}

// PropertyMutation represents an operation that mutates the Property nodes in the graph.
type PropertyMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	create_time        *time.Time
	update_time        *time.Time
	key                *string
	value              *string
	status             *property.Status
	clearedFields      map[string]struct{}
	competition        *int
	clearedcompetition bool
	team               *int
	clearedteam        bool
	services           *int
	clearedservices    bool
	done               bool
	oldValue           func(context.Context) (*Property, error)
	predicates         []predicate.Property
}

var _ ent.Mutation = (*PropertyMutation)(nil)

// propertyOption allows management of the mutation configuration using functional options.
type propertyOption func(*PropertyMutation)

// newPropertyMutation creates new mutation for the Property entity.
func newPropertyMutation(c config, op Op, opts ...propertyOption) *PropertyMutation {
	m := &PropertyMutation{
		config:        c,
		op:            op,
		typ:           TypeProperty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPropertyID sets the ID field of the mutation.
func withPropertyID(id int) propertyOption {
	return func(m *PropertyMutation) {
		var (
			err   error
			once  sync.Once
			value *Property
		)
		m.oldValue = func(ctx context.Context) (*Property, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Property.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProperty sets the old Property of the mutation.
func withProperty(node *Property) propertyOption {
	return func(m *PropertyMutation) {
		m.oldValue = func(context.Context) (*Property, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PropertyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PropertyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entities: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PropertyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PropertyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Property.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *PropertyMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PropertyMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PropertyMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *PropertyMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PropertyMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PropertyMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetCompetitionID sets the "competition_id" field.
func (m *PropertyMutation) SetCompetitionID(i int) {
	m.competition = &i
}

// CompetitionID returns the value of the "competition_id" field in the mutation.
func (m *PropertyMutation) CompetitionID() (r int, exists bool) {
	v := m.competition
	if v == nil {
		return
	}
	return *v, true
}

// OldCompetitionID returns the old "competition_id" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldCompetitionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompetitionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompetitionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompetitionID: %w", err)
	}
	return oldValue.CompetitionID, nil
}

// ResetCompetitionID resets all changes to the "competition_id" field.
func (m *PropertyMutation) ResetCompetitionID() {
	m.competition = nil
}

// SetTeamID sets the "team_id" field.
func (m *PropertyMutation) SetTeamID(i int) {
	m.team = &i
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *PropertyMutation) TeamID() (r int, exists bool) {
	v := m.team
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldTeamID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *PropertyMutation) ResetTeamID() {
	m.team = nil
}

// SetKey sets the "key" field.
func (m *PropertyMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *PropertyMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *PropertyMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *PropertyMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *PropertyMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *PropertyMutation) ResetValue() {
	m.value = nil
}

// SetStatus sets the "status" field.
func (m *PropertyMutation) SetStatus(pr property.Status) {
	m.status = &pr
}

// Status returns the value of the "status" field in the mutation.
func (m *PropertyMutation) Status() (r property.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldStatus(ctx context.Context) (v property.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PropertyMutation) ResetStatus() {
	m.status = nil
}

// ClearCompetition clears the "competition" edge to the Competition entity.
func (m *PropertyMutation) ClearCompetition() {
	m.clearedcompetition = true
}

// CompetitionCleared reports if the "competition" edge to the Competition entity was cleared.
func (m *PropertyMutation) CompetitionCleared() bool {
	return m.clearedcompetition
}

// CompetitionIDs returns the "competition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompetitionID instead. It exists only for internal usage by the builders.
func (m *PropertyMutation) CompetitionIDs() (ids []int) {
	if id := m.competition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompetition resets all changes to the "competition" edge.
func (m *PropertyMutation) ResetCompetition() {
	m.competition = nil
	m.clearedcompetition = false
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *PropertyMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *PropertyMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *PropertyMutation) TeamIDs() (ids []int) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *PropertyMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// SetServicesID sets the "services" edge to the Service entity by id.
func (m *PropertyMutation) SetServicesID(id int) {
	m.services = &id
}

// ClearServices clears the "services" edge to the Service entity.
func (m *PropertyMutation) ClearServices() {
	m.clearedservices = true
}

// ServicesCleared reports if the "services" edge to the Service entity was cleared.
func (m *PropertyMutation) ServicesCleared() bool {
	return m.clearedservices
}

// ServicesID returns the "services" edge ID in the mutation.
func (m *PropertyMutation) ServicesID() (id int, exists bool) {
	if m.services != nil {
		return *m.services, true
	}
	return
}

// ServicesIDs returns the "services" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServicesID instead. It exists only for internal usage by the builders.
func (m *PropertyMutation) ServicesIDs() (ids []int) {
	if id := m.services; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServices resets all changes to the "services" edge.
func (m *PropertyMutation) ResetServices() {
	m.services = nil
	m.clearedservices = false
}

// Where appends a list predicates to the PropertyMutation builder.
func (m *PropertyMutation) Where(ps ...predicate.Property) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PropertyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PropertyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Property, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PropertyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PropertyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Property).
func (m *PropertyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PropertyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, property.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, property.FieldUpdateTime)
	}
	if m.competition != nil {
		fields = append(fields, property.FieldCompetitionID)
	}
	if m.team != nil {
		fields = append(fields, property.FieldTeamID)
	}
	if m.key != nil {
		fields = append(fields, property.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, property.FieldValue)
	}
	if m.status != nil {
		fields = append(fields, property.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PropertyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case property.FieldCreateTime:
		return m.CreateTime()
	case property.FieldUpdateTime:
		return m.UpdateTime()
	case property.FieldCompetitionID:
		return m.CompetitionID()
	case property.FieldTeamID:
		return m.TeamID()
	case property.FieldKey:
		return m.Key()
	case property.FieldValue:
		return m.Value()
	case property.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PropertyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case property.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case property.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case property.FieldCompetitionID:
		return m.OldCompetitionID(ctx)
	case property.FieldTeamID:
		return m.OldTeamID(ctx)
	case property.FieldKey:
		return m.OldKey(ctx)
	case property.FieldValue:
		return m.OldValue(ctx)
	case property.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Property field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PropertyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case property.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case property.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case property.FieldCompetitionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompetitionID(v)
		return nil
	case property.FieldTeamID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	case property.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case property.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case property.FieldStatus:
		v, ok := value.(property.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Property field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PropertyMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PropertyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PropertyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Property numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PropertyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PropertyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PropertyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Property nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PropertyMutation) ResetField(name string) error {
	switch name {
	case property.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case property.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case property.FieldCompetitionID:
		m.ResetCompetitionID()
		return nil
	case property.FieldTeamID:
		m.ResetTeamID()
		return nil
	case property.FieldKey:
		m.ResetKey()
		return nil
	case property.FieldValue:
		m.ResetValue()
		return nil
	case property.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Property field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PropertyMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.competition != nil {
		edges = append(edges, property.EdgeCompetition)
	}
	if m.team != nil {
		edges = append(edges, property.EdgeTeam)
	}
	if m.services != nil {
		edges = append(edges, property.EdgeServices)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PropertyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case property.EdgeCompetition:
		if id := m.competition; id != nil {
			return []ent.Value{*id}
		}
	case property.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	case property.EdgeServices:
		if id := m.services; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PropertyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PropertyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PropertyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcompetition {
		edges = append(edges, property.EdgeCompetition)
	}
	if m.clearedteam {
		edges = append(edges, property.EdgeTeam)
	}
	if m.clearedservices {
		edges = append(edges, property.EdgeServices)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PropertyMutation) EdgeCleared(name string) bool {
	switch name {
	case property.EdgeCompetition:
		return m.clearedcompetition
	case property.EdgeTeam:
		return m.clearedteam
	case property.EdgeServices:
		return m.clearedservices
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PropertyMutation) ClearEdge(name string) error {
	switch name {
	case property.EdgeCompetition:
		m.ClearCompetition()
		return nil
	case property.EdgeTeam:
		m.ClearTeam()
		return nil
	case property.EdgeServices:
		m.ClearServices()
		return nil
	}
	return fmt.Errorf("unknown Property unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PropertyMutation) ResetEdge(name string) error {
	switch name {
	case property.EdgeCompetition:
		m.ResetCompetition()
		return nil
	case property.EdgeTeam:
		m.ResetTeam()
		return nil
	case property.EdgeServices:
		m.ResetServices()
		return nil
	}
	return fmt.Errorf("unknown Property edge %s", name)
}

// RoundMutation represents an operation that mutates the Round nodes in the graph.
type RoundMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	create_time        *time.Time
	update_time        *time.Time
	round_number       *int
	addround_number    *int
	note               *string
	err                *string
	started_at         *time.Time
	finished_at        *time.Time
	clearedFields      map[string]struct{}
	competition        *int
	clearedcompetition bool
	checks             map[int]struct{}
	removedchecks      map[int]struct{}
	clearedchecks      bool
	done               bool
	oldValue           func(context.Context) (*Round, error)
	predicates         []predicate.Round
}

var _ ent.Mutation = (*RoundMutation)(nil)

// roundOption allows management of the mutation configuration using functional options.
type roundOption func(*RoundMutation)

// newRoundMutation creates new mutation for the Round entity.
func newRoundMutation(c config, op Op, opts ...roundOption) *RoundMutation {
	m := &RoundMutation{
		config:        c,
		op:            op,
		typ:           TypeRound,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoundID sets the ID field of the mutation.
func withRoundID(id int) roundOption {
	return func(m *RoundMutation) {
		var (
			err   error
			once  sync.Once
			value *Round
		)
		m.oldValue = func(ctx context.Context) (*Round, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Round.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRound sets the old Round of the mutation.
func withRound(node *Round) roundOption {
	return func(m *RoundMutation) {
		m.oldValue = func(context.Context) (*Round, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoundMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoundMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entities: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoundMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoundMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Round.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *RoundMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *RoundMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *RoundMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *RoundMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *RoundMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *RoundMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetCompetitionID sets the "competition_id" field.
func (m *RoundMutation) SetCompetitionID(i int) {
	m.competition = &i
}

// CompetitionID returns the value of the "competition_id" field in the mutation.
func (m *RoundMutation) CompetitionID() (r int, exists bool) {
	v := m.competition
	if v == nil {
		return
	}
	return *v, true
}

// OldCompetitionID returns the old "competition_id" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldCompetitionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompetitionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompetitionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompetitionID: %w", err)
	}
	return oldValue.CompetitionID, nil
}

// ResetCompetitionID resets all changes to the "competition_id" field.
func (m *RoundMutation) ResetCompetitionID() {
	m.competition = nil
}

// SetRoundNumber sets the "round_number" field.
func (m *RoundMutation) SetRoundNumber(i int) {
	m.round_number = &i
	m.addround_number = nil
}

// RoundNumber returns the value of the "round_number" field in the mutation.
func (m *RoundMutation) RoundNumber() (r int, exists bool) {
	v := m.round_number
	if v == nil {
		return
	}
	return *v, true
}

// OldRoundNumber returns the old "round_number" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldRoundNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoundNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoundNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoundNumber: %w", err)
	}
	return oldValue.RoundNumber, nil
}

// AddRoundNumber adds i to the "round_number" field.
func (m *RoundMutation) AddRoundNumber(i int) {
	if m.addround_number != nil {
		*m.addround_number += i
	} else {
		m.addround_number = &i
	}
}

// AddedRoundNumber returns the value that was added to the "round_number" field in this mutation.
func (m *RoundMutation) AddedRoundNumber() (r int, exists bool) {
	v := m.addround_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoundNumber resets all changes to the "round_number" field.
func (m *RoundMutation) ResetRoundNumber() {
	m.round_number = nil
	m.addround_number = nil
}

// SetNote sets the "note" field.
func (m *RoundMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *RoundMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ResetNote resets all changes to the "note" field.
func (m *RoundMutation) ResetNote() {
	m.note = nil
}

// SetErr sets the "err" field.
func (m *RoundMutation) SetErr(s string) {
	m.err = &s
}

// Err returns the value of the "err" field in the mutation.
func (m *RoundMutation) Err() (r string, exists bool) {
	v := m.err
	if v == nil {
		return
	}
	return *v, true
}

// OldErr returns the old "err" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldErr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErr: %w", err)
	}
	return oldValue.Err, nil
}

// ResetErr resets all changes to the "err" field.
func (m *RoundMutation) ResetErr() {
	m.err = nil
}

// SetStartedAt sets the "started_at" field.
func (m *RoundMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *RoundMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *RoundMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetFinishedAt sets the "finished_at" field.
func (m *RoundMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *RoundMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldFinishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *RoundMutation) ResetFinishedAt() {
	m.finished_at = nil
}

// ClearCompetition clears the "competition" edge to the Competition entity.
func (m *RoundMutation) ClearCompetition() {
	m.clearedcompetition = true
}

// CompetitionCleared reports if the "competition" edge to the Competition entity was cleared.
func (m *RoundMutation) CompetitionCleared() bool {
	return m.clearedcompetition
}

// CompetitionIDs returns the "competition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompetitionID instead. It exists only for internal usage by the builders.
func (m *RoundMutation) CompetitionIDs() (ids []int) {
	if id := m.competition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompetition resets all changes to the "competition" edge.
func (m *RoundMutation) ResetCompetition() {
	m.competition = nil
	m.clearedcompetition = false
}

// AddCheckIDs adds the "checks" edge to the Check entity by ids.
func (m *RoundMutation) AddCheckIDs(ids ...int) {
	if m.checks == nil {
		m.checks = make(map[int]struct{})
	}
	for i := range ids {
		m.checks[ids[i]] = struct{}{}
	}
}

// ClearChecks clears the "checks" edge to the Check entity.
func (m *RoundMutation) ClearChecks() {
	m.clearedchecks = true
}

// ChecksCleared reports if the "checks" edge to the Check entity was cleared.
func (m *RoundMutation) ChecksCleared() bool {
	return m.clearedchecks
}

// RemoveCheckIDs removes the "checks" edge to the Check entity by IDs.
func (m *RoundMutation) RemoveCheckIDs(ids ...int) {
	if m.removedchecks == nil {
		m.removedchecks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.checks, ids[i])
		m.removedchecks[ids[i]] = struct{}{}
	}
}

// RemovedChecks returns the removed IDs of the "checks" edge to the Check entity.
func (m *RoundMutation) RemovedChecksIDs() (ids []int) {
	for id := range m.removedchecks {
		ids = append(ids, id)
	}
	return
}

// ChecksIDs returns the "checks" edge IDs in the mutation.
func (m *RoundMutation) ChecksIDs() (ids []int) {
	for id := range m.checks {
		ids = append(ids, id)
	}
	return
}

// ResetChecks resets all changes to the "checks" edge.
func (m *RoundMutation) ResetChecks() {
	m.checks = nil
	m.clearedchecks = false
	m.removedchecks = nil
}

// Where appends a list predicates to the RoundMutation builder.
func (m *RoundMutation) Where(ps ...predicate.Round) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoundMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoundMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Round, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoundMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoundMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Round).
func (m *RoundMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoundMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, round.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, round.FieldUpdateTime)
	}
	if m.competition != nil {
		fields = append(fields, round.FieldCompetitionID)
	}
	if m.round_number != nil {
		fields = append(fields, round.FieldRoundNumber)
	}
	if m.note != nil {
		fields = append(fields, round.FieldNote)
	}
	if m.err != nil {
		fields = append(fields, round.FieldErr)
	}
	if m.started_at != nil {
		fields = append(fields, round.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, round.FieldFinishedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoundMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case round.FieldCreateTime:
		return m.CreateTime()
	case round.FieldUpdateTime:
		return m.UpdateTime()
	case round.FieldCompetitionID:
		return m.CompetitionID()
	case round.FieldRoundNumber:
		return m.RoundNumber()
	case round.FieldNote:
		return m.Note()
	case round.FieldErr:
		return m.Err()
	case round.FieldStartedAt:
		return m.StartedAt()
	case round.FieldFinishedAt:
		return m.FinishedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoundMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case round.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case round.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case round.FieldCompetitionID:
		return m.OldCompetitionID(ctx)
	case round.FieldRoundNumber:
		return m.OldRoundNumber(ctx)
	case round.FieldNote:
		return m.OldNote(ctx)
	case round.FieldErr:
		return m.OldErr(ctx)
	case round.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case round.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Round field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoundMutation) SetField(name string, value ent.Value) error {
	switch name {
	case round.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case round.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case round.FieldCompetitionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompetitionID(v)
		return nil
	case round.FieldRoundNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoundNumber(v)
		return nil
	case round.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case round.FieldErr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErr(v)
		return nil
	case round.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case round.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Round field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoundMutation) AddedFields() []string {
	var fields []string
	if m.addround_number != nil {
		fields = append(fields, round.FieldRoundNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoundMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case round.FieldRoundNumber:
		return m.AddedRoundNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoundMutation) AddField(name string, value ent.Value) error {
	switch name {
	case round.FieldRoundNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoundNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Round numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoundMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoundMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoundMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Round nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoundMutation) ResetField(name string) error {
	switch name {
	case round.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case round.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case round.FieldCompetitionID:
		m.ResetCompetitionID()
		return nil
	case round.FieldRoundNumber:
		m.ResetRoundNumber()
		return nil
	case round.FieldNote:
		m.ResetNote()
		return nil
	case round.FieldErr:
		m.ResetErr()
		return nil
	case round.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case round.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown Round field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoundMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.competition != nil {
		edges = append(edges, round.EdgeCompetition)
	}
	if m.checks != nil {
		edges = append(edges, round.EdgeChecks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoundMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case round.EdgeCompetition:
		if id := m.competition; id != nil {
			return []ent.Value{*id}
		}
	case round.EdgeChecks:
		ids := make([]ent.Value, 0, len(m.checks))
		for id := range m.checks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoundMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedchecks != nil {
		edges = append(edges, round.EdgeChecks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoundMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case round.EdgeChecks:
		ids := make([]ent.Value, 0, len(m.removedchecks))
		for id := range m.removedchecks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoundMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcompetition {
		edges = append(edges, round.EdgeCompetition)
	}
	if m.clearedchecks {
		edges = append(edges, round.EdgeChecks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoundMutation) EdgeCleared(name string) bool {
	switch name {
	case round.EdgeCompetition:
		return m.clearedcompetition
	case round.EdgeChecks:
		return m.clearedchecks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoundMutation) ClearEdge(name string) error {
	switch name {
	case round.EdgeCompetition:
		m.ClearCompetition()
		return nil
	}
	return fmt.Errorf("unknown Round unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoundMutation) ResetEdge(name string) error {
	switch name {
	case round.EdgeCompetition:
		m.ResetCompetition()
		return nil
	case round.EdgeChecks:
		m.ResetChecks()
		return nil
	}
	return fmt.Errorf("unknown Round edge %s", name)
}

// ServiceMutation represents an operation that mutates the Service nodes in the graph.
type ServiceMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	create_time        *time.Time
	update_time        *time.Time
	pause              *bool
	hidden             *bool
	name               *string
	display_name       *string
	weight             *int
	addweight          *int
	point_boost        *int
	addpoint_boost     *int
	round_units        *int
	addround_units     *int
	round_delay        *int
	addround_delay     *int
	clearedFields      map[string]struct{}
	competition        *int
	clearedcompetition bool
	team               *int
	clearedteam        bool
	hosts              *int
	clearedhosts       bool
	checks             map[int]struct{}
	removedchecks      map[int]struct{}
	clearedchecks      bool
	properties         map[int]struct{}
	removedproperties  map[int]struct{}
	clearedproperties  bool
	done               bool
	oldValue           func(context.Context) (*Service, error)
	predicates         []predicate.Service
}

var _ ent.Mutation = (*ServiceMutation)(nil)

// serviceOption allows management of the mutation configuration using functional options.
type serviceOption func(*ServiceMutation)

// newServiceMutation creates new mutation for the Service entity.
func newServiceMutation(c config, op Op, opts ...serviceOption) *ServiceMutation {
	m := &ServiceMutation{
		config:        c,
		op:            op,
		typ:           TypeService,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceID sets the ID field of the mutation.
func withServiceID(id int) serviceOption {
	return func(m *ServiceMutation) {
		var (
			err   error
			once  sync.Once
			value *Service
		)
		m.oldValue = func(ctx context.Context) (*Service, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Service.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withService sets the old Service of the mutation.
func withService(node *Service) serviceOption {
	return func(m *ServiceMutation) {
		m.oldValue = func(context.Context) (*Service, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entities: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Service.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ServiceMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ServiceMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ServiceMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ServiceMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ServiceMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ServiceMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetPause sets the "pause" field.
func (m *ServiceMutation) SetPause(b bool) {
	m.pause = &b
}

// Pause returns the value of the "pause" field in the mutation.
func (m *ServiceMutation) Pause() (r bool, exists bool) {
	v := m.pause
	if v == nil {
		return
	}
	return *v, true
}

// OldPause returns the old "pause" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldPause(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPause is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPause requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPause: %w", err)
	}
	return oldValue.Pause, nil
}

// ResetPause resets all changes to the "pause" field.
func (m *ServiceMutation) ResetPause() {
	m.pause = nil
}

// SetHidden sets the "hidden" field.
func (m *ServiceMutation) SetHidden(b bool) {
	m.hidden = &b
}

// Hidden returns the value of the "hidden" field in the mutation.
func (m *ServiceMutation) Hidden() (r bool, exists bool) {
	v := m.hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldHidden returns the old "hidden" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHidden: %w", err)
	}
	return oldValue.Hidden, nil
}

// ResetHidden resets all changes to the "hidden" field.
func (m *ServiceMutation) ResetHidden() {
	m.hidden = nil
}

// SetCompetitionID sets the "competition_id" field.
func (m *ServiceMutation) SetCompetitionID(i int) {
	m.competition = &i
}

// CompetitionID returns the value of the "competition_id" field in the mutation.
func (m *ServiceMutation) CompetitionID() (r int, exists bool) {
	v := m.competition
	if v == nil {
		return
	}
	return *v, true
}

// OldCompetitionID returns the old "competition_id" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldCompetitionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompetitionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompetitionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompetitionID: %w", err)
	}
	return oldValue.CompetitionID, nil
}

// ResetCompetitionID resets all changes to the "competition_id" field.
func (m *ServiceMutation) ResetCompetitionID() {
	m.competition = nil
}

// SetTeamID sets the "team_id" field.
func (m *ServiceMutation) SetTeamID(i int) {
	m.team = &i
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *ServiceMutation) TeamID() (r int, exists bool) {
	v := m.team
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldTeamID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *ServiceMutation) ResetTeamID() {
	m.team = nil
}

// SetName sets the "name" field.
func (m *ServiceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ServiceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ServiceMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *ServiceMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ServiceMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ServiceMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetWeight sets the "weight" field.
func (m *ServiceMutation) SetWeight(i int) {
	m.weight = &i
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *ServiceMutation) Weight() (r int, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds i to the "weight" field.
func (m *ServiceMutation) AddWeight(i int) {
	if m.addweight != nil {
		*m.addweight += i
	} else {
		m.addweight = &i
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *ServiceMutation) AddedWeight() (r int, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight resets all changes to the "weight" field.
func (m *ServiceMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// SetPointBoost sets the "point_boost" field.
func (m *ServiceMutation) SetPointBoost(i int) {
	m.point_boost = &i
	m.addpoint_boost = nil
}

// PointBoost returns the value of the "point_boost" field in the mutation.
func (m *ServiceMutation) PointBoost() (r int, exists bool) {
	v := m.point_boost
	if v == nil {
		return
	}
	return *v, true
}

// OldPointBoost returns the old "point_boost" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldPointBoost(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPointBoost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPointBoost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPointBoost: %w", err)
	}
	return oldValue.PointBoost, nil
}

// AddPointBoost adds i to the "point_boost" field.
func (m *ServiceMutation) AddPointBoost(i int) {
	if m.addpoint_boost != nil {
		*m.addpoint_boost += i
	} else {
		m.addpoint_boost = &i
	}
}

// AddedPointBoost returns the value that was added to the "point_boost" field in this mutation.
func (m *ServiceMutation) AddedPointBoost() (r int, exists bool) {
	v := m.addpoint_boost
	if v == nil {
		return
	}
	return *v, true
}

// ResetPointBoost resets all changes to the "point_boost" field.
func (m *ServiceMutation) ResetPointBoost() {
	m.point_boost = nil
	m.addpoint_boost = nil
}

// SetRoundUnits sets the "round_units" field.
func (m *ServiceMutation) SetRoundUnits(i int) {
	m.round_units = &i
	m.addround_units = nil
}

// RoundUnits returns the value of the "round_units" field in the mutation.
func (m *ServiceMutation) RoundUnits() (r int, exists bool) {
	v := m.round_units
	if v == nil {
		return
	}
	return *v, true
}

// OldRoundUnits returns the old "round_units" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldRoundUnits(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoundUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoundUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoundUnits: %w", err)
	}
	return oldValue.RoundUnits, nil
}

// AddRoundUnits adds i to the "round_units" field.
func (m *ServiceMutation) AddRoundUnits(i int) {
	if m.addround_units != nil {
		*m.addround_units += i
	} else {
		m.addround_units = &i
	}
}

// AddedRoundUnits returns the value that was added to the "round_units" field in this mutation.
func (m *ServiceMutation) AddedRoundUnits() (r int, exists bool) {
	v := m.addround_units
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoundUnits resets all changes to the "round_units" field.
func (m *ServiceMutation) ResetRoundUnits() {
	m.round_units = nil
	m.addround_units = nil
}

// SetRoundDelay sets the "round_delay" field.
func (m *ServiceMutation) SetRoundDelay(i int) {
	m.round_delay = &i
	m.addround_delay = nil
}

// RoundDelay returns the value of the "round_delay" field in the mutation.
func (m *ServiceMutation) RoundDelay() (r int, exists bool) {
	v := m.round_delay
	if v == nil {
		return
	}
	return *v, true
}

// OldRoundDelay returns the old "round_delay" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldRoundDelay(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoundDelay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoundDelay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoundDelay: %w", err)
	}
	return oldValue.RoundDelay, nil
}

// AddRoundDelay adds i to the "round_delay" field.
func (m *ServiceMutation) AddRoundDelay(i int) {
	if m.addround_delay != nil {
		*m.addround_delay += i
	} else {
		m.addround_delay = &i
	}
}

// AddedRoundDelay returns the value that was added to the "round_delay" field in this mutation.
func (m *ServiceMutation) AddedRoundDelay() (r int, exists bool) {
	v := m.addround_delay
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoundDelay resets all changes to the "round_delay" field.
func (m *ServiceMutation) ResetRoundDelay() {
	m.round_delay = nil
	m.addround_delay = nil
}

// ClearCompetition clears the "competition" edge to the Competition entity.
func (m *ServiceMutation) ClearCompetition() {
	m.clearedcompetition = true
}

// CompetitionCleared reports if the "competition" edge to the Competition entity was cleared.
func (m *ServiceMutation) CompetitionCleared() bool {
	return m.clearedcompetition
}

// CompetitionIDs returns the "competition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompetitionID instead. It exists only for internal usage by the builders.
func (m *ServiceMutation) CompetitionIDs() (ids []int) {
	if id := m.competition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompetition resets all changes to the "competition" edge.
func (m *ServiceMutation) ResetCompetition() {
	m.competition = nil
	m.clearedcompetition = false
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *ServiceMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *ServiceMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *ServiceMutation) TeamIDs() (ids []int) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *ServiceMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// SetHostsID sets the "hosts" edge to the Host entity by id.
func (m *ServiceMutation) SetHostsID(id int) {
	m.hosts = &id
}

// ClearHosts clears the "hosts" edge to the Host entity.
func (m *ServiceMutation) ClearHosts() {
	m.clearedhosts = true
}

// HostsCleared reports if the "hosts" edge to the Host entity was cleared.
func (m *ServiceMutation) HostsCleared() bool {
	return m.clearedhosts
}

// HostsID returns the "hosts" edge ID in the mutation.
func (m *ServiceMutation) HostsID() (id int, exists bool) {
	if m.hosts != nil {
		return *m.hosts, true
	}
	return
}

// HostsIDs returns the "hosts" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostsID instead. It exists only for internal usage by the builders.
func (m *ServiceMutation) HostsIDs() (ids []int) {
	if id := m.hosts; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHosts resets all changes to the "hosts" edge.
func (m *ServiceMutation) ResetHosts() {
	m.hosts = nil
	m.clearedhosts = false
}

// AddCheckIDs adds the "checks" edge to the Check entity by ids.
func (m *ServiceMutation) AddCheckIDs(ids ...int) {
	if m.checks == nil {
		m.checks = make(map[int]struct{})
	}
	for i := range ids {
		m.checks[ids[i]] = struct{}{}
	}
}

// ClearChecks clears the "checks" edge to the Check entity.
func (m *ServiceMutation) ClearChecks() {
	m.clearedchecks = true
}

// ChecksCleared reports if the "checks" edge to the Check entity was cleared.
func (m *ServiceMutation) ChecksCleared() bool {
	return m.clearedchecks
}

// RemoveCheckIDs removes the "checks" edge to the Check entity by IDs.
func (m *ServiceMutation) RemoveCheckIDs(ids ...int) {
	if m.removedchecks == nil {
		m.removedchecks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.checks, ids[i])
		m.removedchecks[ids[i]] = struct{}{}
	}
}

// RemovedChecks returns the removed IDs of the "checks" edge to the Check entity.
func (m *ServiceMutation) RemovedChecksIDs() (ids []int) {
	for id := range m.removedchecks {
		ids = append(ids, id)
	}
	return
}

// ChecksIDs returns the "checks" edge IDs in the mutation.
func (m *ServiceMutation) ChecksIDs() (ids []int) {
	for id := range m.checks {
		ids = append(ids, id)
	}
	return
}

// ResetChecks resets all changes to the "checks" edge.
func (m *ServiceMutation) ResetChecks() {
	m.checks = nil
	m.clearedchecks = false
	m.removedchecks = nil
}

// AddPropertyIDs adds the "properties" edge to the Property entity by ids.
func (m *ServiceMutation) AddPropertyIDs(ids ...int) {
	if m.properties == nil {
		m.properties = make(map[int]struct{})
	}
	for i := range ids {
		m.properties[ids[i]] = struct{}{}
	}
}

// ClearProperties clears the "properties" edge to the Property entity.
func (m *ServiceMutation) ClearProperties() {
	m.clearedproperties = true
}

// PropertiesCleared reports if the "properties" edge to the Property entity was cleared.
func (m *ServiceMutation) PropertiesCleared() bool {
	return m.clearedproperties
}

// RemovePropertyIDs removes the "properties" edge to the Property entity by IDs.
func (m *ServiceMutation) RemovePropertyIDs(ids ...int) {
	if m.removedproperties == nil {
		m.removedproperties = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.properties, ids[i])
		m.removedproperties[ids[i]] = struct{}{}
	}
}

// RemovedProperties returns the removed IDs of the "properties" edge to the Property entity.
func (m *ServiceMutation) RemovedPropertiesIDs() (ids []int) {
	for id := range m.removedproperties {
		ids = append(ids, id)
	}
	return
}

// PropertiesIDs returns the "properties" edge IDs in the mutation.
func (m *ServiceMutation) PropertiesIDs() (ids []int) {
	for id := range m.properties {
		ids = append(ids, id)
	}
	return
}

// ResetProperties resets all changes to the "properties" edge.
func (m *ServiceMutation) ResetProperties() {
	m.properties = nil
	m.clearedproperties = false
	m.removedproperties = nil
}

// Where appends a list predicates to the ServiceMutation builder.
func (m *ServiceMutation) Where(ps ...predicate.Service) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Service, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Service).
func (m *ServiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.create_time != nil {
		fields = append(fields, service.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, service.FieldUpdateTime)
	}
	if m.pause != nil {
		fields = append(fields, service.FieldPause)
	}
	if m.hidden != nil {
		fields = append(fields, service.FieldHidden)
	}
	if m.competition != nil {
		fields = append(fields, service.FieldCompetitionID)
	}
	if m.team != nil {
		fields = append(fields, service.FieldTeamID)
	}
	if m.name != nil {
		fields = append(fields, service.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, service.FieldDisplayName)
	}
	if m.weight != nil {
		fields = append(fields, service.FieldWeight)
	}
	if m.point_boost != nil {
		fields = append(fields, service.FieldPointBoost)
	}
	if m.round_units != nil {
		fields = append(fields, service.FieldRoundUnits)
	}
	if m.round_delay != nil {
		fields = append(fields, service.FieldRoundDelay)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case service.FieldCreateTime:
		return m.CreateTime()
	case service.FieldUpdateTime:
		return m.UpdateTime()
	case service.FieldPause:
		return m.Pause()
	case service.FieldHidden:
		return m.Hidden()
	case service.FieldCompetitionID:
		return m.CompetitionID()
	case service.FieldTeamID:
		return m.TeamID()
	case service.FieldName:
		return m.Name()
	case service.FieldDisplayName:
		return m.DisplayName()
	case service.FieldWeight:
		return m.Weight()
	case service.FieldPointBoost:
		return m.PointBoost()
	case service.FieldRoundUnits:
		return m.RoundUnits()
	case service.FieldRoundDelay:
		return m.RoundDelay()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case service.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case service.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case service.FieldPause:
		return m.OldPause(ctx)
	case service.FieldHidden:
		return m.OldHidden(ctx)
	case service.FieldCompetitionID:
		return m.OldCompetitionID(ctx)
	case service.FieldTeamID:
		return m.OldTeamID(ctx)
	case service.FieldName:
		return m.OldName(ctx)
	case service.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case service.FieldWeight:
		return m.OldWeight(ctx)
	case service.FieldPointBoost:
		return m.OldPointBoost(ctx)
	case service.FieldRoundUnits:
		return m.OldRoundUnits(ctx)
	case service.FieldRoundDelay:
		return m.OldRoundDelay(ctx)
	}
	return nil, fmt.Errorf("unknown Service field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case service.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case service.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case service.FieldPause:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPause(v)
		return nil
	case service.FieldHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHidden(v)
		return nil
	case service.FieldCompetitionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompetitionID(v)
		return nil
	case service.FieldTeamID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	case service.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case service.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case service.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case service.FieldPointBoost:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPointBoost(v)
		return nil
	case service.FieldRoundUnits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoundUnits(v)
		return nil
	case service.FieldRoundDelay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoundDelay(v)
		return nil
	}
	return fmt.Errorf("unknown Service field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceMutation) AddedFields() []string {
	var fields []string
	if m.addweight != nil {
		fields = append(fields, service.FieldWeight)
	}
	if m.addpoint_boost != nil {
		fields = append(fields, service.FieldPointBoost)
	}
	if m.addround_units != nil {
		fields = append(fields, service.FieldRoundUnits)
	}
	if m.addround_delay != nil {
		fields = append(fields, service.FieldRoundDelay)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case service.FieldWeight:
		return m.AddedWeight()
	case service.FieldPointBoost:
		return m.AddedPointBoost()
	case service.FieldRoundUnits:
		return m.AddedRoundUnits()
	case service.FieldRoundDelay:
		return m.AddedRoundDelay()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case service.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	case service.FieldPointBoost:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPointBoost(v)
		return nil
	case service.FieldRoundUnits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoundUnits(v)
		return nil
	case service.FieldRoundDelay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoundDelay(v)
		return nil
	}
	return fmt.Errorf("unknown Service numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Service nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceMutation) ResetField(name string) error {
	switch name {
	case service.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case service.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case service.FieldPause:
		m.ResetPause()
		return nil
	case service.FieldHidden:
		m.ResetHidden()
		return nil
	case service.FieldCompetitionID:
		m.ResetCompetitionID()
		return nil
	case service.FieldTeamID:
		m.ResetTeamID()
		return nil
	case service.FieldName:
		m.ResetName()
		return nil
	case service.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case service.FieldWeight:
		m.ResetWeight()
		return nil
	case service.FieldPointBoost:
		m.ResetPointBoost()
		return nil
	case service.FieldRoundUnits:
		m.ResetRoundUnits()
		return nil
	case service.FieldRoundDelay:
		m.ResetRoundDelay()
		return nil
	}
	return fmt.Errorf("unknown Service field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.competition != nil {
		edges = append(edges, service.EdgeCompetition)
	}
	if m.team != nil {
		edges = append(edges, service.EdgeTeam)
	}
	if m.hosts != nil {
		edges = append(edges, service.EdgeHosts)
	}
	if m.checks != nil {
		edges = append(edges, service.EdgeChecks)
	}
	if m.properties != nil {
		edges = append(edges, service.EdgeProperties)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case service.EdgeCompetition:
		if id := m.competition; id != nil {
			return []ent.Value{*id}
		}
	case service.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	case service.EdgeHosts:
		if id := m.hosts; id != nil {
			return []ent.Value{*id}
		}
	case service.EdgeChecks:
		ids := make([]ent.Value, 0, len(m.checks))
		for id := range m.checks {
			ids = append(ids, id)
		}
		return ids
	case service.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.properties))
		for id := range m.properties {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedchecks != nil {
		edges = append(edges, service.EdgeChecks)
	}
	if m.removedproperties != nil {
		edges = append(edges, service.EdgeProperties)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case service.EdgeChecks:
		ids := make([]ent.Value, 0, len(m.removedchecks))
		for id := range m.removedchecks {
			ids = append(ids, id)
		}
		return ids
	case service.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.removedproperties))
		for id := range m.removedproperties {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcompetition {
		edges = append(edges, service.EdgeCompetition)
	}
	if m.clearedteam {
		edges = append(edges, service.EdgeTeam)
	}
	if m.clearedhosts {
		edges = append(edges, service.EdgeHosts)
	}
	if m.clearedchecks {
		edges = append(edges, service.EdgeChecks)
	}
	if m.clearedproperties {
		edges = append(edges, service.EdgeProperties)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceMutation) EdgeCleared(name string) bool {
	switch name {
	case service.EdgeCompetition:
		return m.clearedcompetition
	case service.EdgeTeam:
		return m.clearedteam
	case service.EdgeHosts:
		return m.clearedhosts
	case service.EdgeChecks:
		return m.clearedchecks
	case service.EdgeProperties:
		return m.clearedproperties
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceMutation) ClearEdge(name string) error {
	switch name {
	case service.EdgeCompetition:
		m.ClearCompetition()
		return nil
	case service.EdgeTeam:
		m.ClearTeam()
		return nil
	case service.EdgeHosts:
		m.ClearHosts()
		return nil
	}
	return fmt.Errorf("unknown Service unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceMutation) ResetEdge(name string) error {
	switch name {
	case service.EdgeCompetition:
		m.ResetCompetition()
		return nil
	case service.EdgeTeam:
		m.ResetTeam()
		return nil
	case service.EdgeHosts:
		m.ResetHosts()
		return nil
	case service.EdgeChecks:
		m.ResetChecks()
		return nil
	case service.EdgeProperties:
		m.ResetProperties()
		return nil
	}
	return fmt.Errorf("unknown Service edge %s", name)
}

// TeamMutation represents an operation that mutates the Team nodes in the graph.
type TeamMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	create_time        *time.Time
	update_time        *time.Time
	pause              *bool
	hidden             *bool
	name               *string
	index              *int
	addindex           *int
	clearedFields      map[string]struct{}
	competition        *int
	clearedcompetition bool
	users              map[int]struct{}
	removedusers       map[int]struct{}
	clearedusers       bool
	hosts              map[int]struct{}
	removedhosts       map[int]struct{}
	clearedhosts       bool
	done               bool
	oldValue           func(context.Context) (*Team, error)
	predicates         []predicate.Team
}

var _ ent.Mutation = (*TeamMutation)(nil)

// teamOption allows management of the mutation configuration using functional options.
type teamOption func(*TeamMutation)

// newTeamMutation creates new mutation for the Team entity.
func newTeamMutation(c config, op Op, opts ...teamOption) *TeamMutation {
	m := &TeamMutation{
		config:        c,
		op:            op,
		typ:           TypeTeam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamID sets the ID field of the mutation.
func withTeamID(id int) teamOption {
	return func(m *TeamMutation) {
		var (
			err   error
			once  sync.Once
			value *Team
		)
		m.oldValue = func(ctx context.Context) (*Team, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Team.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeam sets the old Team of the mutation.
func withTeam(node *Team) teamOption {
	return func(m *TeamMutation) {
		m.oldValue = func(context.Context) (*Team, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entities: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Team.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TeamMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TeamMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TeamMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TeamMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TeamMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TeamMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetPause sets the "pause" field.
func (m *TeamMutation) SetPause(b bool) {
	m.pause = &b
}

// Pause returns the value of the "pause" field in the mutation.
func (m *TeamMutation) Pause() (r bool, exists bool) {
	v := m.pause
	if v == nil {
		return
	}
	return *v, true
}

// OldPause returns the old "pause" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldPause(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPause is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPause requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPause: %w", err)
	}
	return oldValue.Pause, nil
}

// ResetPause resets all changes to the "pause" field.
func (m *TeamMutation) ResetPause() {
	m.pause = nil
}

// SetHidden sets the "hidden" field.
func (m *TeamMutation) SetHidden(b bool) {
	m.hidden = &b
}

// Hidden returns the value of the "hidden" field in the mutation.
func (m *TeamMutation) Hidden() (r bool, exists bool) {
	v := m.hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldHidden returns the old "hidden" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHidden: %w", err)
	}
	return oldValue.Hidden, nil
}

// ResetHidden resets all changes to the "hidden" field.
func (m *TeamMutation) ResetHidden() {
	m.hidden = nil
}

// SetCompetitionID sets the "competition_id" field.
func (m *TeamMutation) SetCompetitionID(i int) {
	m.competition = &i
}

// CompetitionID returns the value of the "competition_id" field in the mutation.
func (m *TeamMutation) CompetitionID() (r int, exists bool) {
	v := m.competition
	if v == nil {
		return
	}
	return *v, true
}

// OldCompetitionID returns the old "competition_id" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldCompetitionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompetitionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompetitionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompetitionID: %w", err)
	}
	return oldValue.CompetitionID, nil
}

// ResetCompetitionID resets all changes to the "competition_id" field.
func (m *TeamMutation) ResetCompetitionID() {
	m.competition = nil
}

// SetName sets the "name" field.
func (m *TeamMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeamMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeamMutation) ResetName() {
	m.name = nil
}

// SetIndex sets the "index" field.
func (m *TeamMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *TeamMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to the "index" field.
func (m *TeamMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *TeamMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndex resets all changes to the "index" field.
func (m *TeamMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
}

// ClearCompetition clears the "competition" edge to the Competition entity.
func (m *TeamMutation) ClearCompetition() {
	m.clearedcompetition = true
}

// CompetitionCleared reports if the "competition" edge to the Competition entity was cleared.
func (m *TeamMutation) CompetitionCleared() bool {
	return m.clearedcompetition
}

// CompetitionIDs returns the "competition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompetitionID instead. It exists only for internal usage by the builders.
func (m *TeamMutation) CompetitionIDs() (ids []int) {
	if id := m.competition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompetition resets all changes to the "competition" edge.
func (m *TeamMutation) ResetCompetition() {
	m.competition = nil
	m.clearedcompetition = false
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *TeamMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *TeamMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *TeamMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *TeamMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *TeamMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *TeamMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *TeamMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddHostIDs adds the "hosts" edge to the Host entity by ids.
func (m *TeamMutation) AddHostIDs(ids ...int) {
	if m.hosts == nil {
		m.hosts = make(map[int]struct{})
	}
	for i := range ids {
		m.hosts[ids[i]] = struct{}{}
	}
}

// ClearHosts clears the "hosts" edge to the Host entity.
func (m *TeamMutation) ClearHosts() {
	m.clearedhosts = true
}

// HostsCleared reports if the "hosts" edge to the Host entity was cleared.
func (m *TeamMutation) HostsCleared() bool {
	return m.clearedhosts
}

// RemoveHostIDs removes the "hosts" edge to the Host entity by IDs.
func (m *TeamMutation) RemoveHostIDs(ids ...int) {
	if m.removedhosts == nil {
		m.removedhosts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.hosts, ids[i])
		m.removedhosts[ids[i]] = struct{}{}
	}
}

// RemovedHosts returns the removed IDs of the "hosts" edge to the Host entity.
func (m *TeamMutation) RemovedHostsIDs() (ids []int) {
	for id := range m.removedhosts {
		ids = append(ids, id)
	}
	return
}

// HostsIDs returns the "hosts" edge IDs in the mutation.
func (m *TeamMutation) HostsIDs() (ids []int) {
	for id := range m.hosts {
		ids = append(ids, id)
	}
	return
}

// ResetHosts resets all changes to the "hosts" edge.
func (m *TeamMutation) ResetHosts() {
	m.hosts = nil
	m.clearedhosts = false
	m.removedhosts = nil
}

// Where appends a list predicates to the TeamMutation builder.
func (m *TeamMutation) Where(ps ...predicate.Team) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Team, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Team).
func (m *TeamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, team.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, team.FieldUpdateTime)
	}
	if m.pause != nil {
		fields = append(fields, team.FieldPause)
	}
	if m.hidden != nil {
		fields = append(fields, team.FieldHidden)
	}
	if m.competition != nil {
		fields = append(fields, team.FieldCompetitionID)
	}
	if m.name != nil {
		fields = append(fields, team.FieldName)
	}
	if m.index != nil {
		fields = append(fields, team.FieldIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case team.FieldCreateTime:
		return m.CreateTime()
	case team.FieldUpdateTime:
		return m.UpdateTime()
	case team.FieldPause:
		return m.Pause()
	case team.FieldHidden:
		return m.Hidden()
	case team.FieldCompetitionID:
		return m.CompetitionID()
	case team.FieldName:
		return m.Name()
	case team.FieldIndex:
		return m.Index()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case team.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case team.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case team.FieldPause:
		return m.OldPause(ctx)
	case team.FieldHidden:
		return m.OldHidden(ctx)
	case team.FieldCompetitionID:
		return m.OldCompetitionID(ctx)
	case team.FieldName:
		return m.OldName(ctx)
	case team.FieldIndex:
		return m.OldIndex(ctx)
	}
	return nil, fmt.Errorf("unknown Team field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case team.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case team.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case team.FieldPause:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPause(v)
		return nil
	case team.FieldHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHidden(v)
		return nil
	case team.FieldCompetitionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompetitionID(v)
		return nil
	case team.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case team.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamMutation) AddedFields() []string {
	var fields []string
	if m.addindex != nil {
		fields = append(fields, team.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case team.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) AddField(name string, value ent.Value) error {
	switch name {
	case team.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown Team numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Team nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamMutation) ResetField(name string) error {
	switch name {
	case team.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case team.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case team.FieldPause:
		m.ResetPause()
		return nil
	case team.FieldHidden:
		m.ResetHidden()
		return nil
	case team.FieldCompetitionID:
		m.ResetCompetitionID()
		return nil
	case team.FieldName:
		m.ResetName()
		return nil
	case team.FieldIndex:
		m.ResetIndex()
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.competition != nil {
		edges = append(edges, team.EdgeCompetition)
	}
	if m.users != nil {
		edges = append(edges, team.EdgeUsers)
	}
	if m.hosts != nil {
		edges = append(edges, team.EdgeHosts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeCompetition:
		if id := m.competition; id != nil {
			return []ent.Value{*id}
		}
	case team.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeHosts:
		ids := make([]ent.Value, 0, len(m.hosts))
		for id := range m.hosts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedusers != nil {
		edges = append(edges, team.EdgeUsers)
	}
	if m.removedhosts != nil {
		edges = append(edges, team.EdgeHosts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeHosts:
		ids := make([]ent.Value, 0, len(m.removedhosts))
		for id := range m.removedhosts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcompetition {
		edges = append(edges, team.EdgeCompetition)
	}
	if m.clearedusers {
		edges = append(edges, team.EdgeUsers)
	}
	if m.clearedhosts {
		edges = append(edges, team.EdgeHosts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamMutation) EdgeCleared(name string) bool {
	switch name {
	case team.EdgeCompetition:
		return m.clearedcompetition
	case team.EdgeUsers:
		return m.clearedusers
	case team.EdgeHosts:
		return m.clearedhosts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamMutation) ClearEdge(name string) error {
	switch name {
	case team.EdgeCompetition:
		m.ClearCompetition()
		return nil
	}
	return fmt.Errorf("unknown Team unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamMutation) ResetEdge(name string) error {
	switch name {
	case team.EdgeCompetition:
		m.ResetCompetition()
		return nil
	case team.EdgeUsers:
		m.ResetUsers()
		return nil
	case team.EdgeHosts:
		m.ResetHosts()
		return nil
	}
	return fmt.Errorf("unknown Team edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	create_time         *time.Time
	update_time         *time.Time
	username            *string
	clearedFields       map[string]struct{}
	teams               map[int]struct{}
	removedteams        map[int]struct{}
	clearedteams        bool
	competitions        map[int]struct{}
	removedcompetitions map[int]struct{}
	clearedcompetitions bool
	done                bool
	oldValue            func(context.Context) (*User, error)
	predicates          []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entities: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// AddTeamIDs adds the "teams" edge to the Team entity by ids.
func (m *UserMutation) AddTeamIDs(ids ...int) {
	if m.teams == nil {
		m.teams = make(map[int]struct{})
	}
	for i := range ids {
		m.teams[ids[i]] = struct{}{}
	}
}

// ClearTeams clears the "teams" edge to the Team entity.
func (m *UserMutation) ClearTeams() {
	m.clearedteams = true
}

// TeamsCleared reports if the "teams" edge to the Team entity was cleared.
func (m *UserMutation) TeamsCleared() bool {
	return m.clearedteams
}

// RemoveTeamIDs removes the "teams" edge to the Team entity by IDs.
func (m *UserMutation) RemoveTeamIDs(ids ...int) {
	if m.removedteams == nil {
		m.removedteams = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.teams, ids[i])
		m.removedteams[ids[i]] = struct{}{}
	}
}

// RemovedTeams returns the removed IDs of the "teams" edge to the Team entity.
func (m *UserMutation) RemovedTeamsIDs() (ids []int) {
	for id := range m.removedteams {
		ids = append(ids, id)
	}
	return
}

// TeamsIDs returns the "teams" edge IDs in the mutation.
func (m *UserMutation) TeamsIDs() (ids []int) {
	for id := range m.teams {
		ids = append(ids, id)
	}
	return
}

// ResetTeams resets all changes to the "teams" edge.
func (m *UserMutation) ResetTeams() {
	m.teams = nil
	m.clearedteams = false
	m.removedteams = nil
}

// AddCompetitionIDs adds the "competitions" edge to the Competition entity by ids.
func (m *UserMutation) AddCompetitionIDs(ids ...int) {
	if m.competitions == nil {
		m.competitions = make(map[int]struct{})
	}
	for i := range ids {
		m.competitions[ids[i]] = struct{}{}
	}
}

// ClearCompetitions clears the "competitions" edge to the Competition entity.
func (m *UserMutation) ClearCompetitions() {
	m.clearedcompetitions = true
}

// CompetitionsCleared reports if the "competitions" edge to the Competition entity was cleared.
func (m *UserMutation) CompetitionsCleared() bool {
	return m.clearedcompetitions
}

// RemoveCompetitionIDs removes the "competitions" edge to the Competition entity by IDs.
func (m *UserMutation) RemoveCompetitionIDs(ids ...int) {
	if m.removedcompetitions == nil {
		m.removedcompetitions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.competitions, ids[i])
		m.removedcompetitions[ids[i]] = struct{}{}
	}
}

// RemovedCompetitions returns the removed IDs of the "competitions" edge to the Competition entity.
func (m *UserMutation) RemovedCompetitionsIDs() (ids []int) {
	for id := range m.removedcompetitions {
		ids = append(ids, id)
	}
	return
}

// CompetitionsIDs returns the "competitions" edge IDs in the mutation.
func (m *UserMutation) CompetitionsIDs() (ids []int) {
	for id := range m.competitions {
		ids = append(ids, id)
	}
	return
}

// ResetCompetitions resets all changes to the "competitions" edge.
func (m *UserMutation) ResetCompetitions() {
	m.competitions = nil
	m.clearedcompetitions = false
	m.removedcompetitions = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, user.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, user.FieldUpdateTime)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreateTime:
		return m.CreateTime()
	case user.FieldUpdateTime:
		return m.UpdateTime()
	case user.FieldUsername:
		return m.Username()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case user.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case user.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case user.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.teams != nil {
		edges = append(edges, user.EdgeTeams)
	}
	if m.competitions != nil {
		edges = append(edges, user.EdgeCompetitions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.teams))
		for id := range m.teams {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCompetitions:
		ids := make([]ent.Value, 0, len(m.competitions))
		for id := range m.competitions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedteams != nil {
		edges = append(edges, user.EdgeTeams)
	}
	if m.removedcompetitions != nil {
		edges = append(edges, user.EdgeCompetitions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.removedteams))
		for id := range m.removedteams {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCompetitions:
		ids := make([]ent.Value, 0, len(m.removedcompetitions))
		for id := range m.removedcompetitions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedteams {
		edges = append(edges, user.EdgeTeams)
	}
	if m.clearedcompetitions {
		edges = append(edges, user.EdgeCompetitions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeTeams:
		return m.clearedteams
	case user.EdgeCompetitions:
		return m.clearedcompetitions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeTeams:
		m.ResetTeams()
		return nil
	case user.EdgeCompetitions:
		m.ResetCompetitions()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
