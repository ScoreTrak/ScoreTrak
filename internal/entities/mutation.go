// Code generated by ent, DO NOT EDIT.

package entities

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/check"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/competition"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/host"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/hostservice"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/predicate"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/property"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/report"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/round"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/service"
	"github.com/ScoreTrak/ScoreTrak/internal/entities/team"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCheck       = "Check"
	TypeCompetition = "Competition"
	TypeHost        = "Host"
	TypeHostService = "HostService"
	TypeProperty    = "Property"
	TypeReport      = "Report"
	TypeRound       = "Round"
	TypeService     = "Service"
	TypeTeam        = "Team"
)

// CheckMutation represents an operation that mutates the Check nodes in the graph.
type CheckMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	pause              *bool
	hidden             *bool
	log                *string
	error              *string
	passed             *bool
	clearedFields      map[string]struct{}
	rounds             *string
	clearedrounds      bool
	hostservice        *string
	clearedhostservice bool
	team               *string
	clearedteam        bool
	done               bool
	oldValue           func(context.Context) (*Check, error)
	predicates         []predicate.Check
}

var _ ent.Mutation = (*CheckMutation)(nil)

// checkOption allows management of the mutation configuration using functional options.
type checkOption func(*CheckMutation)

// newCheckMutation creates new mutation for the Check entity.
func newCheckMutation(c config, op Op, opts ...checkOption) *CheckMutation {
	m := &CheckMutation{
		config:        c,
		op:            op,
		typ:           TypeCheck,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCheckID sets the ID field of the mutation.
func withCheckID(id string) checkOption {
	return func(m *CheckMutation) {
		var (
			err   error
			once  sync.Once
			value *Check
		)
		m.oldValue = func(ctx context.Context) (*Check, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Check.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCheck sets the old Check of the mutation.
func withCheck(node *Check) checkOption {
	return func(m *CheckMutation) {
		m.oldValue = func(context.Context) (*Check, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CheckMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CheckMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entities: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Check entities.
func (m *CheckMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CheckMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CheckMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Check.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPause sets the "pause" field.
func (m *CheckMutation) SetPause(b bool) {
	m.pause = &b
}

// Pause returns the value of the "pause" field in the mutation.
func (m *CheckMutation) Pause() (r bool, exists bool) {
	v := m.pause
	if v == nil {
		return
	}
	return *v, true
}

// OldPause returns the old "pause" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldPause(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPause is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPause requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPause: %w", err)
	}
	return oldValue.Pause, nil
}

// ClearPause clears the value of the "pause" field.
func (m *CheckMutation) ClearPause() {
	m.pause = nil
	m.clearedFields[check.FieldPause] = struct{}{}
}

// PauseCleared returns if the "pause" field was cleared in this mutation.
func (m *CheckMutation) PauseCleared() bool {
	_, ok := m.clearedFields[check.FieldPause]
	return ok
}

// ResetPause resets all changes to the "pause" field.
func (m *CheckMutation) ResetPause() {
	m.pause = nil
	delete(m.clearedFields, check.FieldPause)
}

// SetHidden sets the "hidden" field.
func (m *CheckMutation) SetHidden(b bool) {
	m.hidden = &b
}

// Hidden returns the value of the "hidden" field in the mutation.
func (m *CheckMutation) Hidden() (r bool, exists bool) {
	v := m.hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldHidden returns the old "hidden" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHidden: %w", err)
	}
	return oldValue.Hidden, nil
}

// ClearHidden clears the value of the "hidden" field.
func (m *CheckMutation) ClearHidden() {
	m.hidden = nil
	m.clearedFields[check.FieldHidden] = struct{}{}
}

// HiddenCleared returns if the "hidden" field was cleared in this mutation.
func (m *CheckMutation) HiddenCleared() bool {
	_, ok := m.clearedFields[check.FieldHidden]
	return ok
}

// ResetHidden resets all changes to the "hidden" field.
func (m *CheckMutation) ResetHidden() {
	m.hidden = nil
	delete(m.clearedFields, check.FieldHidden)
}

// SetLog sets the "log" field.
func (m *CheckMutation) SetLog(s string) {
	m.log = &s
}

// Log returns the value of the "log" field in the mutation.
func (m *CheckMutation) Log() (r string, exists bool) {
	v := m.log
	if v == nil {
		return
	}
	return *v, true
}

// OldLog returns the old "log" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldLog(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLog is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLog requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLog: %w", err)
	}
	return oldValue.Log, nil
}

// ResetLog resets all changes to the "log" field.
func (m *CheckMutation) ResetLog() {
	m.log = nil
}

// SetError sets the "error" field.
func (m *CheckMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *CheckMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ResetError resets all changes to the "error" field.
func (m *CheckMutation) ResetError() {
	m.error = nil
}

// SetPassed sets the "passed" field.
func (m *CheckMutation) SetPassed(b bool) {
	m.passed = &b
}

// Passed returns the value of the "passed" field in the mutation.
func (m *CheckMutation) Passed() (r bool, exists bool) {
	v := m.passed
	if v == nil {
		return
	}
	return *v, true
}

// OldPassed returns the old "passed" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldPassed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassed: %w", err)
	}
	return oldValue.Passed, nil
}

// ResetPassed resets all changes to the "passed" field.
func (m *CheckMutation) ResetPassed() {
	m.passed = nil
}

// SetRoundID sets the "round_id" field.
func (m *CheckMutation) SetRoundID(s string) {
	m.rounds = &s
}

// RoundID returns the value of the "round_id" field in the mutation.
func (m *CheckMutation) RoundID() (r string, exists bool) {
	v := m.rounds
	if v == nil {
		return
	}
	return *v, true
}

// OldRoundID returns the old "round_id" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldRoundID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoundID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoundID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoundID: %w", err)
	}
	return oldValue.RoundID, nil
}

// ResetRoundID resets all changes to the "round_id" field.
func (m *CheckMutation) ResetRoundID() {
	m.rounds = nil
}

// SetHostServiceID sets the "host_service_id" field.
func (m *CheckMutation) SetHostServiceID(s string) {
	m.hostservice = &s
}

// HostServiceID returns the value of the "host_service_id" field in the mutation.
func (m *CheckMutation) HostServiceID() (r string, exists bool) {
	v := m.hostservice
	if v == nil {
		return
	}
	return *v, true
}

// OldHostServiceID returns the old "host_service_id" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldHostServiceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostServiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostServiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostServiceID: %w", err)
	}
	return oldValue.HostServiceID, nil
}

// ResetHostServiceID resets all changes to the "host_service_id" field.
func (m *CheckMutation) ResetHostServiceID() {
	m.hostservice = nil
}

// SetTeamID sets the "team_id" field.
func (m *CheckMutation) SetTeamID(s string) {
	m.team = &s
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *CheckMutation) TeamID() (r string, exists bool) {
	v := m.team
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldTeamID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *CheckMutation) ResetTeamID() {
	m.team = nil
}

// SetRoundsID sets the "rounds" edge to the Round entity by id.
func (m *CheckMutation) SetRoundsID(id string) {
	m.rounds = &id
}

// ClearRounds clears the "rounds" edge to the Round entity.
func (m *CheckMutation) ClearRounds() {
	m.clearedrounds = true
}

// RoundsCleared reports if the "rounds" edge to the Round entity was cleared.
func (m *CheckMutation) RoundsCleared() bool {
	return m.clearedrounds
}

// RoundsID returns the "rounds" edge ID in the mutation.
func (m *CheckMutation) RoundsID() (id string, exists bool) {
	if m.rounds != nil {
		return *m.rounds, true
	}
	return
}

// RoundsIDs returns the "rounds" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoundsID instead. It exists only for internal usage by the builders.
func (m *CheckMutation) RoundsIDs() (ids []string) {
	if id := m.rounds; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRounds resets all changes to the "rounds" edge.
func (m *CheckMutation) ResetRounds() {
	m.rounds = nil
	m.clearedrounds = false
}

// SetHostserviceID sets the "hostservice" edge to the HostService entity by id.
func (m *CheckMutation) SetHostserviceID(id string) {
	m.hostservice = &id
}

// ClearHostservice clears the "hostservice" edge to the HostService entity.
func (m *CheckMutation) ClearHostservice() {
	m.clearedhostservice = true
}

// HostserviceCleared reports if the "hostservice" edge to the HostService entity was cleared.
func (m *CheckMutation) HostserviceCleared() bool {
	return m.clearedhostservice
}

// HostserviceID returns the "hostservice" edge ID in the mutation.
func (m *CheckMutation) HostserviceID() (id string, exists bool) {
	if m.hostservice != nil {
		return *m.hostservice, true
	}
	return
}

// HostserviceIDs returns the "hostservice" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostserviceID instead. It exists only for internal usage by the builders.
func (m *CheckMutation) HostserviceIDs() (ids []string) {
	if id := m.hostservice; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHostservice resets all changes to the "hostservice" edge.
func (m *CheckMutation) ResetHostservice() {
	m.hostservice = nil
	m.clearedhostservice = false
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *CheckMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *CheckMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *CheckMutation) TeamIDs() (ids []string) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *CheckMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// Where appends a list predicates to the CheckMutation builder.
func (m *CheckMutation) Where(ps ...predicate.Check) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CheckMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CheckMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Check, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CheckMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CheckMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Check).
func (m *CheckMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CheckMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.pause != nil {
		fields = append(fields, check.FieldPause)
	}
	if m.hidden != nil {
		fields = append(fields, check.FieldHidden)
	}
	if m.log != nil {
		fields = append(fields, check.FieldLog)
	}
	if m.error != nil {
		fields = append(fields, check.FieldError)
	}
	if m.passed != nil {
		fields = append(fields, check.FieldPassed)
	}
	if m.rounds != nil {
		fields = append(fields, check.FieldRoundID)
	}
	if m.hostservice != nil {
		fields = append(fields, check.FieldHostServiceID)
	}
	if m.team != nil {
		fields = append(fields, check.FieldTeamID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CheckMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case check.FieldPause:
		return m.Pause()
	case check.FieldHidden:
		return m.Hidden()
	case check.FieldLog:
		return m.Log()
	case check.FieldError:
		return m.Error()
	case check.FieldPassed:
		return m.Passed()
	case check.FieldRoundID:
		return m.RoundID()
	case check.FieldHostServiceID:
		return m.HostServiceID()
	case check.FieldTeamID:
		return m.TeamID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CheckMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case check.FieldPause:
		return m.OldPause(ctx)
	case check.FieldHidden:
		return m.OldHidden(ctx)
	case check.FieldLog:
		return m.OldLog(ctx)
	case check.FieldError:
		return m.OldError(ctx)
	case check.FieldPassed:
		return m.OldPassed(ctx)
	case check.FieldRoundID:
		return m.OldRoundID(ctx)
	case check.FieldHostServiceID:
		return m.OldHostServiceID(ctx)
	case check.FieldTeamID:
		return m.OldTeamID(ctx)
	}
	return nil, fmt.Errorf("unknown Check field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CheckMutation) SetField(name string, value ent.Value) error {
	switch name {
	case check.FieldPause:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPause(v)
		return nil
	case check.FieldHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHidden(v)
		return nil
	case check.FieldLog:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLog(v)
		return nil
	case check.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case check.FieldPassed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassed(v)
		return nil
	case check.FieldRoundID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoundID(v)
		return nil
	case check.FieldHostServiceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostServiceID(v)
		return nil
	case check.FieldTeamID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	}
	return fmt.Errorf("unknown Check field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CheckMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CheckMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CheckMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Check numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CheckMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(check.FieldPause) {
		fields = append(fields, check.FieldPause)
	}
	if m.FieldCleared(check.FieldHidden) {
		fields = append(fields, check.FieldHidden)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CheckMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CheckMutation) ClearField(name string) error {
	switch name {
	case check.FieldPause:
		m.ClearPause()
		return nil
	case check.FieldHidden:
		m.ClearHidden()
		return nil
	}
	return fmt.Errorf("unknown Check nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CheckMutation) ResetField(name string) error {
	switch name {
	case check.FieldPause:
		m.ResetPause()
		return nil
	case check.FieldHidden:
		m.ResetHidden()
		return nil
	case check.FieldLog:
		m.ResetLog()
		return nil
	case check.FieldError:
		m.ResetError()
		return nil
	case check.FieldPassed:
		m.ResetPassed()
		return nil
	case check.FieldRoundID:
		m.ResetRoundID()
		return nil
	case check.FieldHostServiceID:
		m.ResetHostServiceID()
		return nil
	case check.FieldTeamID:
		m.ResetTeamID()
		return nil
	}
	return fmt.Errorf("unknown Check field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CheckMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.rounds != nil {
		edges = append(edges, check.EdgeRounds)
	}
	if m.hostservice != nil {
		edges = append(edges, check.EdgeHostservice)
	}
	if m.team != nil {
		edges = append(edges, check.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CheckMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case check.EdgeRounds:
		if id := m.rounds; id != nil {
			return []ent.Value{*id}
		}
	case check.EdgeHostservice:
		if id := m.hostservice; id != nil {
			return []ent.Value{*id}
		}
	case check.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CheckMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CheckMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CheckMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrounds {
		edges = append(edges, check.EdgeRounds)
	}
	if m.clearedhostservice {
		edges = append(edges, check.EdgeHostservice)
	}
	if m.clearedteam {
		edges = append(edges, check.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CheckMutation) EdgeCleared(name string) bool {
	switch name {
	case check.EdgeRounds:
		return m.clearedrounds
	case check.EdgeHostservice:
		return m.clearedhostservice
	case check.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CheckMutation) ClearEdge(name string) error {
	switch name {
	case check.EdgeRounds:
		m.ClearRounds()
		return nil
	case check.EdgeHostservice:
		m.ClearHostservice()
		return nil
	case check.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown Check unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CheckMutation) ResetEdge(name string) error {
	switch name {
	case check.EdgeRounds:
		m.ResetRounds()
		return nil
	case check.EdgeHostservice:
		m.ResetHostservice()
		return nil
	case check.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown Check edge %s", name)
}

// CompetitionMutation represents an operation that mutates the Competition nodes in the graph.
type CompetitionMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	hidden             *bool
	pause              *bool
	name               *string
	display_name       *string
	viewable_to_public *bool
	to_be_started_at   *time.Time
	started_at         *time.Time
	finished_at        *time.Time
	clearedFields      map[string]struct{}
	teams              map[string]struct{}
	removedteams       map[string]struct{}
	clearedteams       bool
	services           map[string]struct{}
	removedservices    map[string]struct{}
	clearedservices    bool
	reports            map[int]struct{}
	removedreports     map[int]struct{}
	clearedreports     bool
	rounds             map[string]struct{}
	removedrounds      map[string]struct{}
	clearedrounds      bool
	done               bool
	oldValue           func(context.Context) (*Competition, error)
	predicates         []predicate.Competition
}

var _ ent.Mutation = (*CompetitionMutation)(nil)

// competitionOption allows management of the mutation configuration using functional options.
type competitionOption func(*CompetitionMutation)

// newCompetitionMutation creates new mutation for the Competition entity.
func newCompetitionMutation(c config, op Op, opts ...competitionOption) *CompetitionMutation {
	m := &CompetitionMutation{
		config:        c,
		op:            op,
		typ:           TypeCompetition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompetitionID sets the ID field of the mutation.
func withCompetitionID(id string) competitionOption {
	return func(m *CompetitionMutation) {
		var (
			err   error
			once  sync.Once
			value *Competition
		)
		m.oldValue = func(ctx context.Context) (*Competition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Competition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompetition sets the old Competition of the mutation.
func withCompetition(node *Competition) competitionOption {
	return func(m *CompetitionMutation) {
		m.oldValue = func(context.Context) (*Competition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompetitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompetitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entities: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Competition entities.
func (m *CompetitionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompetitionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompetitionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Competition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHidden sets the "hidden" field.
func (m *CompetitionMutation) SetHidden(b bool) {
	m.hidden = &b
}

// Hidden returns the value of the "hidden" field in the mutation.
func (m *CompetitionMutation) Hidden() (r bool, exists bool) {
	v := m.hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldHidden returns the old "hidden" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHidden: %w", err)
	}
	return oldValue.Hidden, nil
}

// ClearHidden clears the value of the "hidden" field.
func (m *CompetitionMutation) ClearHidden() {
	m.hidden = nil
	m.clearedFields[competition.FieldHidden] = struct{}{}
}

// HiddenCleared returns if the "hidden" field was cleared in this mutation.
func (m *CompetitionMutation) HiddenCleared() bool {
	_, ok := m.clearedFields[competition.FieldHidden]
	return ok
}

// ResetHidden resets all changes to the "hidden" field.
func (m *CompetitionMutation) ResetHidden() {
	m.hidden = nil
	delete(m.clearedFields, competition.FieldHidden)
}

// SetPause sets the "pause" field.
func (m *CompetitionMutation) SetPause(b bool) {
	m.pause = &b
}

// Pause returns the value of the "pause" field in the mutation.
func (m *CompetitionMutation) Pause() (r bool, exists bool) {
	v := m.pause
	if v == nil {
		return
	}
	return *v, true
}

// OldPause returns the old "pause" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldPause(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPause is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPause requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPause: %w", err)
	}
	return oldValue.Pause, nil
}

// ClearPause clears the value of the "pause" field.
func (m *CompetitionMutation) ClearPause() {
	m.pause = nil
	m.clearedFields[competition.FieldPause] = struct{}{}
}

// PauseCleared returns if the "pause" field was cleared in this mutation.
func (m *CompetitionMutation) PauseCleared() bool {
	_, ok := m.clearedFields[competition.FieldPause]
	return ok
}

// ResetPause resets all changes to the "pause" field.
func (m *CompetitionMutation) ResetPause() {
	m.pause = nil
	delete(m.clearedFields, competition.FieldPause)
}

// SetName sets the "name" field.
func (m *CompetitionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CompetitionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CompetitionMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *CompetitionMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *CompetitionMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *CompetitionMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetViewableToPublic sets the "viewable_to_public" field.
func (m *CompetitionMutation) SetViewableToPublic(b bool) {
	m.viewable_to_public = &b
}

// ViewableToPublic returns the value of the "viewable_to_public" field in the mutation.
func (m *CompetitionMutation) ViewableToPublic() (r bool, exists bool) {
	v := m.viewable_to_public
	if v == nil {
		return
	}
	return *v, true
}

// OldViewableToPublic returns the old "viewable_to_public" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldViewableToPublic(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViewableToPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViewableToPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewableToPublic: %w", err)
	}
	return oldValue.ViewableToPublic, nil
}

// ClearViewableToPublic clears the value of the "viewable_to_public" field.
func (m *CompetitionMutation) ClearViewableToPublic() {
	m.viewable_to_public = nil
	m.clearedFields[competition.FieldViewableToPublic] = struct{}{}
}

// ViewableToPublicCleared returns if the "viewable_to_public" field was cleared in this mutation.
func (m *CompetitionMutation) ViewableToPublicCleared() bool {
	_, ok := m.clearedFields[competition.FieldViewableToPublic]
	return ok
}

// ResetViewableToPublic resets all changes to the "viewable_to_public" field.
func (m *CompetitionMutation) ResetViewableToPublic() {
	m.viewable_to_public = nil
	delete(m.clearedFields, competition.FieldViewableToPublic)
}

// SetToBeStartedAt sets the "to_be_started_at" field.
func (m *CompetitionMutation) SetToBeStartedAt(t time.Time) {
	m.to_be_started_at = &t
}

// ToBeStartedAt returns the value of the "to_be_started_at" field in the mutation.
func (m *CompetitionMutation) ToBeStartedAt() (r time.Time, exists bool) {
	v := m.to_be_started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldToBeStartedAt returns the old "to_be_started_at" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldToBeStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToBeStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToBeStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToBeStartedAt: %w", err)
	}
	return oldValue.ToBeStartedAt, nil
}

// ClearToBeStartedAt clears the value of the "to_be_started_at" field.
func (m *CompetitionMutation) ClearToBeStartedAt() {
	m.to_be_started_at = nil
	m.clearedFields[competition.FieldToBeStartedAt] = struct{}{}
}

// ToBeStartedAtCleared returns if the "to_be_started_at" field was cleared in this mutation.
func (m *CompetitionMutation) ToBeStartedAtCleared() bool {
	_, ok := m.clearedFields[competition.FieldToBeStartedAt]
	return ok
}

// ResetToBeStartedAt resets all changes to the "to_be_started_at" field.
func (m *CompetitionMutation) ResetToBeStartedAt() {
	m.to_be_started_at = nil
	delete(m.clearedFields, competition.FieldToBeStartedAt)
}

// SetStartedAt sets the "started_at" field.
func (m *CompetitionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *CompetitionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *CompetitionMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[competition.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *CompetitionMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[competition.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *CompetitionMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, competition.FieldStartedAt)
}

// SetFinishedAt sets the "finished_at" field.
func (m *CompetitionMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *CompetitionMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldFinishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ClearFinishedAt clears the value of the "finished_at" field.
func (m *CompetitionMutation) ClearFinishedAt() {
	m.finished_at = nil
	m.clearedFields[competition.FieldFinishedAt] = struct{}{}
}

// FinishedAtCleared returns if the "finished_at" field was cleared in this mutation.
func (m *CompetitionMutation) FinishedAtCleared() bool {
	_, ok := m.clearedFields[competition.FieldFinishedAt]
	return ok
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *CompetitionMutation) ResetFinishedAt() {
	m.finished_at = nil
	delete(m.clearedFields, competition.FieldFinishedAt)
}

// AddTeamIDs adds the "teams" edge to the Team entity by ids.
func (m *CompetitionMutation) AddTeamIDs(ids ...string) {
	if m.teams == nil {
		m.teams = make(map[string]struct{})
	}
	for i := range ids {
		m.teams[ids[i]] = struct{}{}
	}
}

// ClearTeams clears the "teams" edge to the Team entity.
func (m *CompetitionMutation) ClearTeams() {
	m.clearedteams = true
}

// TeamsCleared reports if the "teams" edge to the Team entity was cleared.
func (m *CompetitionMutation) TeamsCleared() bool {
	return m.clearedteams
}

// RemoveTeamIDs removes the "teams" edge to the Team entity by IDs.
func (m *CompetitionMutation) RemoveTeamIDs(ids ...string) {
	if m.removedteams == nil {
		m.removedteams = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.teams, ids[i])
		m.removedteams[ids[i]] = struct{}{}
	}
}

// RemovedTeams returns the removed IDs of the "teams" edge to the Team entity.
func (m *CompetitionMutation) RemovedTeamsIDs() (ids []string) {
	for id := range m.removedteams {
		ids = append(ids, id)
	}
	return
}

// TeamsIDs returns the "teams" edge IDs in the mutation.
func (m *CompetitionMutation) TeamsIDs() (ids []string) {
	for id := range m.teams {
		ids = append(ids, id)
	}
	return
}

// ResetTeams resets all changes to the "teams" edge.
func (m *CompetitionMutation) ResetTeams() {
	m.teams = nil
	m.clearedteams = false
	m.removedteams = nil
}

// AddServiceIDs adds the "services" edge to the Service entity by ids.
func (m *CompetitionMutation) AddServiceIDs(ids ...string) {
	if m.services == nil {
		m.services = make(map[string]struct{})
	}
	for i := range ids {
		m.services[ids[i]] = struct{}{}
	}
}

// ClearServices clears the "services" edge to the Service entity.
func (m *CompetitionMutation) ClearServices() {
	m.clearedservices = true
}

// ServicesCleared reports if the "services" edge to the Service entity was cleared.
func (m *CompetitionMutation) ServicesCleared() bool {
	return m.clearedservices
}

// RemoveServiceIDs removes the "services" edge to the Service entity by IDs.
func (m *CompetitionMutation) RemoveServiceIDs(ids ...string) {
	if m.removedservices == nil {
		m.removedservices = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.services, ids[i])
		m.removedservices[ids[i]] = struct{}{}
	}
}

// RemovedServices returns the removed IDs of the "services" edge to the Service entity.
func (m *CompetitionMutation) RemovedServicesIDs() (ids []string) {
	for id := range m.removedservices {
		ids = append(ids, id)
	}
	return
}

// ServicesIDs returns the "services" edge IDs in the mutation.
func (m *CompetitionMutation) ServicesIDs() (ids []string) {
	for id := range m.services {
		ids = append(ids, id)
	}
	return
}

// ResetServices resets all changes to the "services" edge.
func (m *CompetitionMutation) ResetServices() {
	m.services = nil
	m.clearedservices = false
	m.removedservices = nil
}

// AddReportIDs adds the "reports" edge to the Report entity by ids.
func (m *CompetitionMutation) AddReportIDs(ids ...int) {
	if m.reports == nil {
		m.reports = make(map[int]struct{})
	}
	for i := range ids {
		m.reports[ids[i]] = struct{}{}
	}
}

// ClearReports clears the "reports" edge to the Report entity.
func (m *CompetitionMutation) ClearReports() {
	m.clearedreports = true
}

// ReportsCleared reports if the "reports" edge to the Report entity was cleared.
func (m *CompetitionMutation) ReportsCleared() bool {
	return m.clearedreports
}

// RemoveReportIDs removes the "reports" edge to the Report entity by IDs.
func (m *CompetitionMutation) RemoveReportIDs(ids ...int) {
	if m.removedreports == nil {
		m.removedreports = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.reports, ids[i])
		m.removedreports[ids[i]] = struct{}{}
	}
}

// RemovedReports returns the removed IDs of the "reports" edge to the Report entity.
func (m *CompetitionMutation) RemovedReportsIDs() (ids []int) {
	for id := range m.removedreports {
		ids = append(ids, id)
	}
	return
}

// ReportsIDs returns the "reports" edge IDs in the mutation.
func (m *CompetitionMutation) ReportsIDs() (ids []int) {
	for id := range m.reports {
		ids = append(ids, id)
	}
	return
}

// ResetReports resets all changes to the "reports" edge.
func (m *CompetitionMutation) ResetReports() {
	m.reports = nil
	m.clearedreports = false
	m.removedreports = nil
}

// AddRoundIDs adds the "rounds" edge to the Round entity by ids.
func (m *CompetitionMutation) AddRoundIDs(ids ...string) {
	if m.rounds == nil {
		m.rounds = make(map[string]struct{})
	}
	for i := range ids {
		m.rounds[ids[i]] = struct{}{}
	}
}

// ClearRounds clears the "rounds" edge to the Round entity.
func (m *CompetitionMutation) ClearRounds() {
	m.clearedrounds = true
}

// RoundsCleared reports if the "rounds" edge to the Round entity was cleared.
func (m *CompetitionMutation) RoundsCleared() bool {
	return m.clearedrounds
}

// RemoveRoundIDs removes the "rounds" edge to the Round entity by IDs.
func (m *CompetitionMutation) RemoveRoundIDs(ids ...string) {
	if m.removedrounds == nil {
		m.removedrounds = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.rounds, ids[i])
		m.removedrounds[ids[i]] = struct{}{}
	}
}

// RemovedRounds returns the removed IDs of the "rounds" edge to the Round entity.
func (m *CompetitionMutation) RemovedRoundsIDs() (ids []string) {
	for id := range m.removedrounds {
		ids = append(ids, id)
	}
	return
}

// RoundsIDs returns the "rounds" edge IDs in the mutation.
func (m *CompetitionMutation) RoundsIDs() (ids []string) {
	for id := range m.rounds {
		ids = append(ids, id)
	}
	return
}

// ResetRounds resets all changes to the "rounds" edge.
func (m *CompetitionMutation) ResetRounds() {
	m.rounds = nil
	m.clearedrounds = false
	m.removedrounds = nil
}

// Where appends a list predicates to the CompetitionMutation builder.
func (m *CompetitionMutation) Where(ps ...predicate.Competition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompetitionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompetitionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Competition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompetitionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompetitionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Competition).
func (m *CompetitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompetitionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.hidden != nil {
		fields = append(fields, competition.FieldHidden)
	}
	if m.pause != nil {
		fields = append(fields, competition.FieldPause)
	}
	if m.name != nil {
		fields = append(fields, competition.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, competition.FieldDisplayName)
	}
	if m.viewable_to_public != nil {
		fields = append(fields, competition.FieldViewableToPublic)
	}
	if m.to_be_started_at != nil {
		fields = append(fields, competition.FieldToBeStartedAt)
	}
	if m.started_at != nil {
		fields = append(fields, competition.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, competition.FieldFinishedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompetitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case competition.FieldHidden:
		return m.Hidden()
	case competition.FieldPause:
		return m.Pause()
	case competition.FieldName:
		return m.Name()
	case competition.FieldDisplayName:
		return m.DisplayName()
	case competition.FieldViewableToPublic:
		return m.ViewableToPublic()
	case competition.FieldToBeStartedAt:
		return m.ToBeStartedAt()
	case competition.FieldStartedAt:
		return m.StartedAt()
	case competition.FieldFinishedAt:
		return m.FinishedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompetitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case competition.FieldHidden:
		return m.OldHidden(ctx)
	case competition.FieldPause:
		return m.OldPause(ctx)
	case competition.FieldName:
		return m.OldName(ctx)
	case competition.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case competition.FieldViewableToPublic:
		return m.OldViewableToPublic(ctx)
	case competition.FieldToBeStartedAt:
		return m.OldToBeStartedAt(ctx)
	case competition.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case competition.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Competition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompetitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case competition.FieldHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHidden(v)
		return nil
	case competition.FieldPause:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPause(v)
		return nil
	case competition.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case competition.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case competition.FieldViewableToPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewableToPublic(v)
		return nil
	case competition.FieldToBeStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToBeStartedAt(v)
		return nil
	case competition.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case competition.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Competition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompetitionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompetitionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompetitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Competition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompetitionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(competition.FieldHidden) {
		fields = append(fields, competition.FieldHidden)
	}
	if m.FieldCleared(competition.FieldPause) {
		fields = append(fields, competition.FieldPause)
	}
	if m.FieldCleared(competition.FieldViewableToPublic) {
		fields = append(fields, competition.FieldViewableToPublic)
	}
	if m.FieldCleared(competition.FieldToBeStartedAt) {
		fields = append(fields, competition.FieldToBeStartedAt)
	}
	if m.FieldCleared(competition.FieldStartedAt) {
		fields = append(fields, competition.FieldStartedAt)
	}
	if m.FieldCleared(competition.FieldFinishedAt) {
		fields = append(fields, competition.FieldFinishedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompetitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompetitionMutation) ClearField(name string) error {
	switch name {
	case competition.FieldHidden:
		m.ClearHidden()
		return nil
	case competition.FieldPause:
		m.ClearPause()
		return nil
	case competition.FieldViewableToPublic:
		m.ClearViewableToPublic()
		return nil
	case competition.FieldToBeStartedAt:
		m.ClearToBeStartedAt()
		return nil
	case competition.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case competition.FieldFinishedAt:
		m.ClearFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown Competition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompetitionMutation) ResetField(name string) error {
	switch name {
	case competition.FieldHidden:
		m.ResetHidden()
		return nil
	case competition.FieldPause:
		m.ResetPause()
		return nil
	case competition.FieldName:
		m.ResetName()
		return nil
	case competition.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case competition.FieldViewableToPublic:
		m.ResetViewableToPublic()
		return nil
	case competition.FieldToBeStartedAt:
		m.ResetToBeStartedAt()
		return nil
	case competition.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case competition.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown Competition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompetitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.teams != nil {
		edges = append(edges, competition.EdgeTeams)
	}
	if m.services != nil {
		edges = append(edges, competition.EdgeServices)
	}
	if m.reports != nil {
		edges = append(edges, competition.EdgeReports)
	}
	if m.rounds != nil {
		edges = append(edges, competition.EdgeRounds)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompetitionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case competition.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.teams))
		for id := range m.teams {
			ids = append(ids, id)
		}
		return ids
	case competition.EdgeServices:
		ids := make([]ent.Value, 0, len(m.services))
		for id := range m.services {
			ids = append(ids, id)
		}
		return ids
	case competition.EdgeReports:
		ids := make([]ent.Value, 0, len(m.reports))
		for id := range m.reports {
			ids = append(ids, id)
		}
		return ids
	case competition.EdgeRounds:
		ids := make([]ent.Value, 0, len(m.rounds))
		for id := range m.rounds {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompetitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedteams != nil {
		edges = append(edges, competition.EdgeTeams)
	}
	if m.removedservices != nil {
		edges = append(edges, competition.EdgeServices)
	}
	if m.removedreports != nil {
		edges = append(edges, competition.EdgeReports)
	}
	if m.removedrounds != nil {
		edges = append(edges, competition.EdgeRounds)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompetitionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case competition.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.removedteams))
		for id := range m.removedteams {
			ids = append(ids, id)
		}
		return ids
	case competition.EdgeServices:
		ids := make([]ent.Value, 0, len(m.removedservices))
		for id := range m.removedservices {
			ids = append(ids, id)
		}
		return ids
	case competition.EdgeReports:
		ids := make([]ent.Value, 0, len(m.removedreports))
		for id := range m.removedreports {
			ids = append(ids, id)
		}
		return ids
	case competition.EdgeRounds:
		ids := make([]ent.Value, 0, len(m.removedrounds))
		for id := range m.removedrounds {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompetitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedteams {
		edges = append(edges, competition.EdgeTeams)
	}
	if m.clearedservices {
		edges = append(edges, competition.EdgeServices)
	}
	if m.clearedreports {
		edges = append(edges, competition.EdgeReports)
	}
	if m.clearedrounds {
		edges = append(edges, competition.EdgeRounds)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompetitionMutation) EdgeCleared(name string) bool {
	switch name {
	case competition.EdgeTeams:
		return m.clearedteams
	case competition.EdgeServices:
		return m.clearedservices
	case competition.EdgeReports:
		return m.clearedreports
	case competition.EdgeRounds:
		return m.clearedrounds
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompetitionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Competition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompetitionMutation) ResetEdge(name string) error {
	switch name {
	case competition.EdgeTeams:
		m.ResetTeams()
		return nil
	case competition.EdgeServices:
		m.ResetServices()
		return nil
	case competition.EdgeReports:
		m.ResetReports()
		return nil
	case competition.EdgeRounds:
		m.ResetRounds()
		return nil
	}
	return fmt.Errorf("unknown Competition edge %s", name)
}

// HostMutation represents an operation that mutates the Host nodes in the graph.
type HostMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	pause               *bool
	hidden              *bool
	address             *string
	clearedFields       map[string]struct{}
	hostservices        map[string]struct{}
	removedhostservices map[string]struct{}
	clearedhostservices bool
	team                *string
	clearedteam         bool
	done                bool
	oldValue            func(context.Context) (*Host, error)
	predicates          []predicate.Host
}

var _ ent.Mutation = (*HostMutation)(nil)

// hostOption allows management of the mutation configuration using functional options.
type hostOption func(*HostMutation)

// newHostMutation creates new mutation for the Host entity.
func newHostMutation(c config, op Op, opts ...hostOption) *HostMutation {
	m := &HostMutation{
		config:        c,
		op:            op,
		typ:           TypeHost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHostID sets the ID field of the mutation.
func withHostID(id string) hostOption {
	return func(m *HostMutation) {
		var (
			err   error
			once  sync.Once
			value *Host
		)
		m.oldValue = func(ctx context.Context) (*Host, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Host.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHost sets the old Host of the mutation.
func withHost(node *Host) hostOption {
	return func(m *HostMutation) {
		m.oldValue = func(context.Context) (*Host, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entities: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Host entities.
func (m *HostMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HostMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HostMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Host.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPause sets the "pause" field.
func (m *HostMutation) SetPause(b bool) {
	m.pause = &b
}

// Pause returns the value of the "pause" field in the mutation.
func (m *HostMutation) Pause() (r bool, exists bool) {
	v := m.pause
	if v == nil {
		return
	}
	return *v, true
}

// OldPause returns the old "pause" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldPause(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPause is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPause requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPause: %w", err)
	}
	return oldValue.Pause, nil
}

// ClearPause clears the value of the "pause" field.
func (m *HostMutation) ClearPause() {
	m.pause = nil
	m.clearedFields[host.FieldPause] = struct{}{}
}

// PauseCleared returns if the "pause" field was cleared in this mutation.
func (m *HostMutation) PauseCleared() bool {
	_, ok := m.clearedFields[host.FieldPause]
	return ok
}

// ResetPause resets all changes to the "pause" field.
func (m *HostMutation) ResetPause() {
	m.pause = nil
	delete(m.clearedFields, host.FieldPause)
}

// SetHidden sets the "hidden" field.
func (m *HostMutation) SetHidden(b bool) {
	m.hidden = &b
}

// Hidden returns the value of the "hidden" field in the mutation.
func (m *HostMutation) Hidden() (r bool, exists bool) {
	v := m.hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldHidden returns the old "hidden" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHidden: %w", err)
	}
	return oldValue.Hidden, nil
}

// ClearHidden clears the value of the "hidden" field.
func (m *HostMutation) ClearHidden() {
	m.hidden = nil
	m.clearedFields[host.FieldHidden] = struct{}{}
}

// HiddenCleared returns if the "hidden" field was cleared in this mutation.
func (m *HostMutation) HiddenCleared() bool {
	_, ok := m.clearedFields[host.FieldHidden]
	return ok
}

// ResetHidden resets all changes to the "hidden" field.
func (m *HostMutation) ResetHidden() {
	m.hidden = nil
	delete(m.clearedFields, host.FieldHidden)
}

// SetAddress sets the "address" field.
func (m *HostMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *HostMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *HostMutation) ResetAddress() {
	m.address = nil
}

// SetTeamID sets the "team_id" field.
func (m *HostMutation) SetTeamID(s string) {
	m.team = &s
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *HostMutation) TeamID() (r string, exists bool) {
	v := m.team
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldTeamID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *HostMutation) ResetTeamID() {
	m.team = nil
}

// AddHostserviceIDs adds the "hostservices" edge to the HostService entity by ids.
func (m *HostMutation) AddHostserviceIDs(ids ...string) {
	if m.hostservices == nil {
		m.hostservices = make(map[string]struct{})
	}
	for i := range ids {
		m.hostservices[ids[i]] = struct{}{}
	}
}

// ClearHostservices clears the "hostservices" edge to the HostService entity.
func (m *HostMutation) ClearHostservices() {
	m.clearedhostservices = true
}

// HostservicesCleared reports if the "hostservices" edge to the HostService entity was cleared.
func (m *HostMutation) HostservicesCleared() bool {
	return m.clearedhostservices
}

// RemoveHostserviceIDs removes the "hostservices" edge to the HostService entity by IDs.
func (m *HostMutation) RemoveHostserviceIDs(ids ...string) {
	if m.removedhostservices == nil {
		m.removedhostservices = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hostservices, ids[i])
		m.removedhostservices[ids[i]] = struct{}{}
	}
}

// RemovedHostservices returns the removed IDs of the "hostservices" edge to the HostService entity.
func (m *HostMutation) RemovedHostservicesIDs() (ids []string) {
	for id := range m.removedhostservices {
		ids = append(ids, id)
	}
	return
}

// HostservicesIDs returns the "hostservices" edge IDs in the mutation.
func (m *HostMutation) HostservicesIDs() (ids []string) {
	for id := range m.hostservices {
		ids = append(ids, id)
	}
	return
}

// ResetHostservices resets all changes to the "hostservices" edge.
func (m *HostMutation) ResetHostservices() {
	m.hostservices = nil
	m.clearedhostservices = false
	m.removedhostservices = nil
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *HostMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *HostMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *HostMutation) TeamIDs() (ids []string) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *HostMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// Where appends a list predicates to the HostMutation builder.
func (m *HostMutation) Where(ps ...predicate.Host) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Host, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Host).
func (m *HostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HostMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.pause != nil {
		fields = append(fields, host.FieldPause)
	}
	if m.hidden != nil {
		fields = append(fields, host.FieldHidden)
	}
	if m.address != nil {
		fields = append(fields, host.FieldAddress)
	}
	if m.team != nil {
		fields = append(fields, host.FieldTeamID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case host.FieldPause:
		return m.Pause()
	case host.FieldHidden:
		return m.Hidden()
	case host.FieldAddress:
		return m.Address()
	case host.FieldTeamID:
		return m.TeamID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case host.FieldPause:
		return m.OldPause(ctx)
	case host.FieldHidden:
		return m.OldHidden(ctx)
	case host.FieldAddress:
		return m.OldAddress(ctx)
	case host.FieldTeamID:
		return m.OldTeamID(ctx)
	}
	return nil, fmt.Errorf("unknown Host field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case host.FieldPause:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPause(v)
		return nil
	case host.FieldHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHidden(v)
		return nil
	case host.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case host.FieldTeamID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	}
	return fmt.Errorf("unknown Host field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Host numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(host.FieldPause) {
		fields = append(fields, host.FieldPause)
	}
	if m.FieldCleared(host.FieldHidden) {
		fields = append(fields, host.FieldHidden)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HostMutation) ClearField(name string) error {
	switch name {
	case host.FieldPause:
		m.ClearPause()
		return nil
	case host.FieldHidden:
		m.ClearHidden()
		return nil
	}
	return fmt.Errorf("unknown Host nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HostMutation) ResetField(name string) error {
	switch name {
	case host.FieldPause:
		m.ResetPause()
		return nil
	case host.FieldHidden:
		m.ResetHidden()
		return nil
	case host.FieldAddress:
		m.ResetAddress()
		return nil
	case host.FieldTeamID:
		m.ResetTeamID()
		return nil
	}
	return fmt.Errorf("unknown Host field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HostMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.hostservices != nil {
		edges = append(edges, host.EdgeHostservices)
	}
	if m.team != nil {
		edges = append(edges, host.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case host.EdgeHostservices:
		ids := make([]ent.Value, 0, len(m.hostservices))
		for id := range m.hostservices {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedhostservices != nil {
		edges = append(edges, host.EdgeHostservices)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case host.EdgeHostservices:
		ids := make([]ent.Value, 0, len(m.removedhostservices))
		for id := range m.removedhostservices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedhostservices {
		edges = append(edges, host.EdgeHostservices)
	}
	if m.clearedteam {
		edges = append(edges, host.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HostMutation) EdgeCleared(name string) bool {
	switch name {
	case host.EdgeHostservices:
		return m.clearedhostservices
	case host.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HostMutation) ClearEdge(name string) error {
	switch name {
	case host.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown Host unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HostMutation) ResetEdge(name string) error {
	switch name {
	case host.EdgeHostservices:
		m.ResetHostservices()
		return nil
	case host.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown Host edge %s", name)
}

// HostServiceMutation represents an operation that mutates the HostService nodes in the graph.
type HostServiceMutation struct {
	config
	op                Op
	typ               string
	id                *string
	name              *string
	display_name      *string
	pause             *bool
	hidden            *bool
	weight            *int
	addweight         *int
	point_boost       *int
	addpoint_boost    *int
	round_units       *int
	addround_units    *int
	round_delay       *int
	addround_delay    *int
	clearedFields     map[string]struct{}
	host              *string
	clearedhost       bool
	checks            map[string]struct{}
	removedchecks     map[string]struct{}
	clearedchecks     bool
	properties        map[string]struct{}
	removedproperties map[string]struct{}
	clearedproperties bool
	team              *string
	clearedteam       bool
	done              bool
	oldValue          func(context.Context) (*HostService, error)
	predicates        []predicate.HostService
}

var _ ent.Mutation = (*HostServiceMutation)(nil)

// hostserviceOption allows management of the mutation configuration using functional options.
type hostserviceOption func(*HostServiceMutation)

// newHostServiceMutation creates new mutation for the HostService entity.
func newHostServiceMutation(c config, op Op, opts ...hostserviceOption) *HostServiceMutation {
	m := &HostServiceMutation{
		config:        c,
		op:            op,
		typ:           TypeHostService,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHostServiceID sets the ID field of the mutation.
func withHostServiceID(id string) hostserviceOption {
	return func(m *HostServiceMutation) {
		var (
			err   error
			once  sync.Once
			value *HostService
		)
		m.oldValue = func(ctx context.Context) (*HostService, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HostService.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHostService sets the old HostService of the mutation.
func withHostService(node *HostService) hostserviceOption {
	return func(m *HostServiceMutation) {
		m.oldValue = func(context.Context) (*HostService, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HostServiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HostServiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entities: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HostService entities.
func (m *HostServiceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HostServiceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HostServiceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HostService.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *HostServiceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HostServiceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the HostService entity.
// If the HostService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostServiceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *HostServiceMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *HostServiceMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *HostServiceMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the HostService entity.
// If the HostService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostServiceMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *HostServiceMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetPause sets the "pause" field.
func (m *HostServiceMutation) SetPause(b bool) {
	m.pause = &b
}

// Pause returns the value of the "pause" field in the mutation.
func (m *HostServiceMutation) Pause() (r bool, exists bool) {
	v := m.pause
	if v == nil {
		return
	}
	return *v, true
}

// OldPause returns the old "pause" field's value of the HostService entity.
// If the HostService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostServiceMutation) OldPause(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPause is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPause requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPause: %w", err)
	}
	return oldValue.Pause, nil
}

// ClearPause clears the value of the "pause" field.
func (m *HostServiceMutation) ClearPause() {
	m.pause = nil
	m.clearedFields[hostservice.FieldPause] = struct{}{}
}

// PauseCleared returns if the "pause" field was cleared in this mutation.
func (m *HostServiceMutation) PauseCleared() bool {
	_, ok := m.clearedFields[hostservice.FieldPause]
	return ok
}

// ResetPause resets all changes to the "pause" field.
func (m *HostServiceMutation) ResetPause() {
	m.pause = nil
	delete(m.clearedFields, hostservice.FieldPause)
}

// SetHidden sets the "hidden" field.
func (m *HostServiceMutation) SetHidden(b bool) {
	m.hidden = &b
}

// Hidden returns the value of the "hidden" field in the mutation.
func (m *HostServiceMutation) Hidden() (r bool, exists bool) {
	v := m.hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldHidden returns the old "hidden" field's value of the HostService entity.
// If the HostService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostServiceMutation) OldHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHidden: %w", err)
	}
	return oldValue.Hidden, nil
}

// ClearHidden clears the value of the "hidden" field.
func (m *HostServiceMutation) ClearHidden() {
	m.hidden = nil
	m.clearedFields[hostservice.FieldHidden] = struct{}{}
}

// HiddenCleared returns if the "hidden" field was cleared in this mutation.
func (m *HostServiceMutation) HiddenCleared() bool {
	_, ok := m.clearedFields[hostservice.FieldHidden]
	return ok
}

// ResetHidden resets all changes to the "hidden" field.
func (m *HostServiceMutation) ResetHidden() {
	m.hidden = nil
	delete(m.clearedFields, hostservice.FieldHidden)
}

// SetWeight sets the "weight" field.
func (m *HostServiceMutation) SetWeight(i int) {
	m.weight = &i
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *HostServiceMutation) Weight() (r int, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the HostService entity.
// If the HostService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostServiceMutation) OldWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds i to the "weight" field.
func (m *HostServiceMutation) AddWeight(i int) {
	if m.addweight != nil {
		*m.addweight += i
	} else {
		m.addweight = &i
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *HostServiceMutation) AddedWeight() (r int, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight resets all changes to the "weight" field.
func (m *HostServiceMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// SetPointBoost sets the "point_boost" field.
func (m *HostServiceMutation) SetPointBoost(i int) {
	m.point_boost = &i
	m.addpoint_boost = nil
}

// PointBoost returns the value of the "point_boost" field in the mutation.
func (m *HostServiceMutation) PointBoost() (r int, exists bool) {
	v := m.point_boost
	if v == nil {
		return
	}
	return *v, true
}

// OldPointBoost returns the old "point_boost" field's value of the HostService entity.
// If the HostService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostServiceMutation) OldPointBoost(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPointBoost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPointBoost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPointBoost: %w", err)
	}
	return oldValue.PointBoost, nil
}

// AddPointBoost adds i to the "point_boost" field.
func (m *HostServiceMutation) AddPointBoost(i int) {
	if m.addpoint_boost != nil {
		*m.addpoint_boost += i
	} else {
		m.addpoint_boost = &i
	}
}

// AddedPointBoost returns the value that was added to the "point_boost" field in this mutation.
func (m *HostServiceMutation) AddedPointBoost() (r int, exists bool) {
	v := m.addpoint_boost
	if v == nil {
		return
	}
	return *v, true
}

// ResetPointBoost resets all changes to the "point_boost" field.
func (m *HostServiceMutation) ResetPointBoost() {
	m.point_boost = nil
	m.addpoint_boost = nil
}

// SetRoundUnits sets the "round_units" field.
func (m *HostServiceMutation) SetRoundUnits(i int) {
	m.round_units = &i
	m.addround_units = nil
}

// RoundUnits returns the value of the "round_units" field in the mutation.
func (m *HostServiceMutation) RoundUnits() (r int, exists bool) {
	v := m.round_units
	if v == nil {
		return
	}
	return *v, true
}

// OldRoundUnits returns the old "round_units" field's value of the HostService entity.
// If the HostService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostServiceMutation) OldRoundUnits(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoundUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoundUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoundUnits: %w", err)
	}
	return oldValue.RoundUnits, nil
}

// AddRoundUnits adds i to the "round_units" field.
func (m *HostServiceMutation) AddRoundUnits(i int) {
	if m.addround_units != nil {
		*m.addround_units += i
	} else {
		m.addround_units = &i
	}
}

// AddedRoundUnits returns the value that was added to the "round_units" field in this mutation.
func (m *HostServiceMutation) AddedRoundUnits() (r int, exists bool) {
	v := m.addround_units
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoundUnits resets all changes to the "round_units" field.
func (m *HostServiceMutation) ResetRoundUnits() {
	m.round_units = nil
	m.addround_units = nil
}

// SetRoundDelay sets the "round_delay" field.
func (m *HostServiceMutation) SetRoundDelay(i int) {
	m.round_delay = &i
	m.addround_delay = nil
}

// RoundDelay returns the value of the "round_delay" field in the mutation.
func (m *HostServiceMutation) RoundDelay() (r int, exists bool) {
	v := m.round_delay
	if v == nil {
		return
	}
	return *v, true
}

// OldRoundDelay returns the old "round_delay" field's value of the HostService entity.
// If the HostService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostServiceMutation) OldRoundDelay(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoundDelay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoundDelay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoundDelay: %w", err)
	}
	return oldValue.RoundDelay, nil
}

// AddRoundDelay adds i to the "round_delay" field.
func (m *HostServiceMutation) AddRoundDelay(i int) {
	if m.addround_delay != nil {
		*m.addround_delay += i
	} else {
		m.addround_delay = &i
	}
}

// AddedRoundDelay returns the value that was added to the "round_delay" field in this mutation.
func (m *HostServiceMutation) AddedRoundDelay() (r int, exists bool) {
	v := m.addround_delay
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoundDelay resets all changes to the "round_delay" field.
func (m *HostServiceMutation) ResetRoundDelay() {
	m.round_delay = nil
	m.addround_delay = nil
}

// SetHostID sets the "host_id" field.
func (m *HostServiceMutation) SetHostID(s string) {
	m.host = &s
}

// HostID returns the value of the "host_id" field in the mutation.
func (m *HostServiceMutation) HostID() (r string, exists bool) {
	v := m.host
	if v == nil {
		return
	}
	return *v, true
}

// OldHostID returns the old "host_id" field's value of the HostService entity.
// If the HostService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostServiceMutation) OldHostID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostID: %w", err)
	}
	return oldValue.HostID, nil
}

// ResetHostID resets all changes to the "host_id" field.
func (m *HostServiceMutation) ResetHostID() {
	m.host = nil
}

// SetTeamID sets the "team_id" field.
func (m *HostServiceMutation) SetTeamID(s string) {
	m.team = &s
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *HostServiceMutation) TeamID() (r string, exists bool) {
	v := m.team
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the HostService entity.
// If the HostService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostServiceMutation) OldTeamID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *HostServiceMutation) ResetTeamID() {
	m.team = nil
}

// ClearHost clears the "host" edge to the Host entity.
func (m *HostServiceMutation) ClearHost() {
	m.clearedhost = true
}

// HostCleared reports if the "host" edge to the Host entity was cleared.
func (m *HostServiceMutation) HostCleared() bool {
	return m.clearedhost
}

// HostIDs returns the "host" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostID instead. It exists only for internal usage by the builders.
func (m *HostServiceMutation) HostIDs() (ids []string) {
	if id := m.host; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHost resets all changes to the "host" edge.
func (m *HostServiceMutation) ResetHost() {
	m.host = nil
	m.clearedhost = false
}

// AddCheckIDs adds the "checks" edge to the Check entity by ids.
func (m *HostServiceMutation) AddCheckIDs(ids ...string) {
	if m.checks == nil {
		m.checks = make(map[string]struct{})
	}
	for i := range ids {
		m.checks[ids[i]] = struct{}{}
	}
}

// ClearChecks clears the "checks" edge to the Check entity.
func (m *HostServiceMutation) ClearChecks() {
	m.clearedchecks = true
}

// ChecksCleared reports if the "checks" edge to the Check entity was cleared.
func (m *HostServiceMutation) ChecksCleared() bool {
	return m.clearedchecks
}

// RemoveCheckIDs removes the "checks" edge to the Check entity by IDs.
func (m *HostServiceMutation) RemoveCheckIDs(ids ...string) {
	if m.removedchecks == nil {
		m.removedchecks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.checks, ids[i])
		m.removedchecks[ids[i]] = struct{}{}
	}
}

// RemovedChecks returns the removed IDs of the "checks" edge to the Check entity.
func (m *HostServiceMutation) RemovedChecksIDs() (ids []string) {
	for id := range m.removedchecks {
		ids = append(ids, id)
	}
	return
}

// ChecksIDs returns the "checks" edge IDs in the mutation.
func (m *HostServiceMutation) ChecksIDs() (ids []string) {
	for id := range m.checks {
		ids = append(ids, id)
	}
	return
}

// ResetChecks resets all changes to the "checks" edge.
func (m *HostServiceMutation) ResetChecks() {
	m.checks = nil
	m.clearedchecks = false
	m.removedchecks = nil
}

// AddPropertyIDs adds the "properties" edge to the Property entity by ids.
func (m *HostServiceMutation) AddPropertyIDs(ids ...string) {
	if m.properties == nil {
		m.properties = make(map[string]struct{})
	}
	for i := range ids {
		m.properties[ids[i]] = struct{}{}
	}
}

// ClearProperties clears the "properties" edge to the Property entity.
func (m *HostServiceMutation) ClearProperties() {
	m.clearedproperties = true
}

// PropertiesCleared reports if the "properties" edge to the Property entity was cleared.
func (m *HostServiceMutation) PropertiesCleared() bool {
	return m.clearedproperties
}

// RemovePropertyIDs removes the "properties" edge to the Property entity by IDs.
func (m *HostServiceMutation) RemovePropertyIDs(ids ...string) {
	if m.removedproperties == nil {
		m.removedproperties = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.properties, ids[i])
		m.removedproperties[ids[i]] = struct{}{}
	}
}

// RemovedProperties returns the removed IDs of the "properties" edge to the Property entity.
func (m *HostServiceMutation) RemovedPropertiesIDs() (ids []string) {
	for id := range m.removedproperties {
		ids = append(ids, id)
	}
	return
}

// PropertiesIDs returns the "properties" edge IDs in the mutation.
func (m *HostServiceMutation) PropertiesIDs() (ids []string) {
	for id := range m.properties {
		ids = append(ids, id)
	}
	return
}

// ResetProperties resets all changes to the "properties" edge.
func (m *HostServiceMutation) ResetProperties() {
	m.properties = nil
	m.clearedproperties = false
	m.removedproperties = nil
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *HostServiceMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *HostServiceMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *HostServiceMutation) TeamIDs() (ids []string) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *HostServiceMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// Where appends a list predicates to the HostServiceMutation builder.
func (m *HostServiceMutation) Where(ps ...predicate.HostService) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HostServiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HostServiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HostService, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HostServiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HostServiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HostService).
func (m *HostServiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HostServiceMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, hostservice.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, hostservice.FieldDisplayName)
	}
	if m.pause != nil {
		fields = append(fields, hostservice.FieldPause)
	}
	if m.hidden != nil {
		fields = append(fields, hostservice.FieldHidden)
	}
	if m.weight != nil {
		fields = append(fields, hostservice.FieldWeight)
	}
	if m.point_boost != nil {
		fields = append(fields, hostservice.FieldPointBoost)
	}
	if m.round_units != nil {
		fields = append(fields, hostservice.FieldRoundUnits)
	}
	if m.round_delay != nil {
		fields = append(fields, hostservice.FieldRoundDelay)
	}
	if m.host != nil {
		fields = append(fields, hostservice.FieldHostID)
	}
	if m.team != nil {
		fields = append(fields, hostservice.FieldTeamID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HostServiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hostservice.FieldName:
		return m.Name()
	case hostservice.FieldDisplayName:
		return m.DisplayName()
	case hostservice.FieldPause:
		return m.Pause()
	case hostservice.FieldHidden:
		return m.Hidden()
	case hostservice.FieldWeight:
		return m.Weight()
	case hostservice.FieldPointBoost:
		return m.PointBoost()
	case hostservice.FieldRoundUnits:
		return m.RoundUnits()
	case hostservice.FieldRoundDelay:
		return m.RoundDelay()
	case hostservice.FieldHostID:
		return m.HostID()
	case hostservice.FieldTeamID:
		return m.TeamID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HostServiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hostservice.FieldName:
		return m.OldName(ctx)
	case hostservice.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case hostservice.FieldPause:
		return m.OldPause(ctx)
	case hostservice.FieldHidden:
		return m.OldHidden(ctx)
	case hostservice.FieldWeight:
		return m.OldWeight(ctx)
	case hostservice.FieldPointBoost:
		return m.OldPointBoost(ctx)
	case hostservice.FieldRoundUnits:
		return m.OldRoundUnits(ctx)
	case hostservice.FieldRoundDelay:
		return m.OldRoundDelay(ctx)
	case hostservice.FieldHostID:
		return m.OldHostID(ctx)
	case hostservice.FieldTeamID:
		return m.OldTeamID(ctx)
	}
	return nil, fmt.Errorf("unknown HostService field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostServiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hostservice.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case hostservice.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case hostservice.FieldPause:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPause(v)
		return nil
	case hostservice.FieldHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHidden(v)
		return nil
	case hostservice.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case hostservice.FieldPointBoost:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPointBoost(v)
		return nil
	case hostservice.FieldRoundUnits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoundUnits(v)
		return nil
	case hostservice.FieldRoundDelay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoundDelay(v)
		return nil
	case hostservice.FieldHostID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostID(v)
		return nil
	case hostservice.FieldTeamID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	}
	return fmt.Errorf("unknown HostService field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HostServiceMutation) AddedFields() []string {
	var fields []string
	if m.addweight != nil {
		fields = append(fields, hostservice.FieldWeight)
	}
	if m.addpoint_boost != nil {
		fields = append(fields, hostservice.FieldPointBoost)
	}
	if m.addround_units != nil {
		fields = append(fields, hostservice.FieldRoundUnits)
	}
	if m.addround_delay != nil {
		fields = append(fields, hostservice.FieldRoundDelay)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HostServiceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hostservice.FieldWeight:
		return m.AddedWeight()
	case hostservice.FieldPointBoost:
		return m.AddedPointBoost()
	case hostservice.FieldRoundUnits:
		return m.AddedRoundUnits()
	case hostservice.FieldRoundDelay:
		return m.AddedRoundDelay()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostServiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hostservice.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	case hostservice.FieldPointBoost:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPointBoost(v)
		return nil
	case hostservice.FieldRoundUnits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoundUnits(v)
		return nil
	case hostservice.FieldRoundDelay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoundDelay(v)
		return nil
	}
	return fmt.Errorf("unknown HostService numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HostServiceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hostservice.FieldPause) {
		fields = append(fields, hostservice.FieldPause)
	}
	if m.FieldCleared(hostservice.FieldHidden) {
		fields = append(fields, hostservice.FieldHidden)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HostServiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HostServiceMutation) ClearField(name string) error {
	switch name {
	case hostservice.FieldPause:
		m.ClearPause()
		return nil
	case hostservice.FieldHidden:
		m.ClearHidden()
		return nil
	}
	return fmt.Errorf("unknown HostService nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HostServiceMutation) ResetField(name string) error {
	switch name {
	case hostservice.FieldName:
		m.ResetName()
		return nil
	case hostservice.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case hostservice.FieldPause:
		m.ResetPause()
		return nil
	case hostservice.FieldHidden:
		m.ResetHidden()
		return nil
	case hostservice.FieldWeight:
		m.ResetWeight()
		return nil
	case hostservice.FieldPointBoost:
		m.ResetPointBoost()
		return nil
	case hostservice.FieldRoundUnits:
		m.ResetRoundUnits()
		return nil
	case hostservice.FieldRoundDelay:
		m.ResetRoundDelay()
		return nil
	case hostservice.FieldHostID:
		m.ResetHostID()
		return nil
	case hostservice.FieldTeamID:
		m.ResetTeamID()
		return nil
	}
	return fmt.Errorf("unknown HostService field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HostServiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.host != nil {
		edges = append(edges, hostservice.EdgeHost)
	}
	if m.checks != nil {
		edges = append(edges, hostservice.EdgeChecks)
	}
	if m.properties != nil {
		edges = append(edges, hostservice.EdgeProperties)
	}
	if m.team != nil {
		edges = append(edges, hostservice.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HostServiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hostservice.EdgeHost:
		if id := m.host; id != nil {
			return []ent.Value{*id}
		}
	case hostservice.EdgeChecks:
		ids := make([]ent.Value, 0, len(m.checks))
		for id := range m.checks {
			ids = append(ids, id)
		}
		return ids
	case hostservice.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.properties))
		for id := range m.properties {
			ids = append(ids, id)
		}
		return ids
	case hostservice.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HostServiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchecks != nil {
		edges = append(edges, hostservice.EdgeChecks)
	}
	if m.removedproperties != nil {
		edges = append(edges, hostservice.EdgeProperties)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HostServiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hostservice.EdgeChecks:
		ids := make([]ent.Value, 0, len(m.removedchecks))
		for id := range m.removedchecks {
			ids = append(ids, id)
		}
		return ids
	case hostservice.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.removedproperties))
		for id := range m.removedproperties {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HostServiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedhost {
		edges = append(edges, hostservice.EdgeHost)
	}
	if m.clearedchecks {
		edges = append(edges, hostservice.EdgeChecks)
	}
	if m.clearedproperties {
		edges = append(edges, hostservice.EdgeProperties)
	}
	if m.clearedteam {
		edges = append(edges, hostservice.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HostServiceMutation) EdgeCleared(name string) bool {
	switch name {
	case hostservice.EdgeHost:
		return m.clearedhost
	case hostservice.EdgeChecks:
		return m.clearedchecks
	case hostservice.EdgeProperties:
		return m.clearedproperties
	case hostservice.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HostServiceMutation) ClearEdge(name string) error {
	switch name {
	case hostservice.EdgeHost:
		m.ClearHost()
		return nil
	case hostservice.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown HostService unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HostServiceMutation) ResetEdge(name string) error {
	switch name {
	case hostservice.EdgeHost:
		m.ResetHost()
		return nil
	case hostservice.EdgeChecks:
		m.ResetChecks()
		return nil
	case hostservice.EdgeProperties:
		m.ResetProperties()
		return nil
	case hostservice.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown HostService edge %s", name)
}

// PropertyMutation represents an operation that mutates the Property nodes in the graph.
type PropertyMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	key                *string
	value              *string
	status             *property.Status
	clearedFields      map[string]struct{}
	hostservice        *string
	clearedhostservice bool
	team               *string
	clearedteam        bool
	done               bool
	oldValue           func(context.Context) (*Property, error)
	predicates         []predicate.Property
}

var _ ent.Mutation = (*PropertyMutation)(nil)

// propertyOption allows management of the mutation configuration using functional options.
type propertyOption func(*PropertyMutation)

// newPropertyMutation creates new mutation for the Property entity.
func newPropertyMutation(c config, op Op, opts ...propertyOption) *PropertyMutation {
	m := &PropertyMutation{
		config:        c,
		op:            op,
		typ:           TypeProperty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPropertyID sets the ID field of the mutation.
func withPropertyID(id string) propertyOption {
	return func(m *PropertyMutation) {
		var (
			err   error
			once  sync.Once
			value *Property
		)
		m.oldValue = func(ctx context.Context) (*Property, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Property.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProperty sets the old Property of the mutation.
func withProperty(node *Property) propertyOption {
	return func(m *PropertyMutation) {
		m.oldValue = func(context.Context) (*Property, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PropertyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PropertyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entities: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Property entities.
func (m *PropertyMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PropertyMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PropertyMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Property.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *PropertyMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *PropertyMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *PropertyMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *PropertyMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *PropertyMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *PropertyMutation) ResetValue() {
	m.value = nil
}

// SetStatus sets the "status" field.
func (m *PropertyMutation) SetStatus(pr property.Status) {
	m.status = &pr
}

// Status returns the value of the "status" field in the mutation.
func (m *PropertyMutation) Status() (r property.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldStatus(ctx context.Context) (v property.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PropertyMutation) ResetStatus() {
	m.status = nil
}

// SetHostServiceID sets the "host_service_id" field.
func (m *PropertyMutation) SetHostServiceID(s string) {
	m.hostservice = &s
}

// HostServiceID returns the value of the "host_service_id" field in the mutation.
func (m *PropertyMutation) HostServiceID() (r string, exists bool) {
	v := m.hostservice
	if v == nil {
		return
	}
	return *v, true
}

// OldHostServiceID returns the old "host_service_id" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldHostServiceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostServiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostServiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostServiceID: %w", err)
	}
	return oldValue.HostServiceID, nil
}

// ResetHostServiceID resets all changes to the "host_service_id" field.
func (m *PropertyMutation) ResetHostServiceID() {
	m.hostservice = nil
}

// SetTeamID sets the "team_id" field.
func (m *PropertyMutation) SetTeamID(s string) {
	m.team = &s
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *PropertyMutation) TeamID() (r string, exists bool) {
	v := m.team
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldTeamID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *PropertyMutation) ResetTeamID() {
	m.team = nil
}

// SetHostserviceID sets the "hostservice" edge to the HostService entity by id.
func (m *PropertyMutation) SetHostserviceID(id string) {
	m.hostservice = &id
}

// ClearHostservice clears the "hostservice" edge to the HostService entity.
func (m *PropertyMutation) ClearHostservice() {
	m.clearedhostservice = true
}

// HostserviceCleared reports if the "hostservice" edge to the HostService entity was cleared.
func (m *PropertyMutation) HostserviceCleared() bool {
	return m.clearedhostservice
}

// HostserviceID returns the "hostservice" edge ID in the mutation.
func (m *PropertyMutation) HostserviceID() (id string, exists bool) {
	if m.hostservice != nil {
		return *m.hostservice, true
	}
	return
}

// HostserviceIDs returns the "hostservice" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostserviceID instead. It exists only for internal usage by the builders.
func (m *PropertyMutation) HostserviceIDs() (ids []string) {
	if id := m.hostservice; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHostservice resets all changes to the "hostservice" edge.
func (m *PropertyMutation) ResetHostservice() {
	m.hostservice = nil
	m.clearedhostservice = false
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *PropertyMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *PropertyMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *PropertyMutation) TeamIDs() (ids []string) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *PropertyMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// Where appends a list predicates to the PropertyMutation builder.
func (m *PropertyMutation) Where(ps ...predicate.Property) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PropertyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PropertyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Property, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PropertyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PropertyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Property).
func (m *PropertyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PropertyMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.key != nil {
		fields = append(fields, property.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, property.FieldValue)
	}
	if m.status != nil {
		fields = append(fields, property.FieldStatus)
	}
	if m.hostservice != nil {
		fields = append(fields, property.FieldHostServiceID)
	}
	if m.team != nil {
		fields = append(fields, property.FieldTeamID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PropertyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case property.FieldKey:
		return m.Key()
	case property.FieldValue:
		return m.Value()
	case property.FieldStatus:
		return m.Status()
	case property.FieldHostServiceID:
		return m.HostServiceID()
	case property.FieldTeamID:
		return m.TeamID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PropertyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case property.FieldKey:
		return m.OldKey(ctx)
	case property.FieldValue:
		return m.OldValue(ctx)
	case property.FieldStatus:
		return m.OldStatus(ctx)
	case property.FieldHostServiceID:
		return m.OldHostServiceID(ctx)
	case property.FieldTeamID:
		return m.OldTeamID(ctx)
	}
	return nil, fmt.Errorf("unknown Property field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PropertyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case property.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case property.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case property.FieldStatus:
		v, ok := value.(property.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case property.FieldHostServiceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostServiceID(v)
		return nil
	case property.FieldTeamID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	}
	return fmt.Errorf("unknown Property field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PropertyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PropertyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PropertyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Property numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PropertyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PropertyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PropertyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Property nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PropertyMutation) ResetField(name string) error {
	switch name {
	case property.FieldKey:
		m.ResetKey()
		return nil
	case property.FieldValue:
		m.ResetValue()
		return nil
	case property.FieldStatus:
		m.ResetStatus()
		return nil
	case property.FieldHostServiceID:
		m.ResetHostServiceID()
		return nil
	case property.FieldTeamID:
		m.ResetTeamID()
		return nil
	}
	return fmt.Errorf("unknown Property field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PropertyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.hostservice != nil {
		edges = append(edges, property.EdgeHostservice)
	}
	if m.team != nil {
		edges = append(edges, property.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PropertyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case property.EdgeHostservice:
		if id := m.hostservice; id != nil {
			return []ent.Value{*id}
		}
	case property.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PropertyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PropertyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PropertyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedhostservice {
		edges = append(edges, property.EdgeHostservice)
	}
	if m.clearedteam {
		edges = append(edges, property.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PropertyMutation) EdgeCleared(name string) bool {
	switch name {
	case property.EdgeHostservice:
		return m.clearedhostservice
	case property.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PropertyMutation) ClearEdge(name string) error {
	switch name {
	case property.EdgeHostservice:
		m.ClearHostservice()
		return nil
	case property.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown Property unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PropertyMutation) ResetEdge(name string) error {
	switch name {
	case property.EdgeHostservice:
		m.ResetHostservice()
		return nil
	case property.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown Property edge %s", name)
}

// ReportMutation represents an operation that mutates the Report nodes in the graph.
type ReportMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	log                *string
	error              *string
	clearedFields      map[string]struct{}
	competition        *string
	clearedcompetition bool
	done               bool
	oldValue           func(context.Context) (*Report, error)
	predicates         []predicate.Report
}

var _ ent.Mutation = (*ReportMutation)(nil)

// reportOption allows management of the mutation configuration using functional options.
type reportOption func(*ReportMutation)

// newReportMutation creates new mutation for the Report entity.
func newReportMutation(c config, op Op, opts ...reportOption) *ReportMutation {
	m := &ReportMutation{
		config:        c,
		op:            op,
		typ:           TypeReport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReportID sets the ID field of the mutation.
func withReportID(id int) reportOption {
	return func(m *ReportMutation) {
		var (
			err   error
			once  sync.Once
			value *Report
		)
		m.oldValue = func(ctx context.Context) (*Report, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Report.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReport sets the old Report of the mutation.
func withReport(node *Report) reportOption {
	return func(m *ReportMutation) {
		m.oldValue = func(context.Context) (*Report, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entities: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReportMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReportMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Report.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLog sets the "log" field.
func (m *ReportMutation) SetLog(s string) {
	m.log = &s
}

// Log returns the value of the "log" field in the mutation.
func (m *ReportMutation) Log() (r string, exists bool) {
	v := m.log
	if v == nil {
		return
	}
	return *v, true
}

// OldLog returns the old "log" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldLog(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLog is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLog requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLog: %w", err)
	}
	return oldValue.Log, nil
}

// ResetLog resets all changes to the "log" field.
func (m *ReportMutation) ResetLog() {
	m.log = nil
}

// SetError sets the "error" field.
func (m *ReportMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *ReportMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ResetError resets all changes to the "error" field.
func (m *ReportMutation) ResetError() {
	m.error = nil
}

// SetCompetitionID sets the "competition_id" field.
func (m *ReportMutation) SetCompetitionID(s string) {
	m.competition = &s
}

// CompetitionID returns the value of the "competition_id" field in the mutation.
func (m *ReportMutation) CompetitionID() (r string, exists bool) {
	v := m.competition
	if v == nil {
		return
	}
	return *v, true
}

// OldCompetitionID returns the old "competition_id" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldCompetitionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompetitionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompetitionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompetitionID: %w", err)
	}
	return oldValue.CompetitionID, nil
}

// ResetCompetitionID resets all changes to the "competition_id" field.
func (m *ReportMutation) ResetCompetitionID() {
	m.competition = nil
}

// ClearCompetition clears the "competition" edge to the Competition entity.
func (m *ReportMutation) ClearCompetition() {
	m.clearedcompetition = true
}

// CompetitionCleared reports if the "competition" edge to the Competition entity was cleared.
func (m *ReportMutation) CompetitionCleared() bool {
	return m.clearedcompetition
}

// CompetitionIDs returns the "competition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompetitionID instead. It exists only for internal usage by the builders.
func (m *ReportMutation) CompetitionIDs() (ids []string) {
	if id := m.competition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompetition resets all changes to the "competition" edge.
func (m *ReportMutation) ResetCompetition() {
	m.competition = nil
	m.clearedcompetition = false
}

// Where appends a list predicates to the ReportMutation builder.
func (m *ReportMutation) Where(ps ...predicate.Report) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Report, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Report).
func (m *ReportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReportMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.log != nil {
		fields = append(fields, report.FieldLog)
	}
	if m.error != nil {
		fields = append(fields, report.FieldError)
	}
	if m.competition != nil {
		fields = append(fields, report.FieldCompetitionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case report.FieldLog:
		return m.Log()
	case report.FieldError:
		return m.Error()
	case report.FieldCompetitionID:
		return m.CompetitionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case report.FieldLog:
		return m.OldLog(ctx)
	case report.FieldError:
		return m.OldError(ctx)
	case report.FieldCompetitionID:
		return m.OldCompetitionID(ctx)
	}
	return nil, fmt.Errorf("unknown Report field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case report.FieldLog:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLog(v)
		return nil
	case report.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case report.FieldCompetitionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompetitionID(v)
		return nil
	}
	return fmt.Errorf("unknown Report field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReportMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReportMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReportMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Report numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReportMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReportMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Report nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReportMutation) ResetField(name string) error {
	switch name {
	case report.FieldLog:
		m.ResetLog()
		return nil
	case report.FieldError:
		m.ResetError()
		return nil
	case report.FieldCompetitionID:
		m.ResetCompetitionID()
		return nil
	}
	return fmt.Errorf("unknown Report field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReportMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.competition != nil {
		edges = append(edges, report.EdgeCompetition)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case report.EdgeCompetition:
		if id := m.competition; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReportMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcompetition {
		edges = append(edges, report.EdgeCompetition)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReportMutation) EdgeCleared(name string) bool {
	switch name {
	case report.EdgeCompetition:
		return m.clearedcompetition
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReportMutation) ClearEdge(name string) error {
	switch name {
	case report.EdgeCompetition:
		m.ClearCompetition()
		return nil
	}
	return fmt.Errorf("unknown Report unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReportMutation) ResetEdge(name string) error {
	switch name {
	case report.EdgeCompetition:
		m.ResetCompetition()
		return nil
	}
	return fmt.Errorf("unknown Report edge %s", name)
}

// RoundMutation represents an operation that mutates the Round nodes in the graph.
type RoundMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	round_number       *int
	addround_number    *int
	note               *string
	err                *string
	started_at         *time.Time
	finished_at        *time.Time
	clearedFields      map[string]struct{}
	checks             map[string]struct{}
	removedchecks      map[string]struct{}
	clearedchecks      bool
	competition        *string
	clearedcompetition bool
	done               bool
	oldValue           func(context.Context) (*Round, error)
	predicates         []predicate.Round
}

var _ ent.Mutation = (*RoundMutation)(nil)

// roundOption allows management of the mutation configuration using functional options.
type roundOption func(*RoundMutation)

// newRoundMutation creates new mutation for the Round entity.
func newRoundMutation(c config, op Op, opts ...roundOption) *RoundMutation {
	m := &RoundMutation{
		config:        c,
		op:            op,
		typ:           TypeRound,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoundID sets the ID field of the mutation.
func withRoundID(id string) roundOption {
	return func(m *RoundMutation) {
		var (
			err   error
			once  sync.Once
			value *Round
		)
		m.oldValue = func(ctx context.Context) (*Round, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Round.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRound sets the old Round of the mutation.
func withRound(node *Round) roundOption {
	return func(m *RoundMutation) {
		m.oldValue = func(context.Context) (*Round, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoundMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoundMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entities: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Round entities.
func (m *RoundMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoundMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoundMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Round.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRoundNumber sets the "round_number" field.
func (m *RoundMutation) SetRoundNumber(i int) {
	m.round_number = &i
	m.addround_number = nil
}

// RoundNumber returns the value of the "round_number" field in the mutation.
func (m *RoundMutation) RoundNumber() (r int, exists bool) {
	v := m.round_number
	if v == nil {
		return
	}
	return *v, true
}

// OldRoundNumber returns the old "round_number" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldRoundNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoundNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoundNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoundNumber: %w", err)
	}
	return oldValue.RoundNumber, nil
}

// AddRoundNumber adds i to the "round_number" field.
func (m *RoundMutation) AddRoundNumber(i int) {
	if m.addround_number != nil {
		*m.addround_number += i
	} else {
		m.addround_number = &i
	}
}

// AddedRoundNumber returns the value that was added to the "round_number" field in this mutation.
func (m *RoundMutation) AddedRoundNumber() (r int, exists bool) {
	v := m.addround_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoundNumber resets all changes to the "round_number" field.
func (m *RoundMutation) ResetRoundNumber() {
	m.round_number = nil
	m.addround_number = nil
}

// SetNote sets the "note" field.
func (m *RoundMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *RoundMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ResetNote resets all changes to the "note" field.
func (m *RoundMutation) ResetNote() {
	m.note = nil
}

// SetErr sets the "err" field.
func (m *RoundMutation) SetErr(s string) {
	m.err = &s
}

// Err returns the value of the "err" field in the mutation.
func (m *RoundMutation) Err() (r string, exists bool) {
	v := m.err
	if v == nil {
		return
	}
	return *v, true
}

// OldErr returns the old "err" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldErr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErr: %w", err)
	}
	return oldValue.Err, nil
}

// ResetErr resets all changes to the "err" field.
func (m *RoundMutation) ResetErr() {
	m.err = nil
}

// SetStartedAt sets the "started_at" field.
func (m *RoundMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *RoundMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *RoundMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetFinishedAt sets the "finished_at" field.
func (m *RoundMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *RoundMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldFinishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *RoundMutation) ResetFinishedAt() {
	m.finished_at = nil
}

// SetCompetitionID sets the "competition_id" field.
func (m *RoundMutation) SetCompetitionID(s string) {
	m.competition = &s
}

// CompetitionID returns the value of the "competition_id" field in the mutation.
func (m *RoundMutation) CompetitionID() (r string, exists bool) {
	v := m.competition
	if v == nil {
		return
	}
	return *v, true
}

// OldCompetitionID returns the old "competition_id" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldCompetitionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompetitionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompetitionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompetitionID: %w", err)
	}
	return oldValue.CompetitionID, nil
}

// ResetCompetitionID resets all changes to the "competition_id" field.
func (m *RoundMutation) ResetCompetitionID() {
	m.competition = nil
}

// AddCheckIDs adds the "checks" edge to the Check entity by ids.
func (m *RoundMutation) AddCheckIDs(ids ...string) {
	if m.checks == nil {
		m.checks = make(map[string]struct{})
	}
	for i := range ids {
		m.checks[ids[i]] = struct{}{}
	}
}

// ClearChecks clears the "checks" edge to the Check entity.
func (m *RoundMutation) ClearChecks() {
	m.clearedchecks = true
}

// ChecksCleared reports if the "checks" edge to the Check entity was cleared.
func (m *RoundMutation) ChecksCleared() bool {
	return m.clearedchecks
}

// RemoveCheckIDs removes the "checks" edge to the Check entity by IDs.
func (m *RoundMutation) RemoveCheckIDs(ids ...string) {
	if m.removedchecks == nil {
		m.removedchecks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.checks, ids[i])
		m.removedchecks[ids[i]] = struct{}{}
	}
}

// RemovedChecks returns the removed IDs of the "checks" edge to the Check entity.
func (m *RoundMutation) RemovedChecksIDs() (ids []string) {
	for id := range m.removedchecks {
		ids = append(ids, id)
	}
	return
}

// ChecksIDs returns the "checks" edge IDs in the mutation.
func (m *RoundMutation) ChecksIDs() (ids []string) {
	for id := range m.checks {
		ids = append(ids, id)
	}
	return
}

// ResetChecks resets all changes to the "checks" edge.
func (m *RoundMutation) ResetChecks() {
	m.checks = nil
	m.clearedchecks = false
	m.removedchecks = nil
}

// ClearCompetition clears the "competition" edge to the Competition entity.
func (m *RoundMutation) ClearCompetition() {
	m.clearedcompetition = true
}

// CompetitionCleared reports if the "competition" edge to the Competition entity was cleared.
func (m *RoundMutation) CompetitionCleared() bool {
	return m.clearedcompetition
}

// CompetitionIDs returns the "competition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompetitionID instead. It exists only for internal usage by the builders.
func (m *RoundMutation) CompetitionIDs() (ids []string) {
	if id := m.competition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompetition resets all changes to the "competition" edge.
func (m *RoundMutation) ResetCompetition() {
	m.competition = nil
	m.clearedcompetition = false
}

// Where appends a list predicates to the RoundMutation builder.
func (m *RoundMutation) Where(ps ...predicate.Round) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoundMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoundMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Round, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoundMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoundMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Round).
func (m *RoundMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoundMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.round_number != nil {
		fields = append(fields, round.FieldRoundNumber)
	}
	if m.note != nil {
		fields = append(fields, round.FieldNote)
	}
	if m.err != nil {
		fields = append(fields, round.FieldErr)
	}
	if m.started_at != nil {
		fields = append(fields, round.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, round.FieldFinishedAt)
	}
	if m.competition != nil {
		fields = append(fields, round.FieldCompetitionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoundMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case round.FieldRoundNumber:
		return m.RoundNumber()
	case round.FieldNote:
		return m.Note()
	case round.FieldErr:
		return m.Err()
	case round.FieldStartedAt:
		return m.StartedAt()
	case round.FieldFinishedAt:
		return m.FinishedAt()
	case round.FieldCompetitionID:
		return m.CompetitionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoundMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case round.FieldRoundNumber:
		return m.OldRoundNumber(ctx)
	case round.FieldNote:
		return m.OldNote(ctx)
	case round.FieldErr:
		return m.OldErr(ctx)
	case round.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case round.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case round.FieldCompetitionID:
		return m.OldCompetitionID(ctx)
	}
	return nil, fmt.Errorf("unknown Round field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoundMutation) SetField(name string, value ent.Value) error {
	switch name {
	case round.FieldRoundNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoundNumber(v)
		return nil
	case round.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case round.FieldErr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErr(v)
		return nil
	case round.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case round.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case round.FieldCompetitionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompetitionID(v)
		return nil
	}
	return fmt.Errorf("unknown Round field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoundMutation) AddedFields() []string {
	var fields []string
	if m.addround_number != nil {
		fields = append(fields, round.FieldRoundNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoundMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case round.FieldRoundNumber:
		return m.AddedRoundNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoundMutation) AddField(name string, value ent.Value) error {
	switch name {
	case round.FieldRoundNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoundNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Round numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoundMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoundMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoundMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Round nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoundMutation) ResetField(name string) error {
	switch name {
	case round.FieldRoundNumber:
		m.ResetRoundNumber()
		return nil
	case round.FieldNote:
		m.ResetNote()
		return nil
	case round.FieldErr:
		m.ResetErr()
		return nil
	case round.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case round.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case round.FieldCompetitionID:
		m.ResetCompetitionID()
		return nil
	}
	return fmt.Errorf("unknown Round field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoundMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.checks != nil {
		edges = append(edges, round.EdgeChecks)
	}
	if m.competition != nil {
		edges = append(edges, round.EdgeCompetition)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoundMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case round.EdgeChecks:
		ids := make([]ent.Value, 0, len(m.checks))
		for id := range m.checks {
			ids = append(ids, id)
		}
		return ids
	case round.EdgeCompetition:
		if id := m.competition; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoundMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedchecks != nil {
		edges = append(edges, round.EdgeChecks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoundMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case round.EdgeChecks:
		ids := make([]ent.Value, 0, len(m.removedchecks))
		for id := range m.removedchecks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoundMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedchecks {
		edges = append(edges, round.EdgeChecks)
	}
	if m.clearedcompetition {
		edges = append(edges, round.EdgeCompetition)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoundMutation) EdgeCleared(name string) bool {
	switch name {
	case round.EdgeChecks:
		return m.clearedchecks
	case round.EdgeCompetition:
		return m.clearedcompetition
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoundMutation) ClearEdge(name string) error {
	switch name {
	case round.EdgeCompetition:
		m.ClearCompetition()
		return nil
	}
	return fmt.Errorf("unknown Round unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoundMutation) ResetEdge(name string) error {
	switch name {
	case round.EdgeChecks:
		m.ResetChecks()
		return nil
	case round.EdgeCompetition:
		m.ResetCompetition()
		return nil
	}
	return fmt.Errorf("unknown Round edge %s", name)
}

// ServiceMutation represents an operation that mutates the Service nodes in the graph.
type ServiceMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	name               *string
	display_name       *string
	pause              *bool
	hidden             *bool
	clearedFields      map[string]struct{}
	competition        *string
	clearedcompetition bool
	done               bool
	oldValue           func(context.Context) (*Service, error)
	predicates         []predicate.Service
}

var _ ent.Mutation = (*ServiceMutation)(nil)

// serviceOption allows management of the mutation configuration using functional options.
type serviceOption func(*ServiceMutation)

// newServiceMutation creates new mutation for the Service entity.
func newServiceMutation(c config, op Op, opts ...serviceOption) *ServiceMutation {
	m := &ServiceMutation{
		config:        c,
		op:            op,
		typ:           TypeService,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceID sets the ID field of the mutation.
func withServiceID(id string) serviceOption {
	return func(m *ServiceMutation) {
		var (
			err   error
			once  sync.Once
			value *Service
		)
		m.oldValue = func(ctx context.Context) (*Service, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Service.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withService sets the old Service of the mutation.
func withService(node *Service) serviceOption {
	return func(m *ServiceMutation) {
		m.oldValue = func(context.Context) (*Service, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entities: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Service entities.
func (m *ServiceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Service.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ServiceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ServiceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ServiceMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *ServiceMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ServiceMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ServiceMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetPause sets the "pause" field.
func (m *ServiceMutation) SetPause(b bool) {
	m.pause = &b
}

// Pause returns the value of the "pause" field in the mutation.
func (m *ServiceMutation) Pause() (r bool, exists bool) {
	v := m.pause
	if v == nil {
		return
	}
	return *v, true
}

// OldPause returns the old "pause" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldPause(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPause is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPause requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPause: %w", err)
	}
	return oldValue.Pause, nil
}

// ClearPause clears the value of the "pause" field.
func (m *ServiceMutation) ClearPause() {
	m.pause = nil
	m.clearedFields[service.FieldPause] = struct{}{}
}

// PauseCleared returns if the "pause" field was cleared in this mutation.
func (m *ServiceMutation) PauseCleared() bool {
	_, ok := m.clearedFields[service.FieldPause]
	return ok
}

// ResetPause resets all changes to the "pause" field.
func (m *ServiceMutation) ResetPause() {
	m.pause = nil
	delete(m.clearedFields, service.FieldPause)
}

// SetHidden sets the "hidden" field.
func (m *ServiceMutation) SetHidden(b bool) {
	m.hidden = &b
}

// Hidden returns the value of the "hidden" field in the mutation.
func (m *ServiceMutation) Hidden() (r bool, exists bool) {
	v := m.hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldHidden returns the old "hidden" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHidden: %w", err)
	}
	return oldValue.Hidden, nil
}

// ClearHidden clears the value of the "hidden" field.
func (m *ServiceMutation) ClearHidden() {
	m.hidden = nil
	m.clearedFields[service.FieldHidden] = struct{}{}
}

// HiddenCleared returns if the "hidden" field was cleared in this mutation.
func (m *ServiceMutation) HiddenCleared() bool {
	_, ok := m.clearedFields[service.FieldHidden]
	return ok
}

// ResetHidden resets all changes to the "hidden" field.
func (m *ServiceMutation) ResetHidden() {
	m.hidden = nil
	delete(m.clearedFields, service.FieldHidden)
}

// SetCompetitionID sets the "competition_id" field.
func (m *ServiceMutation) SetCompetitionID(s string) {
	m.competition = &s
}

// CompetitionID returns the value of the "competition_id" field in the mutation.
func (m *ServiceMutation) CompetitionID() (r string, exists bool) {
	v := m.competition
	if v == nil {
		return
	}
	return *v, true
}

// OldCompetitionID returns the old "competition_id" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldCompetitionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompetitionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompetitionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompetitionID: %w", err)
	}
	return oldValue.CompetitionID, nil
}

// ResetCompetitionID resets all changes to the "competition_id" field.
func (m *ServiceMutation) ResetCompetitionID() {
	m.competition = nil
}

// ClearCompetition clears the "competition" edge to the Competition entity.
func (m *ServiceMutation) ClearCompetition() {
	m.clearedcompetition = true
}

// CompetitionCleared reports if the "competition" edge to the Competition entity was cleared.
func (m *ServiceMutation) CompetitionCleared() bool {
	return m.clearedcompetition
}

// CompetitionIDs returns the "competition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompetitionID instead. It exists only for internal usage by the builders.
func (m *ServiceMutation) CompetitionIDs() (ids []string) {
	if id := m.competition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompetition resets all changes to the "competition" edge.
func (m *ServiceMutation) ResetCompetition() {
	m.competition = nil
	m.clearedcompetition = false
}

// Where appends a list predicates to the ServiceMutation builder.
func (m *ServiceMutation) Where(ps ...predicate.Service) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Service, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Service).
func (m *ServiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, service.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, service.FieldDisplayName)
	}
	if m.pause != nil {
		fields = append(fields, service.FieldPause)
	}
	if m.hidden != nil {
		fields = append(fields, service.FieldHidden)
	}
	if m.competition != nil {
		fields = append(fields, service.FieldCompetitionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case service.FieldName:
		return m.Name()
	case service.FieldDisplayName:
		return m.DisplayName()
	case service.FieldPause:
		return m.Pause()
	case service.FieldHidden:
		return m.Hidden()
	case service.FieldCompetitionID:
		return m.CompetitionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case service.FieldName:
		return m.OldName(ctx)
	case service.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case service.FieldPause:
		return m.OldPause(ctx)
	case service.FieldHidden:
		return m.OldHidden(ctx)
	case service.FieldCompetitionID:
		return m.OldCompetitionID(ctx)
	}
	return nil, fmt.Errorf("unknown Service field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case service.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case service.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case service.FieldPause:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPause(v)
		return nil
	case service.FieldHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHidden(v)
		return nil
	case service.FieldCompetitionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompetitionID(v)
		return nil
	}
	return fmt.Errorf("unknown Service field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Service numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(service.FieldPause) {
		fields = append(fields, service.FieldPause)
	}
	if m.FieldCleared(service.FieldHidden) {
		fields = append(fields, service.FieldHidden)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceMutation) ClearField(name string) error {
	switch name {
	case service.FieldPause:
		m.ClearPause()
		return nil
	case service.FieldHidden:
		m.ClearHidden()
		return nil
	}
	return fmt.Errorf("unknown Service nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceMutation) ResetField(name string) error {
	switch name {
	case service.FieldName:
		m.ResetName()
		return nil
	case service.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case service.FieldPause:
		m.ResetPause()
		return nil
	case service.FieldHidden:
		m.ResetHidden()
		return nil
	case service.FieldCompetitionID:
		m.ResetCompetitionID()
		return nil
	}
	return fmt.Errorf("unknown Service field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.competition != nil {
		edges = append(edges, service.EdgeCompetition)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case service.EdgeCompetition:
		if id := m.competition; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcompetition {
		edges = append(edges, service.EdgeCompetition)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceMutation) EdgeCleared(name string) bool {
	switch name {
	case service.EdgeCompetition:
		return m.clearedcompetition
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceMutation) ClearEdge(name string) error {
	switch name {
	case service.EdgeCompetition:
		m.ClearCompetition()
		return nil
	}
	return fmt.Errorf("unknown Service unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceMutation) ResetEdge(name string) error {
	switch name {
	case service.EdgeCompetition:
		m.ResetCompetition()
		return nil
	}
	return fmt.Errorf("unknown Service edge %s", name)
}

// TeamMutation represents an operation that mutates the Team nodes in the graph.
type TeamMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	name                *string
	display_name        *string
	pause               *bool
	hidden              *bool
	number              *int
	addnumber           *int
	clearedFields       map[string]struct{}
	hosts               map[string]struct{}
	removedhosts        map[string]struct{}
	clearedhosts        bool
	hostservices        map[string]struct{}
	removedhostservices map[string]struct{}
	clearedhostservices bool
	checks              map[string]struct{}
	removedchecks       map[string]struct{}
	clearedchecks       bool
	properties          map[string]struct{}
	removedproperties   map[string]struct{}
	clearedproperties   bool
	competition         *string
	clearedcompetition  bool
	done                bool
	oldValue            func(context.Context) (*Team, error)
	predicates          []predicate.Team
}

var _ ent.Mutation = (*TeamMutation)(nil)

// teamOption allows management of the mutation configuration using functional options.
type teamOption func(*TeamMutation)

// newTeamMutation creates new mutation for the Team entity.
func newTeamMutation(c config, op Op, opts ...teamOption) *TeamMutation {
	m := &TeamMutation{
		config:        c,
		op:            op,
		typ:           TypeTeam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamID sets the ID field of the mutation.
func withTeamID(id string) teamOption {
	return func(m *TeamMutation) {
		var (
			err   error
			once  sync.Once
			value *Team
		)
		m.oldValue = func(ctx context.Context) (*Team, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Team.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeam sets the old Team of the mutation.
func withTeam(node *Team) teamOption {
	return func(m *TeamMutation) {
		m.oldValue = func(context.Context) (*Team, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entities: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Team entities.
func (m *TeamMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Team.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TeamMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeamMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeamMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *TeamMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *TeamMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *TeamMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetPause sets the "pause" field.
func (m *TeamMutation) SetPause(b bool) {
	m.pause = &b
}

// Pause returns the value of the "pause" field in the mutation.
func (m *TeamMutation) Pause() (r bool, exists bool) {
	v := m.pause
	if v == nil {
		return
	}
	return *v, true
}

// OldPause returns the old "pause" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldPause(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPause is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPause requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPause: %w", err)
	}
	return oldValue.Pause, nil
}

// ClearPause clears the value of the "pause" field.
func (m *TeamMutation) ClearPause() {
	m.pause = nil
	m.clearedFields[team.FieldPause] = struct{}{}
}

// PauseCleared returns if the "pause" field was cleared in this mutation.
func (m *TeamMutation) PauseCleared() bool {
	_, ok := m.clearedFields[team.FieldPause]
	return ok
}

// ResetPause resets all changes to the "pause" field.
func (m *TeamMutation) ResetPause() {
	m.pause = nil
	delete(m.clearedFields, team.FieldPause)
}

// SetHidden sets the "hidden" field.
func (m *TeamMutation) SetHidden(b bool) {
	m.hidden = &b
}

// Hidden returns the value of the "hidden" field in the mutation.
func (m *TeamMutation) Hidden() (r bool, exists bool) {
	v := m.hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldHidden returns the old "hidden" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHidden: %w", err)
	}
	return oldValue.Hidden, nil
}

// ClearHidden clears the value of the "hidden" field.
func (m *TeamMutation) ClearHidden() {
	m.hidden = nil
	m.clearedFields[team.FieldHidden] = struct{}{}
}

// HiddenCleared returns if the "hidden" field was cleared in this mutation.
func (m *TeamMutation) HiddenCleared() bool {
	_, ok := m.clearedFields[team.FieldHidden]
	return ok
}

// ResetHidden resets all changes to the "hidden" field.
func (m *TeamMutation) ResetHidden() {
	m.hidden = nil
	delete(m.clearedFields, team.FieldHidden)
}

// SetNumber sets the "number" field.
func (m *TeamMutation) SetNumber(i int) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *TeamMutation) Number() (r int, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to the "number" field.
func (m *TeamMutation) AddNumber(i int) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *TeamMutation) AddedNumber() (r int, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber resets all changes to the "number" field.
func (m *TeamMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
}

// SetCompetitionID sets the "competition_id" field.
func (m *TeamMutation) SetCompetitionID(s string) {
	m.competition = &s
}

// CompetitionID returns the value of the "competition_id" field in the mutation.
func (m *TeamMutation) CompetitionID() (r string, exists bool) {
	v := m.competition
	if v == nil {
		return
	}
	return *v, true
}

// OldCompetitionID returns the old "competition_id" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldCompetitionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompetitionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompetitionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompetitionID: %w", err)
	}
	return oldValue.CompetitionID, nil
}

// ResetCompetitionID resets all changes to the "competition_id" field.
func (m *TeamMutation) ResetCompetitionID() {
	m.competition = nil
}

// AddHostIDs adds the "hosts" edge to the Host entity by ids.
func (m *TeamMutation) AddHostIDs(ids ...string) {
	if m.hosts == nil {
		m.hosts = make(map[string]struct{})
	}
	for i := range ids {
		m.hosts[ids[i]] = struct{}{}
	}
}

// ClearHosts clears the "hosts" edge to the Host entity.
func (m *TeamMutation) ClearHosts() {
	m.clearedhosts = true
}

// HostsCleared reports if the "hosts" edge to the Host entity was cleared.
func (m *TeamMutation) HostsCleared() bool {
	return m.clearedhosts
}

// RemoveHostIDs removes the "hosts" edge to the Host entity by IDs.
func (m *TeamMutation) RemoveHostIDs(ids ...string) {
	if m.removedhosts == nil {
		m.removedhosts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hosts, ids[i])
		m.removedhosts[ids[i]] = struct{}{}
	}
}

// RemovedHosts returns the removed IDs of the "hosts" edge to the Host entity.
func (m *TeamMutation) RemovedHostsIDs() (ids []string) {
	for id := range m.removedhosts {
		ids = append(ids, id)
	}
	return
}

// HostsIDs returns the "hosts" edge IDs in the mutation.
func (m *TeamMutation) HostsIDs() (ids []string) {
	for id := range m.hosts {
		ids = append(ids, id)
	}
	return
}

// ResetHosts resets all changes to the "hosts" edge.
func (m *TeamMutation) ResetHosts() {
	m.hosts = nil
	m.clearedhosts = false
	m.removedhosts = nil
}

// AddHostserviceIDs adds the "hostservices" edge to the HostService entity by ids.
func (m *TeamMutation) AddHostserviceIDs(ids ...string) {
	if m.hostservices == nil {
		m.hostservices = make(map[string]struct{})
	}
	for i := range ids {
		m.hostservices[ids[i]] = struct{}{}
	}
}

// ClearHostservices clears the "hostservices" edge to the HostService entity.
func (m *TeamMutation) ClearHostservices() {
	m.clearedhostservices = true
}

// HostservicesCleared reports if the "hostservices" edge to the HostService entity was cleared.
func (m *TeamMutation) HostservicesCleared() bool {
	return m.clearedhostservices
}

// RemoveHostserviceIDs removes the "hostservices" edge to the HostService entity by IDs.
func (m *TeamMutation) RemoveHostserviceIDs(ids ...string) {
	if m.removedhostservices == nil {
		m.removedhostservices = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hostservices, ids[i])
		m.removedhostservices[ids[i]] = struct{}{}
	}
}

// RemovedHostservices returns the removed IDs of the "hostservices" edge to the HostService entity.
func (m *TeamMutation) RemovedHostservicesIDs() (ids []string) {
	for id := range m.removedhostservices {
		ids = append(ids, id)
	}
	return
}

// HostservicesIDs returns the "hostservices" edge IDs in the mutation.
func (m *TeamMutation) HostservicesIDs() (ids []string) {
	for id := range m.hostservices {
		ids = append(ids, id)
	}
	return
}

// ResetHostservices resets all changes to the "hostservices" edge.
func (m *TeamMutation) ResetHostservices() {
	m.hostservices = nil
	m.clearedhostservices = false
	m.removedhostservices = nil
}

// AddCheckIDs adds the "checks" edge to the Check entity by ids.
func (m *TeamMutation) AddCheckIDs(ids ...string) {
	if m.checks == nil {
		m.checks = make(map[string]struct{})
	}
	for i := range ids {
		m.checks[ids[i]] = struct{}{}
	}
}

// ClearChecks clears the "checks" edge to the Check entity.
func (m *TeamMutation) ClearChecks() {
	m.clearedchecks = true
}

// ChecksCleared reports if the "checks" edge to the Check entity was cleared.
func (m *TeamMutation) ChecksCleared() bool {
	return m.clearedchecks
}

// RemoveCheckIDs removes the "checks" edge to the Check entity by IDs.
func (m *TeamMutation) RemoveCheckIDs(ids ...string) {
	if m.removedchecks == nil {
		m.removedchecks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.checks, ids[i])
		m.removedchecks[ids[i]] = struct{}{}
	}
}

// RemovedChecks returns the removed IDs of the "checks" edge to the Check entity.
func (m *TeamMutation) RemovedChecksIDs() (ids []string) {
	for id := range m.removedchecks {
		ids = append(ids, id)
	}
	return
}

// ChecksIDs returns the "checks" edge IDs in the mutation.
func (m *TeamMutation) ChecksIDs() (ids []string) {
	for id := range m.checks {
		ids = append(ids, id)
	}
	return
}

// ResetChecks resets all changes to the "checks" edge.
func (m *TeamMutation) ResetChecks() {
	m.checks = nil
	m.clearedchecks = false
	m.removedchecks = nil
}

// AddPropertyIDs adds the "properties" edge to the Property entity by ids.
func (m *TeamMutation) AddPropertyIDs(ids ...string) {
	if m.properties == nil {
		m.properties = make(map[string]struct{})
	}
	for i := range ids {
		m.properties[ids[i]] = struct{}{}
	}
}

// ClearProperties clears the "properties" edge to the Property entity.
func (m *TeamMutation) ClearProperties() {
	m.clearedproperties = true
}

// PropertiesCleared reports if the "properties" edge to the Property entity was cleared.
func (m *TeamMutation) PropertiesCleared() bool {
	return m.clearedproperties
}

// RemovePropertyIDs removes the "properties" edge to the Property entity by IDs.
func (m *TeamMutation) RemovePropertyIDs(ids ...string) {
	if m.removedproperties == nil {
		m.removedproperties = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.properties, ids[i])
		m.removedproperties[ids[i]] = struct{}{}
	}
}

// RemovedProperties returns the removed IDs of the "properties" edge to the Property entity.
func (m *TeamMutation) RemovedPropertiesIDs() (ids []string) {
	for id := range m.removedproperties {
		ids = append(ids, id)
	}
	return
}

// PropertiesIDs returns the "properties" edge IDs in the mutation.
func (m *TeamMutation) PropertiesIDs() (ids []string) {
	for id := range m.properties {
		ids = append(ids, id)
	}
	return
}

// ResetProperties resets all changes to the "properties" edge.
func (m *TeamMutation) ResetProperties() {
	m.properties = nil
	m.clearedproperties = false
	m.removedproperties = nil
}

// ClearCompetition clears the "competition" edge to the Competition entity.
func (m *TeamMutation) ClearCompetition() {
	m.clearedcompetition = true
}

// CompetitionCleared reports if the "competition" edge to the Competition entity was cleared.
func (m *TeamMutation) CompetitionCleared() bool {
	return m.clearedcompetition
}

// CompetitionIDs returns the "competition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompetitionID instead. It exists only for internal usage by the builders.
func (m *TeamMutation) CompetitionIDs() (ids []string) {
	if id := m.competition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompetition resets all changes to the "competition" edge.
func (m *TeamMutation) ResetCompetition() {
	m.competition = nil
	m.clearedcompetition = false
}

// Where appends a list predicates to the TeamMutation builder.
func (m *TeamMutation) Where(ps ...predicate.Team) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Team, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Team).
func (m *TeamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, team.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, team.FieldDisplayName)
	}
	if m.pause != nil {
		fields = append(fields, team.FieldPause)
	}
	if m.hidden != nil {
		fields = append(fields, team.FieldHidden)
	}
	if m.number != nil {
		fields = append(fields, team.FieldNumber)
	}
	if m.competition != nil {
		fields = append(fields, team.FieldCompetitionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case team.FieldName:
		return m.Name()
	case team.FieldDisplayName:
		return m.DisplayName()
	case team.FieldPause:
		return m.Pause()
	case team.FieldHidden:
		return m.Hidden()
	case team.FieldNumber:
		return m.Number()
	case team.FieldCompetitionID:
		return m.CompetitionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case team.FieldName:
		return m.OldName(ctx)
	case team.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case team.FieldPause:
		return m.OldPause(ctx)
	case team.FieldHidden:
		return m.OldHidden(ctx)
	case team.FieldNumber:
		return m.OldNumber(ctx)
	case team.FieldCompetitionID:
		return m.OldCompetitionID(ctx)
	}
	return nil, fmt.Errorf("unknown Team field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case team.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case team.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case team.FieldPause:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPause(v)
		return nil
	case team.FieldHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHidden(v)
		return nil
	case team.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case team.FieldCompetitionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompetitionID(v)
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamMutation) AddedFields() []string {
	var fields []string
	if m.addnumber != nil {
		fields = append(fields, team.FieldNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case team.FieldNumber:
		return m.AddedNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) AddField(name string, value ent.Value) error {
	switch name {
	case team.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Team numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(team.FieldPause) {
		fields = append(fields, team.FieldPause)
	}
	if m.FieldCleared(team.FieldHidden) {
		fields = append(fields, team.FieldHidden)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamMutation) ClearField(name string) error {
	switch name {
	case team.FieldPause:
		m.ClearPause()
		return nil
	case team.FieldHidden:
		m.ClearHidden()
		return nil
	}
	return fmt.Errorf("unknown Team nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamMutation) ResetField(name string) error {
	switch name {
	case team.FieldName:
		m.ResetName()
		return nil
	case team.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case team.FieldPause:
		m.ResetPause()
		return nil
	case team.FieldHidden:
		m.ResetHidden()
		return nil
	case team.FieldNumber:
		m.ResetNumber()
		return nil
	case team.FieldCompetitionID:
		m.ResetCompetitionID()
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.hosts != nil {
		edges = append(edges, team.EdgeHosts)
	}
	if m.hostservices != nil {
		edges = append(edges, team.EdgeHostservices)
	}
	if m.checks != nil {
		edges = append(edges, team.EdgeChecks)
	}
	if m.properties != nil {
		edges = append(edges, team.EdgeProperties)
	}
	if m.competition != nil {
		edges = append(edges, team.EdgeCompetition)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeHosts:
		ids := make([]ent.Value, 0, len(m.hosts))
		for id := range m.hosts {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeHostservices:
		ids := make([]ent.Value, 0, len(m.hostservices))
		for id := range m.hostservices {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeChecks:
		ids := make([]ent.Value, 0, len(m.checks))
		for id := range m.checks {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.properties))
		for id := range m.properties {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeCompetition:
		if id := m.competition; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedhosts != nil {
		edges = append(edges, team.EdgeHosts)
	}
	if m.removedhostservices != nil {
		edges = append(edges, team.EdgeHostservices)
	}
	if m.removedchecks != nil {
		edges = append(edges, team.EdgeChecks)
	}
	if m.removedproperties != nil {
		edges = append(edges, team.EdgeProperties)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeHosts:
		ids := make([]ent.Value, 0, len(m.removedhosts))
		for id := range m.removedhosts {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeHostservices:
		ids := make([]ent.Value, 0, len(m.removedhostservices))
		for id := range m.removedhostservices {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeChecks:
		ids := make([]ent.Value, 0, len(m.removedchecks))
		for id := range m.removedchecks {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.removedproperties))
		for id := range m.removedproperties {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedhosts {
		edges = append(edges, team.EdgeHosts)
	}
	if m.clearedhostservices {
		edges = append(edges, team.EdgeHostservices)
	}
	if m.clearedchecks {
		edges = append(edges, team.EdgeChecks)
	}
	if m.clearedproperties {
		edges = append(edges, team.EdgeProperties)
	}
	if m.clearedcompetition {
		edges = append(edges, team.EdgeCompetition)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamMutation) EdgeCleared(name string) bool {
	switch name {
	case team.EdgeHosts:
		return m.clearedhosts
	case team.EdgeHostservices:
		return m.clearedhostservices
	case team.EdgeChecks:
		return m.clearedchecks
	case team.EdgeProperties:
		return m.clearedproperties
	case team.EdgeCompetition:
		return m.clearedcompetition
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamMutation) ClearEdge(name string) error {
	switch name {
	case team.EdgeCompetition:
		m.ClearCompetition()
		return nil
	}
	return fmt.Errorf("unknown Team unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamMutation) ResetEdge(name string) error {
	switch name {
	case team.EdgeHosts:
		m.ResetHosts()
		return nil
	case team.EdgeHostservices:
		m.ResetHostservices()
		return nil
	case team.EdgeChecks:
		m.ResetChecks()
		return nil
	case team.EdgeProperties:
		m.ResetProperties()
		return nil
	case team.EdgeCompetition:
		m.ResetCompetition()
		return nil
	}
	return fmt.Errorf("unknown Team edge %s", name)
}
