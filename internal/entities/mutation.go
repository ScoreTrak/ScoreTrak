// Code generated by ent, DO NOT EDIT.

package entities

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/scoretrak/scoretrak/internal/entities/apitoken"
	"github.com/scoretrak/scoretrak/internal/entities/check"
	"github.com/scoretrak/scoretrak/internal/entities/competition"
	"github.com/scoretrak/scoretrak/internal/entities/host"
	"github.com/scoretrak/scoretrak/internal/entities/hostservice"
	"github.com/scoretrak/scoretrak/internal/entities/hostservicereport"
	"github.com/scoretrak/scoretrak/internal/entities/predicate"
	"github.com/scoretrak/scoretrak/internal/entities/property"
	"github.com/scoretrak/scoretrak/internal/entities/round"
	"github.com/scoretrak/scoretrak/internal/entities/service"
	"github.com/scoretrak/scoretrak/internal/entities/team"
	"github.com/scoretrak/scoretrak/internal/entities/teamreport"
	"github.com/scoretrak/scoretrak/pkg/scorer"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApiToken          = "ApiToken"
	TypeCheck             = "Check"
	TypeCompetition       = "Competition"
	TypeHost              = "Host"
	TypeHostService       = "HostService"
	TypeHostServiceReport = "HostServiceReport"
	TypeProperty          = "Property"
	TypeRound             = "Round"
	TypeService           = "Service"
	TypeTeam              = "Team"
	TypeTeamReport        = "TeamReport"
)

// ApiTokenMutation represents an operation that mutates the ApiToken nodes in the graph.
type ApiTokenMutation struct {
	config
	op            Op
	typ           string
	id            *string
	create_time   *time.Time
	update_time   *time.Time
	token         *string
	expired_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ApiToken, error)
	predicates    []predicate.ApiToken
}

var _ ent.Mutation = (*ApiTokenMutation)(nil)

// apitokenOption allows management of the mutation configuration using functional options.
type apitokenOption func(*ApiTokenMutation)

// newApiTokenMutation creates new mutation for the ApiToken entity.
func newApiTokenMutation(c config, op Op, opts ...apitokenOption) *ApiTokenMutation {
	m := &ApiTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeApiToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApiTokenID sets the ID field of the mutation.
func withApiTokenID(id string) apitokenOption {
	return func(m *ApiTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *ApiToken
		)
		m.oldValue = func(ctx context.Context) (*ApiToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApiToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApiToken sets the old ApiToken of the mutation.
func withApiToken(node *ApiToken) apitokenOption {
	return func(m *ApiTokenMutation) {
		m.oldValue = func(context.Context) (*ApiToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApiTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApiTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entities: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ApiToken entities.
func (m *ApiTokenMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApiTokenMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApiTokenMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApiToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ApiTokenMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ApiTokenMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *ApiTokenMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[apitoken.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *ApiTokenMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[apitoken.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ApiTokenMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, apitoken.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *ApiTokenMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ApiTokenMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *ApiTokenMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[apitoken.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *ApiTokenMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[apitoken.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ApiTokenMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, apitoken.FieldUpdateTime)
}

// SetToken sets the "token" field.
func (m *ApiTokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *ApiTokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *ApiTokenMutation) ResetToken() {
	m.token = nil
}

// SetExpiredAt sets the "expired_at" field.
func (m *ApiTokenMutation) SetExpiredAt(t time.Time) {
	m.expired_at = &t
}

// ExpiredAt returns the value of the "expired_at" field in the mutation.
func (m *ApiTokenMutation) ExpiredAt() (r time.Time, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old "expired_at" field's value of the ApiToken entity.
// If the ApiToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTokenMutation) OldExpiredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ResetExpiredAt resets all changes to the "expired_at" field.
func (m *ApiTokenMutation) ResetExpiredAt() {
	m.expired_at = nil
}

// Where appends a list predicates to the ApiTokenMutation builder.
func (m *ApiTokenMutation) Where(ps ...predicate.ApiToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApiTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApiTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApiToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApiTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApiTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApiToken).
func (m *ApiTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApiTokenMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, apitoken.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, apitoken.FieldUpdateTime)
	}
	if m.token != nil {
		fields = append(fields, apitoken.FieldToken)
	}
	if m.expired_at != nil {
		fields = append(fields, apitoken.FieldExpiredAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApiTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apitoken.FieldCreateTime:
		return m.CreateTime()
	case apitoken.FieldUpdateTime:
		return m.UpdateTime()
	case apitoken.FieldToken:
		return m.Token()
	case apitoken.FieldExpiredAt:
		return m.ExpiredAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApiTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apitoken.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case apitoken.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case apitoken.FieldToken:
		return m.OldToken(ctx)
	case apitoken.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	}
	return nil, fmt.Errorf("unknown ApiToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apitoken.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case apitoken.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case apitoken.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case apitoken.FieldExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	}
	return fmt.Errorf("unknown ApiToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApiTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApiTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ApiToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApiTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apitoken.FieldCreateTime) {
		fields = append(fields, apitoken.FieldCreateTime)
	}
	if m.FieldCleared(apitoken.FieldUpdateTime) {
		fields = append(fields, apitoken.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApiTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApiTokenMutation) ClearField(name string) error {
	switch name {
	case apitoken.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case apitoken.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown ApiToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApiTokenMutation) ResetField(name string) error {
	switch name {
	case apitoken.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case apitoken.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case apitoken.FieldToken:
		m.ResetToken()
		return nil
	case apitoken.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	}
	return fmt.Errorf("unknown ApiToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApiTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApiTokenMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApiTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApiTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApiTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApiTokenMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApiTokenMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ApiToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApiTokenMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ApiToken edge %s", name)
}

// CheckMutation represents an operation that mutates the Check nodes in the graph.
type CheckMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	create_time        *time.Time
	update_time        *time.Time
	log                *string
	error              *string
	outcome_status     *check.OutcomeStatus
	progress_status    *check.ProgressStatus
	clearedFields      map[string]struct{}
	round              *string
	clearedround       bool
	hostservice        *string
	clearedhostservice bool
	done               bool
	oldValue           func(context.Context) (*Check, error)
	predicates         []predicate.Check
}

var _ ent.Mutation = (*CheckMutation)(nil)

// checkOption allows management of the mutation configuration using functional options.
type checkOption func(*CheckMutation)

// newCheckMutation creates new mutation for the Check entity.
func newCheckMutation(c config, op Op, opts ...checkOption) *CheckMutation {
	m := &CheckMutation{
		config:        c,
		op:            op,
		typ:           TypeCheck,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCheckID sets the ID field of the mutation.
func withCheckID(id string) checkOption {
	return func(m *CheckMutation) {
		var (
			err   error
			once  sync.Once
			value *Check
		)
		m.oldValue = func(ctx context.Context) (*Check, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Check.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCheck sets the old Check of the mutation.
func withCheck(node *Check) checkOption {
	return func(m *CheckMutation) {
		m.oldValue = func(context.Context) (*Check, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CheckMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CheckMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entities: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Check entities.
func (m *CheckMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CheckMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CheckMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Check.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CheckMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CheckMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *CheckMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[check.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *CheckMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[check.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CheckMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, check.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *CheckMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CheckMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *CheckMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[check.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *CheckMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[check.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CheckMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, check.FieldUpdateTime)
}

// SetLog sets the "log" field.
func (m *CheckMutation) SetLog(s string) {
	m.log = &s
}

// Log returns the value of the "log" field in the mutation.
func (m *CheckMutation) Log() (r string, exists bool) {
	v := m.log
	if v == nil {
		return
	}
	return *v, true
}

// OldLog returns the old "log" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldLog(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLog is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLog requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLog: %w", err)
	}
	return oldValue.Log, nil
}

// ClearLog clears the value of the "log" field.
func (m *CheckMutation) ClearLog() {
	m.log = nil
	m.clearedFields[check.FieldLog] = struct{}{}
}

// LogCleared returns if the "log" field was cleared in this mutation.
func (m *CheckMutation) LogCleared() bool {
	_, ok := m.clearedFields[check.FieldLog]
	return ok
}

// ResetLog resets all changes to the "log" field.
func (m *CheckMutation) ResetLog() {
	m.log = nil
	delete(m.clearedFields, check.FieldLog)
}

// SetError sets the "error" field.
func (m *CheckMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *CheckMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *CheckMutation) ClearError() {
	m.error = nil
	m.clearedFields[check.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *CheckMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[check.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *CheckMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, check.FieldError)
}

// SetOutcomeStatus sets the "outcome_status" field.
func (m *CheckMutation) SetOutcomeStatus(cs check.OutcomeStatus) {
	m.outcome_status = &cs
}

// OutcomeStatus returns the value of the "outcome_status" field in the mutation.
func (m *CheckMutation) OutcomeStatus() (r check.OutcomeStatus, exists bool) {
	v := m.outcome_status
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeStatus returns the old "outcome_status" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldOutcomeStatus(ctx context.Context) (v check.OutcomeStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeStatus: %w", err)
	}
	return oldValue.OutcomeStatus, nil
}

// ClearOutcomeStatus clears the value of the "outcome_status" field.
func (m *CheckMutation) ClearOutcomeStatus() {
	m.outcome_status = nil
	m.clearedFields[check.FieldOutcomeStatus] = struct{}{}
}

// OutcomeStatusCleared returns if the "outcome_status" field was cleared in this mutation.
func (m *CheckMutation) OutcomeStatusCleared() bool {
	_, ok := m.clearedFields[check.FieldOutcomeStatus]
	return ok
}

// ResetOutcomeStatus resets all changes to the "outcome_status" field.
func (m *CheckMutation) ResetOutcomeStatus() {
	m.outcome_status = nil
	delete(m.clearedFields, check.FieldOutcomeStatus)
}

// SetProgressStatus sets the "progress_status" field.
func (m *CheckMutation) SetProgressStatus(cs check.ProgressStatus) {
	m.progress_status = &cs
}

// ProgressStatus returns the value of the "progress_status" field in the mutation.
func (m *CheckMutation) ProgressStatus() (r check.ProgressStatus, exists bool) {
	v := m.progress_status
	if v == nil {
		return
	}
	return *v, true
}

// OldProgressStatus returns the old "progress_status" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldProgressStatus(ctx context.Context) (v check.ProgressStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgressStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgressStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgressStatus: %w", err)
	}
	return oldValue.ProgressStatus, nil
}

// ResetProgressStatus resets all changes to the "progress_status" field.
func (m *CheckMutation) ResetProgressStatus() {
	m.progress_status = nil
}

// SetRoundID sets the "round_id" field.
func (m *CheckMutation) SetRoundID(s string) {
	m.round = &s
}

// RoundID returns the value of the "round_id" field in the mutation.
func (m *CheckMutation) RoundID() (r string, exists bool) {
	v := m.round
	if v == nil {
		return
	}
	return *v, true
}

// OldRoundID returns the old "round_id" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldRoundID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoundID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoundID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoundID: %w", err)
	}
	return oldValue.RoundID, nil
}

// ResetRoundID resets all changes to the "round_id" field.
func (m *CheckMutation) ResetRoundID() {
	m.round = nil
}

// SetHostServiceID sets the "host_service_id" field.
func (m *CheckMutation) SetHostServiceID(s string) {
	m.hostservice = &s
}

// HostServiceID returns the value of the "host_service_id" field in the mutation.
func (m *CheckMutation) HostServiceID() (r string, exists bool) {
	v := m.hostservice
	if v == nil {
		return
	}
	return *v, true
}

// OldHostServiceID returns the old "host_service_id" field's value of the Check entity.
// If the Check object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckMutation) OldHostServiceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostServiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostServiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostServiceID: %w", err)
	}
	return oldValue.HostServiceID, nil
}

// ResetHostServiceID resets all changes to the "host_service_id" field.
func (m *CheckMutation) ResetHostServiceID() {
	m.hostservice = nil
}

// ClearRound clears the "round" edge to the Round entity.
func (m *CheckMutation) ClearRound() {
	m.clearedround = true
}

// RoundCleared reports if the "round" edge to the Round entity was cleared.
func (m *CheckMutation) RoundCleared() bool {
	return m.clearedround
}

// RoundIDs returns the "round" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoundID instead. It exists only for internal usage by the builders.
func (m *CheckMutation) RoundIDs() (ids []string) {
	if id := m.round; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRound resets all changes to the "round" edge.
func (m *CheckMutation) ResetRound() {
	m.round = nil
	m.clearedround = false
}

// SetHostserviceID sets the "hostservice" edge to the HostService entity by id.
func (m *CheckMutation) SetHostserviceID(id string) {
	m.hostservice = &id
}

// ClearHostservice clears the "hostservice" edge to the HostService entity.
func (m *CheckMutation) ClearHostservice() {
	m.clearedhostservice = true
}

// HostserviceCleared reports if the "hostservice" edge to the HostService entity was cleared.
func (m *CheckMutation) HostserviceCleared() bool {
	return m.clearedhostservice
}

// HostserviceID returns the "hostservice" edge ID in the mutation.
func (m *CheckMutation) HostserviceID() (id string, exists bool) {
	if m.hostservice != nil {
		return *m.hostservice, true
	}
	return
}

// HostserviceIDs returns the "hostservice" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostserviceID instead. It exists only for internal usage by the builders.
func (m *CheckMutation) HostserviceIDs() (ids []string) {
	if id := m.hostservice; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHostservice resets all changes to the "hostservice" edge.
func (m *CheckMutation) ResetHostservice() {
	m.hostservice = nil
	m.clearedhostservice = false
}

// Where appends a list predicates to the CheckMutation builder.
func (m *CheckMutation) Where(ps ...predicate.Check) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CheckMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CheckMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Check, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CheckMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CheckMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Check).
func (m *CheckMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CheckMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, check.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, check.FieldUpdateTime)
	}
	if m.log != nil {
		fields = append(fields, check.FieldLog)
	}
	if m.error != nil {
		fields = append(fields, check.FieldError)
	}
	if m.outcome_status != nil {
		fields = append(fields, check.FieldOutcomeStatus)
	}
	if m.progress_status != nil {
		fields = append(fields, check.FieldProgressStatus)
	}
	if m.round != nil {
		fields = append(fields, check.FieldRoundID)
	}
	if m.hostservice != nil {
		fields = append(fields, check.FieldHostServiceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CheckMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case check.FieldCreateTime:
		return m.CreateTime()
	case check.FieldUpdateTime:
		return m.UpdateTime()
	case check.FieldLog:
		return m.Log()
	case check.FieldError:
		return m.Error()
	case check.FieldOutcomeStatus:
		return m.OutcomeStatus()
	case check.FieldProgressStatus:
		return m.ProgressStatus()
	case check.FieldRoundID:
		return m.RoundID()
	case check.FieldHostServiceID:
		return m.HostServiceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CheckMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case check.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case check.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case check.FieldLog:
		return m.OldLog(ctx)
	case check.FieldError:
		return m.OldError(ctx)
	case check.FieldOutcomeStatus:
		return m.OldOutcomeStatus(ctx)
	case check.FieldProgressStatus:
		return m.OldProgressStatus(ctx)
	case check.FieldRoundID:
		return m.OldRoundID(ctx)
	case check.FieldHostServiceID:
		return m.OldHostServiceID(ctx)
	}
	return nil, fmt.Errorf("unknown Check field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CheckMutation) SetField(name string, value ent.Value) error {
	switch name {
	case check.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case check.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case check.FieldLog:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLog(v)
		return nil
	case check.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case check.FieldOutcomeStatus:
		v, ok := value.(check.OutcomeStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeStatus(v)
		return nil
	case check.FieldProgressStatus:
		v, ok := value.(check.ProgressStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgressStatus(v)
		return nil
	case check.FieldRoundID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoundID(v)
		return nil
	case check.FieldHostServiceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostServiceID(v)
		return nil
	}
	return fmt.Errorf("unknown Check field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CheckMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CheckMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CheckMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Check numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CheckMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(check.FieldCreateTime) {
		fields = append(fields, check.FieldCreateTime)
	}
	if m.FieldCleared(check.FieldUpdateTime) {
		fields = append(fields, check.FieldUpdateTime)
	}
	if m.FieldCleared(check.FieldLog) {
		fields = append(fields, check.FieldLog)
	}
	if m.FieldCleared(check.FieldError) {
		fields = append(fields, check.FieldError)
	}
	if m.FieldCleared(check.FieldOutcomeStatus) {
		fields = append(fields, check.FieldOutcomeStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CheckMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CheckMutation) ClearField(name string) error {
	switch name {
	case check.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case check.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case check.FieldLog:
		m.ClearLog()
		return nil
	case check.FieldError:
		m.ClearError()
		return nil
	case check.FieldOutcomeStatus:
		m.ClearOutcomeStatus()
		return nil
	}
	return fmt.Errorf("unknown Check nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CheckMutation) ResetField(name string) error {
	switch name {
	case check.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case check.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case check.FieldLog:
		m.ResetLog()
		return nil
	case check.FieldError:
		m.ResetError()
		return nil
	case check.FieldOutcomeStatus:
		m.ResetOutcomeStatus()
		return nil
	case check.FieldProgressStatus:
		m.ResetProgressStatus()
		return nil
	case check.FieldRoundID:
		m.ResetRoundID()
		return nil
	case check.FieldHostServiceID:
		m.ResetHostServiceID()
		return nil
	}
	return fmt.Errorf("unknown Check field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CheckMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.round != nil {
		edges = append(edges, check.EdgeRound)
	}
	if m.hostservice != nil {
		edges = append(edges, check.EdgeHostservice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CheckMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case check.EdgeRound:
		if id := m.round; id != nil {
			return []ent.Value{*id}
		}
	case check.EdgeHostservice:
		if id := m.hostservice; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CheckMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CheckMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CheckMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedround {
		edges = append(edges, check.EdgeRound)
	}
	if m.clearedhostservice {
		edges = append(edges, check.EdgeHostservice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CheckMutation) EdgeCleared(name string) bool {
	switch name {
	case check.EdgeRound:
		return m.clearedround
	case check.EdgeHostservice:
		return m.clearedhostservice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CheckMutation) ClearEdge(name string) error {
	switch name {
	case check.EdgeRound:
		m.ClearRound()
		return nil
	case check.EdgeHostservice:
		m.ClearHostservice()
		return nil
	}
	return fmt.Errorf("unknown Check unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CheckMutation) ResetEdge(name string) error {
	switch name {
	case check.EdgeRound:
		m.ResetRound()
		return nil
	case check.EdgeHostservice:
		m.ResetHostservice()
		return nil
	}
	return fmt.Errorf("unknown Check edge %s", name)
}

// CompetitionMutation represents an operation that mutates the Competition nodes in the graph.
type CompetitionMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	pause              *bool
	create_time        *time.Time
	update_time        *time.Time
	name               *string
	display_name       *string
	viewable_to_public *bool
	started_at         *time.Time
	finished_at        *time.Time
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*Competition, error)
	predicates         []predicate.Competition
}

var _ ent.Mutation = (*CompetitionMutation)(nil)

// competitionOption allows management of the mutation configuration using functional options.
type competitionOption func(*CompetitionMutation)

// newCompetitionMutation creates new mutation for the Competition entity.
func newCompetitionMutation(c config, op Op, opts ...competitionOption) *CompetitionMutation {
	m := &CompetitionMutation{
		config:        c,
		op:            op,
		typ:           TypeCompetition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompetitionID sets the ID field of the mutation.
func withCompetitionID(id string) competitionOption {
	return func(m *CompetitionMutation) {
		var (
			err   error
			once  sync.Once
			value *Competition
		)
		m.oldValue = func(ctx context.Context) (*Competition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Competition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompetition sets the old Competition of the mutation.
func withCompetition(node *Competition) competitionOption {
	return func(m *CompetitionMutation) {
		m.oldValue = func(context.Context) (*Competition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompetitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompetitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entities: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Competition entities.
func (m *CompetitionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompetitionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompetitionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Competition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPause sets the "pause" field.
func (m *CompetitionMutation) SetPause(b bool) {
	m.pause = &b
}

// Pause returns the value of the "pause" field in the mutation.
func (m *CompetitionMutation) Pause() (r bool, exists bool) {
	v := m.pause
	if v == nil {
		return
	}
	return *v, true
}

// OldPause returns the old "pause" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldPause(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPause is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPause requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPause: %w", err)
	}
	return oldValue.Pause, nil
}

// ClearPause clears the value of the "pause" field.
func (m *CompetitionMutation) ClearPause() {
	m.pause = nil
	m.clearedFields[competition.FieldPause] = struct{}{}
}

// PauseCleared returns if the "pause" field was cleared in this mutation.
func (m *CompetitionMutation) PauseCleared() bool {
	_, ok := m.clearedFields[competition.FieldPause]
	return ok
}

// ResetPause resets all changes to the "pause" field.
func (m *CompetitionMutation) ResetPause() {
	m.pause = nil
	delete(m.clearedFields, competition.FieldPause)
}

// SetCreateTime sets the "create_time" field.
func (m *CompetitionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CompetitionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *CompetitionMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[competition.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *CompetitionMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[competition.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CompetitionMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, competition.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *CompetitionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CompetitionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *CompetitionMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[competition.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *CompetitionMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[competition.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CompetitionMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, competition.FieldUpdateTime)
}

// SetName sets the "name" field.
func (m *CompetitionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CompetitionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CompetitionMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *CompetitionMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *CompetitionMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *CompetitionMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetViewableToPublic sets the "viewable_to_public" field.
func (m *CompetitionMutation) SetViewableToPublic(b bool) {
	m.viewable_to_public = &b
}

// ViewableToPublic returns the value of the "viewable_to_public" field in the mutation.
func (m *CompetitionMutation) ViewableToPublic() (r bool, exists bool) {
	v := m.viewable_to_public
	if v == nil {
		return
	}
	return *v, true
}

// OldViewableToPublic returns the old "viewable_to_public" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldViewableToPublic(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViewableToPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViewableToPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewableToPublic: %w", err)
	}
	return oldValue.ViewableToPublic, nil
}

// ClearViewableToPublic clears the value of the "viewable_to_public" field.
func (m *CompetitionMutation) ClearViewableToPublic() {
	m.viewable_to_public = nil
	m.clearedFields[competition.FieldViewableToPublic] = struct{}{}
}

// ViewableToPublicCleared returns if the "viewable_to_public" field was cleared in this mutation.
func (m *CompetitionMutation) ViewableToPublicCleared() bool {
	_, ok := m.clearedFields[competition.FieldViewableToPublic]
	return ok
}

// ResetViewableToPublic resets all changes to the "viewable_to_public" field.
func (m *CompetitionMutation) ResetViewableToPublic() {
	m.viewable_to_public = nil
	delete(m.clearedFields, competition.FieldViewableToPublic)
}

// SetStartedAt sets the "started_at" field.
func (m *CompetitionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *CompetitionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *CompetitionMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[competition.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *CompetitionMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[competition.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *CompetitionMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, competition.FieldStartedAt)
}

// SetFinishedAt sets the "finished_at" field.
func (m *CompetitionMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *CompetitionMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldFinishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ClearFinishedAt clears the value of the "finished_at" field.
func (m *CompetitionMutation) ClearFinishedAt() {
	m.finished_at = nil
	m.clearedFields[competition.FieldFinishedAt] = struct{}{}
}

// FinishedAtCleared returns if the "finished_at" field was cleared in this mutation.
func (m *CompetitionMutation) FinishedAtCleared() bool {
	_, ok := m.clearedFields[competition.FieldFinishedAt]
	return ok
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *CompetitionMutation) ResetFinishedAt() {
	m.finished_at = nil
	delete(m.clearedFields, competition.FieldFinishedAt)
}

// Where appends a list predicates to the CompetitionMutation builder.
func (m *CompetitionMutation) Where(ps ...predicate.Competition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompetitionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompetitionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Competition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompetitionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompetitionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Competition).
func (m *CompetitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompetitionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.pause != nil {
		fields = append(fields, competition.FieldPause)
	}
	if m.create_time != nil {
		fields = append(fields, competition.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, competition.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, competition.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, competition.FieldDisplayName)
	}
	if m.viewable_to_public != nil {
		fields = append(fields, competition.FieldViewableToPublic)
	}
	if m.started_at != nil {
		fields = append(fields, competition.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, competition.FieldFinishedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompetitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case competition.FieldPause:
		return m.Pause()
	case competition.FieldCreateTime:
		return m.CreateTime()
	case competition.FieldUpdateTime:
		return m.UpdateTime()
	case competition.FieldName:
		return m.Name()
	case competition.FieldDisplayName:
		return m.DisplayName()
	case competition.FieldViewableToPublic:
		return m.ViewableToPublic()
	case competition.FieldStartedAt:
		return m.StartedAt()
	case competition.FieldFinishedAt:
		return m.FinishedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompetitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case competition.FieldPause:
		return m.OldPause(ctx)
	case competition.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case competition.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case competition.FieldName:
		return m.OldName(ctx)
	case competition.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case competition.FieldViewableToPublic:
		return m.OldViewableToPublic(ctx)
	case competition.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case competition.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Competition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompetitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case competition.FieldPause:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPause(v)
		return nil
	case competition.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case competition.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case competition.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case competition.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case competition.FieldViewableToPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewableToPublic(v)
		return nil
	case competition.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case competition.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Competition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompetitionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompetitionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompetitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Competition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompetitionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(competition.FieldPause) {
		fields = append(fields, competition.FieldPause)
	}
	if m.FieldCleared(competition.FieldCreateTime) {
		fields = append(fields, competition.FieldCreateTime)
	}
	if m.FieldCleared(competition.FieldUpdateTime) {
		fields = append(fields, competition.FieldUpdateTime)
	}
	if m.FieldCleared(competition.FieldViewableToPublic) {
		fields = append(fields, competition.FieldViewableToPublic)
	}
	if m.FieldCleared(competition.FieldStartedAt) {
		fields = append(fields, competition.FieldStartedAt)
	}
	if m.FieldCleared(competition.FieldFinishedAt) {
		fields = append(fields, competition.FieldFinishedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompetitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompetitionMutation) ClearField(name string) error {
	switch name {
	case competition.FieldPause:
		m.ClearPause()
		return nil
	case competition.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case competition.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case competition.FieldViewableToPublic:
		m.ClearViewableToPublic()
		return nil
	case competition.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case competition.FieldFinishedAt:
		m.ClearFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown Competition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompetitionMutation) ResetField(name string) error {
	switch name {
	case competition.FieldPause:
		m.ResetPause()
		return nil
	case competition.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case competition.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case competition.FieldName:
		m.ResetName()
		return nil
	case competition.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case competition.FieldViewableToPublic:
		m.ResetViewableToPublic()
		return nil
	case competition.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case competition.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown Competition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompetitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompetitionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompetitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompetitionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompetitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompetitionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompetitionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Competition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompetitionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Competition edge %s", name)
}

// HostMutation represents an operation that mutates the Host nodes in the graph.
type HostMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	pause               *bool
	hidden              *bool
	create_time         *time.Time
	update_time         *time.Time
	address             *string
	clearedFields       map[string]struct{}
	hostservices        map[string]struct{}
	removedhostservices map[string]struct{}
	clearedhostservices bool
	team                *string
	clearedteam         bool
	done                bool
	oldValue            func(context.Context) (*Host, error)
	predicates          []predicate.Host
}

var _ ent.Mutation = (*HostMutation)(nil)

// hostOption allows management of the mutation configuration using functional options.
type hostOption func(*HostMutation)

// newHostMutation creates new mutation for the Host entity.
func newHostMutation(c config, op Op, opts ...hostOption) *HostMutation {
	m := &HostMutation{
		config:        c,
		op:            op,
		typ:           TypeHost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHostID sets the ID field of the mutation.
func withHostID(id string) hostOption {
	return func(m *HostMutation) {
		var (
			err   error
			once  sync.Once
			value *Host
		)
		m.oldValue = func(ctx context.Context) (*Host, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Host.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHost sets the old Host of the mutation.
func withHost(node *Host) hostOption {
	return func(m *HostMutation) {
		m.oldValue = func(context.Context) (*Host, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entities: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Host entities.
func (m *HostMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HostMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HostMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Host.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPause sets the "pause" field.
func (m *HostMutation) SetPause(b bool) {
	m.pause = &b
}

// Pause returns the value of the "pause" field in the mutation.
func (m *HostMutation) Pause() (r bool, exists bool) {
	v := m.pause
	if v == nil {
		return
	}
	return *v, true
}

// OldPause returns the old "pause" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldPause(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPause is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPause requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPause: %w", err)
	}
	return oldValue.Pause, nil
}

// ClearPause clears the value of the "pause" field.
func (m *HostMutation) ClearPause() {
	m.pause = nil
	m.clearedFields[host.FieldPause] = struct{}{}
}

// PauseCleared returns if the "pause" field was cleared in this mutation.
func (m *HostMutation) PauseCleared() bool {
	_, ok := m.clearedFields[host.FieldPause]
	return ok
}

// ResetPause resets all changes to the "pause" field.
func (m *HostMutation) ResetPause() {
	m.pause = nil
	delete(m.clearedFields, host.FieldPause)
}

// SetHidden sets the "hidden" field.
func (m *HostMutation) SetHidden(b bool) {
	m.hidden = &b
}

// Hidden returns the value of the "hidden" field in the mutation.
func (m *HostMutation) Hidden() (r bool, exists bool) {
	v := m.hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldHidden returns the old "hidden" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHidden: %w", err)
	}
	return oldValue.Hidden, nil
}

// ClearHidden clears the value of the "hidden" field.
func (m *HostMutation) ClearHidden() {
	m.hidden = nil
	m.clearedFields[host.FieldHidden] = struct{}{}
}

// HiddenCleared returns if the "hidden" field was cleared in this mutation.
func (m *HostMutation) HiddenCleared() bool {
	_, ok := m.clearedFields[host.FieldHidden]
	return ok
}

// ResetHidden resets all changes to the "hidden" field.
func (m *HostMutation) ResetHidden() {
	m.hidden = nil
	delete(m.clearedFields, host.FieldHidden)
}

// SetCreateTime sets the "create_time" field.
func (m *HostMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *HostMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *HostMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[host.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *HostMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[host.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *HostMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, host.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *HostMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *HostMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *HostMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[host.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *HostMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[host.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *HostMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, host.FieldUpdateTime)
}

// SetAddress sets the "address" field.
func (m *HostMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *HostMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *HostMutation) ResetAddress() {
	m.address = nil
}

// SetTeamID sets the "team_id" field.
func (m *HostMutation) SetTeamID(s string) {
	m.team = &s
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *HostMutation) TeamID() (r string, exists bool) {
	v := m.team
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldTeamID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *HostMutation) ResetTeamID() {
	m.team = nil
}

// AddHostserviceIDs adds the "hostservices" edge to the HostService entity by ids.
func (m *HostMutation) AddHostserviceIDs(ids ...string) {
	if m.hostservices == nil {
		m.hostservices = make(map[string]struct{})
	}
	for i := range ids {
		m.hostservices[ids[i]] = struct{}{}
	}
}

// ClearHostservices clears the "hostservices" edge to the HostService entity.
func (m *HostMutation) ClearHostservices() {
	m.clearedhostservices = true
}

// HostservicesCleared reports if the "hostservices" edge to the HostService entity was cleared.
func (m *HostMutation) HostservicesCleared() bool {
	return m.clearedhostservices
}

// RemoveHostserviceIDs removes the "hostservices" edge to the HostService entity by IDs.
func (m *HostMutation) RemoveHostserviceIDs(ids ...string) {
	if m.removedhostservices == nil {
		m.removedhostservices = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hostservices, ids[i])
		m.removedhostservices[ids[i]] = struct{}{}
	}
}

// RemovedHostservices returns the removed IDs of the "hostservices" edge to the HostService entity.
func (m *HostMutation) RemovedHostservicesIDs() (ids []string) {
	for id := range m.removedhostservices {
		ids = append(ids, id)
	}
	return
}

// HostservicesIDs returns the "hostservices" edge IDs in the mutation.
func (m *HostMutation) HostservicesIDs() (ids []string) {
	for id := range m.hostservices {
		ids = append(ids, id)
	}
	return
}

// ResetHostservices resets all changes to the "hostservices" edge.
func (m *HostMutation) ResetHostservices() {
	m.hostservices = nil
	m.clearedhostservices = false
	m.removedhostservices = nil
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *HostMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *HostMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *HostMutation) TeamIDs() (ids []string) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *HostMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// Where appends a list predicates to the HostMutation builder.
func (m *HostMutation) Where(ps ...predicate.Host) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Host, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Host).
func (m *HostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HostMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.pause != nil {
		fields = append(fields, host.FieldPause)
	}
	if m.hidden != nil {
		fields = append(fields, host.FieldHidden)
	}
	if m.create_time != nil {
		fields = append(fields, host.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, host.FieldUpdateTime)
	}
	if m.address != nil {
		fields = append(fields, host.FieldAddress)
	}
	if m.team != nil {
		fields = append(fields, host.FieldTeamID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case host.FieldPause:
		return m.Pause()
	case host.FieldHidden:
		return m.Hidden()
	case host.FieldCreateTime:
		return m.CreateTime()
	case host.FieldUpdateTime:
		return m.UpdateTime()
	case host.FieldAddress:
		return m.Address()
	case host.FieldTeamID:
		return m.TeamID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case host.FieldPause:
		return m.OldPause(ctx)
	case host.FieldHidden:
		return m.OldHidden(ctx)
	case host.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case host.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case host.FieldAddress:
		return m.OldAddress(ctx)
	case host.FieldTeamID:
		return m.OldTeamID(ctx)
	}
	return nil, fmt.Errorf("unknown Host field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case host.FieldPause:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPause(v)
		return nil
	case host.FieldHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHidden(v)
		return nil
	case host.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case host.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case host.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case host.FieldTeamID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	}
	return fmt.Errorf("unknown Host field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Host numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(host.FieldPause) {
		fields = append(fields, host.FieldPause)
	}
	if m.FieldCleared(host.FieldHidden) {
		fields = append(fields, host.FieldHidden)
	}
	if m.FieldCleared(host.FieldCreateTime) {
		fields = append(fields, host.FieldCreateTime)
	}
	if m.FieldCleared(host.FieldUpdateTime) {
		fields = append(fields, host.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HostMutation) ClearField(name string) error {
	switch name {
	case host.FieldPause:
		m.ClearPause()
		return nil
	case host.FieldHidden:
		m.ClearHidden()
		return nil
	case host.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case host.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Host nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HostMutation) ResetField(name string) error {
	switch name {
	case host.FieldPause:
		m.ResetPause()
		return nil
	case host.FieldHidden:
		m.ResetHidden()
		return nil
	case host.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case host.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case host.FieldAddress:
		m.ResetAddress()
		return nil
	case host.FieldTeamID:
		m.ResetTeamID()
		return nil
	}
	return fmt.Errorf("unknown Host field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HostMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.hostservices != nil {
		edges = append(edges, host.EdgeHostservices)
	}
	if m.team != nil {
		edges = append(edges, host.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case host.EdgeHostservices:
		ids := make([]ent.Value, 0, len(m.hostservices))
		for id := range m.hostservices {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedhostservices != nil {
		edges = append(edges, host.EdgeHostservices)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case host.EdgeHostservices:
		ids := make([]ent.Value, 0, len(m.removedhostservices))
		for id := range m.removedhostservices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedhostservices {
		edges = append(edges, host.EdgeHostservices)
	}
	if m.clearedteam {
		edges = append(edges, host.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HostMutation) EdgeCleared(name string) bool {
	switch name {
	case host.EdgeHostservices:
		return m.clearedhostservices
	case host.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HostMutation) ClearEdge(name string) error {
	switch name {
	case host.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown Host unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HostMutation) ResetEdge(name string) error {
	switch name {
	case host.EdgeHostservices:
		m.ResetHostservices()
		return nil
	case host.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown Host edge %s", name)
}

// HostServiceMutation represents an operation that mutates the HostService nodes in the graph.
type HostServiceMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	name                     *string
	display_name             *string
	pause                    *bool
	hidden                   *bool
	create_time              *time.Time
	update_time              *time.Time
	clearedFields            map[string]struct{}
	checks                   map[string]struct{}
	removedchecks            map[string]struct{}
	clearedchecks            bool
	properties               map[string]struct{}
	removedproperties        map[string]struct{}
	clearedproperties        bool
	hostservicereport        *string
	clearedhostservicereport bool
	service                  *string
	clearedservice           bool
	host                     *string
	clearedhost              bool
	team                     *string
	clearedteam              bool
	done                     bool
	oldValue                 func(context.Context) (*HostService, error)
	predicates               []predicate.HostService
}

var _ ent.Mutation = (*HostServiceMutation)(nil)

// hostserviceOption allows management of the mutation configuration using functional options.
type hostserviceOption func(*HostServiceMutation)

// newHostServiceMutation creates new mutation for the HostService entity.
func newHostServiceMutation(c config, op Op, opts ...hostserviceOption) *HostServiceMutation {
	m := &HostServiceMutation{
		config:        c,
		op:            op,
		typ:           TypeHostService,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHostServiceID sets the ID field of the mutation.
func withHostServiceID(id string) hostserviceOption {
	return func(m *HostServiceMutation) {
		var (
			err   error
			once  sync.Once
			value *HostService
		)
		m.oldValue = func(ctx context.Context) (*HostService, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HostService.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHostService sets the old HostService of the mutation.
func withHostService(node *HostService) hostserviceOption {
	return func(m *HostServiceMutation) {
		m.oldValue = func(context.Context) (*HostService, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HostServiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HostServiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entities: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HostService entities.
func (m *HostServiceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HostServiceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HostServiceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HostService.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *HostServiceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HostServiceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the HostService entity.
// If the HostService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostServiceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *HostServiceMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *HostServiceMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *HostServiceMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the HostService entity.
// If the HostService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostServiceMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *HostServiceMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetPause sets the "pause" field.
func (m *HostServiceMutation) SetPause(b bool) {
	m.pause = &b
}

// Pause returns the value of the "pause" field in the mutation.
func (m *HostServiceMutation) Pause() (r bool, exists bool) {
	v := m.pause
	if v == nil {
		return
	}
	return *v, true
}

// OldPause returns the old "pause" field's value of the HostService entity.
// If the HostService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostServiceMutation) OldPause(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPause is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPause requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPause: %w", err)
	}
	return oldValue.Pause, nil
}

// ClearPause clears the value of the "pause" field.
func (m *HostServiceMutation) ClearPause() {
	m.pause = nil
	m.clearedFields[hostservice.FieldPause] = struct{}{}
}

// PauseCleared returns if the "pause" field was cleared in this mutation.
func (m *HostServiceMutation) PauseCleared() bool {
	_, ok := m.clearedFields[hostservice.FieldPause]
	return ok
}

// ResetPause resets all changes to the "pause" field.
func (m *HostServiceMutation) ResetPause() {
	m.pause = nil
	delete(m.clearedFields, hostservice.FieldPause)
}

// SetHidden sets the "hidden" field.
func (m *HostServiceMutation) SetHidden(b bool) {
	m.hidden = &b
}

// Hidden returns the value of the "hidden" field in the mutation.
func (m *HostServiceMutation) Hidden() (r bool, exists bool) {
	v := m.hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldHidden returns the old "hidden" field's value of the HostService entity.
// If the HostService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostServiceMutation) OldHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHidden: %w", err)
	}
	return oldValue.Hidden, nil
}

// ClearHidden clears the value of the "hidden" field.
func (m *HostServiceMutation) ClearHidden() {
	m.hidden = nil
	m.clearedFields[hostservice.FieldHidden] = struct{}{}
}

// HiddenCleared returns if the "hidden" field was cleared in this mutation.
func (m *HostServiceMutation) HiddenCleared() bool {
	_, ok := m.clearedFields[hostservice.FieldHidden]
	return ok
}

// ResetHidden resets all changes to the "hidden" field.
func (m *HostServiceMutation) ResetHidden() {
	m.hidden = nil
	delete(m.clearedFields, hostservice.FieldHidden)
}

// SetCreateTime sets the "create_time" field.
func (m *HostServiceMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *HostServiceMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the HostService entity.
// If the HostService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostServiceMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *HostServiceMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[hostservice.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *HostServiceMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[hostservice.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *HostServiceMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, hostservice.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *HostServiceMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *HostServiceMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the HostService entity.
// If the HostService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostServiceMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *HostServiceMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[hostservice.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *HostServiceMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[hostservice.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *HostServiceMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, hostservice.FieldUpdateTime)
}

// SetServiceID sets the "service_id" field.
func (m *HostServiceMutation) SetServiceID(s string) {
	m.service = &s
}

// ServiceID returns the value of the "service_id" field in the mutation.
func (m *HostServiceMutation) ServiceID() (r string, exists bool) {
	v := m.service
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceID returns the old "service_id" field's value of the HostService entity.
// If the HostService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostServiceMutation) OldServiceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceID: %w", err)
	}
	return oldValue.ServiceID, nil
}

// ResetServiceID resets all changes to the "service_id" field.
func (m *HostServiceMutation) ResetServiceID() {
	m.service = nil
}

// SetHostID sets the "host_id" field.
func (m *HostServiceMutation) SetHostID(s string) {
	m.host = &s
}

// HostID returns the value of the "host_id" field in the mutation.
func (m *HostServiceMutation) HostID() (r string, exists bool) {
	v := m.host
	if v == nil {
		return
	}
	return *v, true
}

// OldHostID returns the old "host_id" field's value of the HostService entity.
// If the HostService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostServiceMutation) OldHostID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostID: %w", err)
	}
	return oldValue.HostID, nil
}

// ResetHostID resets all changes to the "host_id" field.
func (m *HostServiceMutation) ResetHostID() {
	m.host = nil
}

// SetTeamID sets the "team_id" field.
func (m *HostServiceMutation) SetTeamID(s string) {
	m.team = &s
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *HostServiceMutation) TeamID() (r string, exists bool) {
	v := m.team
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the HostService entity.
// If the HostService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostServiceMutation) OldTeamID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *HostServiceMutation) ResetTeamID() {
	m.team = nil
}

// AddCheckIDs adds the "checks" edge to the Check entity by ids.
func (m *HostServiceMutation) AddCheckIDs(ids ...string) {
	if m.checks == nil {
		m.checks = make(map[string]struct{})
	}
	for i := range ids {
		m.checks[ids[i]] = struct{}{}
	}
}

// ClearChecks clears the "checks" edge to the Check entity.
func (m *HostServiceMutation) ClearChecks() {
	m.clearedchecks = true
}

// ChecksCleared reports if the "checks" edge to the Check entity was cleared.
func (m *HostServiceMutation) ChecksCleared() bool {
	return m.clearedchecks
}

// RemoveCheckIDs removes the "checks" edge to the Check entity by IDs.
func (m *HostServiceMutation) RemoveCheckIDs(ids ...string) {
	if m.removedchecks == nil {
		m.removedchecks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.checks, ids[i])
		m.removedchecks[ids[i]] = struct{}{}
	}
}

// RemovedChecks returns the removed IDs of the "checks" edge to the Check entity.
func (m *HostServiceMutation) RemovedChecksIDs() (ids []string) {
	for id := range m.removedchecks {
		ids = append(ids, id)
	}
	return
}

// ChecksIDs returns the "checks" edge IDs in the mutation.
func (m *HostServiceMutation) ChecksIDs() (ids []string) {
	for id := range m.checks {
		ids = append(ids, id)
	}
	return
}

// ResetChecks resets all changes to the "checks" edge.
func (m *HostServiceMutation) ResetChecks() {
	m.checks = nil
	m.clearedchecks = false
	m.removedchecks = nil
}

// AddPropertyIDs adds the "properties" edge to the Property entity by ids.
func (m *HostServiceMutation) AddPropertyIDs(ids ...string) {
	if m.properties == nil {
		m.properties = make(map[string]struct{})
	}
	for i := range ids {
		m.properties[ids[i]] = struct{}{}
	}
}

// ClearProperties clears the "properties" edge to the Property entity.
func (m *HostServiceMutation) ClearProperties() {
	m.clearedproperties = true
}

// PropertiesCleared reports if the "properties" edge to the Property entity was cleared.
func (m *HostServiceMutation) PropertiesCleared() bool {
	return m.clearedproperties
}

// RemovePropertyIDs removes the "properties" edge to the Property entity by IDs.
func (m *HostServiceMutation) RemovePropertyIDs(ids ...string) {
	if m.removedproperties == nil {
		m.removedproperties = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.properties, ids[i])
		m.removedproperties[ids[i]] = struct{}{}
	}
}

// RemovedProperties returns the removed IDs of the "properties" edge to the Property entity.
func (m *HostServiceMutation) RemovedPropertiesIDs() (ids []string) {
	for id := range m.removedproperties {
		ids = append(ids, id)
	}
	return
}

// PropertiesIDs returns the "properties" edge IDs in the mutation.
func (m *HostServiceMutation) PropertiesIDs() (ids []string) {
	for id := range m.properties {
		ids = append(ids, id)
	}
	return
}

// ResetProperties resets all changes to the "properties" edge.
func (m *HostServiceMutation) ResetProperties() {
	m.properties = nil
	m.clearedproperties = false
	m.removedproperties = nil
}

// SetHostservicereportID sets the "hostservicereport" edge to the HostServiceReport entity by id.
func (m *HostServiceMutation) SetHostservicereportID(id string) {
	m.hostservicereport = &id
}

// ClearHostservicereport clears the "hostservicereport" edge to the HostServiceReport entity.
func (m *HostServiceMutation) ClearHostservicereport() {
	m.clearedhostservicereport = true
}

// HostservicereportCleared reports if the "hostservicereport" edge to the HostServiceReport entity was cleared.
func (m *HostServiceMutation) HostservicereportCleared() bool {
	return m.clearedhostservicereport
}

// HostservicereportID returns the "hostservicereport" edge ID in the mutation.
func (m *HostServiceMutation) HostservicereportID() (id string, exists bool) {
	if m.hostservicereport != nil {
		return *m.hostservicereport, true
	}
	return
}

// HostservicereportIDs returns the "hostservicereport" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostservicereportID instead. It exists only for internal usage by the builders.
func (m *HostServiceMutation) HostservicereportIDs() (ids []string) {
	if id := m.hostservicereport; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHostservicereport resets all changes to the "hostservicereport" edge.
func (m *HostServiceMutation) ResetHostservicereport() {
	m.hostservicereport = nil
	m.clearedhostservicereport = false
}

// ClearService clears the "service" edge to the Service entity.
func (m *HostServiceMutation) ClearService() {
	m.clearedservice = true
}

// ServiceCleared reports if the "service" edge to the Service entity was cleared.
func (m *HostServiceMutation) ServiceCleared() bool {
	return m.clearedservice
}

// ServiceIDs returns the "service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceID instead. It exists only for internal usage by the builders.
func (m *HostServiceMutation) ServiceIDs() (ids []string) {
	if id := m.service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetService resets all changes to the "service" edge.
func (m *HostServiceMutation) ResetService() {
	m.service = nil
	m.clearedservice = false
}

// ClearHost clears the "host" edge to the Host entity.
func (m *HostServiceMutation) ClearHost() {
	m.clearedhost = true
}

// HostCleared reports if the "host" edge to the Host entity was cleared.
func (m *HostServiceMutation) HostCleared() bool {
	return m.clearedhost
}

// HostIDs returns the "host" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostID instead. It exists only for internal usage by the builders.
func (m *HostServiceMutation) HostIDs() (ids []string) {
	if id := m.host; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHost resets all changes to the "host" edge.
func (m *HostServiceMutation) ResetHost() {
	m.host = nil
	m.clearedhost = false
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *HostServiceMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *HostServiceMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *HostServiceMutation) TeamIDs() (ids []string) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *HostServiceMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// Where appends a list predicates to the HostServiceMutation builder.
func (m *HostServiceMutation) Where(ps ...predicate.HostService) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HostServiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HostServiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HostService, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HostServiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HostServiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HostService).
func (m *HostServiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HostServiceMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, hostservice.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, hostservice.FieldDisplayName)
	}
	if m.pause != nil {
		fields = append(fields, hostservice.FieldPause)
	}
	if m.hidden != nil {
		fields = append(fields, hostservice.FieldHidden)
	}
	if m.create_time != nil {
		fields = append(fields, hostservice.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, hostservice.FieldUpdateTime)
	}
	if m.service != nil {
		fields = append(fields, hostservice.FieldServiceID)
	}
	if m.host != nil {
		fields = append(fields, hostservice.FieldHostID)
	}
	if m.team != nil {
		fields = append(fields, hostservice.FieldTeamID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HostServiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hostservice.FieldName:
		return m.Name()
	case hostservice.FieldDisplayName:
		return m.DisplayName()
	case hostservice.FieldPause:
		return m.Pause()
	case hostservice.FieldHidden:
		return m.Hidden()
	case hostservice.FieldCreateTime:
		return m.CreateTime()
	case hostservice.FieldUpdateTime:
		return m.UpdateTime()
	case hostservice.FieldServiceID:
		return m.ServiceID()
	case hostservice.FieldHostID:
		return m.HostID()
	case hostservice.FieldTeamID:
		return m.TeamID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HostServiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hostservice.FieldName:
		return m.OldName(ctx)
	case hostservice.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case hostservice.FieldPause:
		return m.OldPause(ctx)
	case hostservice.FieldHidden:
		return m.OldHidden(ctx)
	case hostservice.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case hostservice.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case hostservice.FieldServiceID:
		return m.OldServiceID(ctx)
	case hostservice.FieldHostID:
		return m.OldHostID(ctx)
	case hostservice.FieldTeamID:
		return m.OldTeamID(ctx)
	}
	return nil, fmt.Errorf("unknown HostService field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostServiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hostservice.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case hostservice.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case hostservice.FieldPause:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPause(v)
		return nil
	case hostservice.FieldHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHidden(v)
		return nil
	case hostservice.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case hostservice.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case hostservice.FieldServiceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceID(v)
		return nil
	case hostservice.FieldHostID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostID(v)
		return nil
	case hostservice.FieldTeamID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	}
	return fmt.Errorf("unknown HostService field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HostServiceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HostServiceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostServiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HostService numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HostServiceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hostservice.FieldPause) {
		fields = append(fields, hostservice.FieldPause)
	}
	if m.FieldCleared(hostservice.FieldHidden) {
		fields = append(fields, hostservice.FieldHidden)
	}
	if m.FieldCleared(hostservice.FieldCreateTime) {
		fields = append(fields, hostservice.FieldCreateTime)
	}
	if m.FieldCleared(hostservice.FieldUpdateTime) {
		fields = append(fields, hostservice.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HostServiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HostServiceMutation) ClearField(name string) error {
	switch name {
	case hostservice.FieldPause:
		m.ClearPause()
		return nil
	case hostservice.FieldHidden:
		m.ClearHidden()
		return nil
	case hostservice.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case hostservice.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown HostService nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HostServiceMutation) ResetField(name string) error {
	switch name {
	case hostservice.FieldName:
		m.ResetName()
		return nil
	case hostservice.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case hostservice.FieldPause:
		m.ResetPause()
		return nil
	case hostservice.FieldHidden:
		m.ResetHidden()
		return nil
	case hostservice.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case hostservice.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case hostservice.FieldServiceID:
		m.ResetServiceID()
		return nil
	case hostservice.FieldHostID:
		m.ResetHostID()
		return nil
	case hostservice.FieldTeamID:
		m.ResetTeamID()
		return nil
	}
	return fmt.Errorf("unknown HostService field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HostServiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.checks != nil {
		edges = append(edges, hostservice.EdgeChecks)
	}
	if m.properties != nil {
		edges = append(edges, hostservice.EdgeProperties)
	}
	if m.hostservicereport != nil {
		edges = append(edges, hostservice.EdgeHostservicereport)
	}
	if m.service != nil {
		edges = append(edges, hostservice.EdgeService)
	}
	if m.host != nil {
		edges = append(edges, hostservice.EdgeHost)
	}
	if m.team != nil {
		edges = append(edges, hostservice.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HostServiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hostservice.EdgeChecks:
		ids := make([]ent.Value, 0, len(m.checks))
		for id := range m.checks {
			ids = append(ids, id)
		}
		return ids
	case hostservice.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.properties))
		for id := range m.properties {
			ids = append(ids, id)
		}
		return ids
	case hostservice.EdgeHostservicereport:
		if id := m.hostservicereport; id != nil {
			return []ent.Value{*id}
		}
	case hostservice.EdgeService:
		if id := m.service; id != nil {
			return []ent.Value{*id}
		}
	case hostservice.EdgeHost:
		if id := m.host; id != nil {
			return []ent.Value{*id}
		}
	case hostservice.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HostServiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedchecks != nil {
		edges = append(edges, hostservice.EdgeChecks)
	}
	if m.removedproperties != nil {
		edges = append(edges, hostservice.EdgeProperties)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HostServiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hostservice.EdgeChecks:
		ids := make([]ent.Value, 0, len(m.removedchecks))
		for id := range m.removedchecks {
			ids = append(ids, id)
		}
		return ids
	case hostservice.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.removedproperties))
		for id := range m.removedproperties {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HostServiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedchecks {
		edges = append(edges, hostservice.EdgeChecks)
	}
	if m.clearedproperties {
		edges = append(edges, hostservice.EdgeProperties)
	}
	if m.clearedhostservicereport {
		edges = append(edges, hostservice.EdgeHostservicereport)
	}
	if m.clearedservice {
		edges = append(edges, hostservice.EdgeService)
	}
	if m.clearedhost {
		edges = append(edges, hostservice.EdgeHost)
	}
	if m.clearedteam {
		edges = append(edges, hostservice.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HostServiceMutation) EdgeCleared(name string) bool {
	switch name {
	case hostservice.EdgeChecks:
		return m.clearedchecks
	case hostservice.EdgeProperties:
		return m.clearedproperties
	case hostservice.EdgeHostservicereport:
		return m.clearedhostservicereport
	case hostservice.EdgeService:
		return m.clearedservice
	case hostservice.EdgeHost:
		return m.clearedhost
	case hostservice.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HostServiceMutation) ClearEdge(name string) error {
	switch name {
	case hostservice.EdgeHostservicereport:
		m.ClearHostservicereport()
		return nil
	case hostservice.EdgeService:
		m.ClearService()
		return nil
	case hostservice.EdgeHost:
		m.ClearHost()
		return nil
	case hostservice.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown HostService unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HostServiceMutation) ResetEdge(name string) error {
	switch name {
	case hostservice.EdgeChecks:
		m.ResetChecks()
		return nil
	case hostservice.EdgeProperties:
		m.ResetProperties()
		return nil
	case hostservice.EdgeHostservicereport:
		m.ResetHostservicereport()
		return nil
	case hostservice.EdgeService:
		m.ResetService()
		return nil
	case hostservice.EdgeHost:
		m.ResetHost()
		return nil
	case hostservice.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown HostService edge %s", name)
}

// HostServiceReportMutation represents an operation that mutates the HostServiceReport nodes in the graph.
type HostServiceReportMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	create_time        *time.Time
	update_time        *time.Time
	points             *int
	addpoints          *int
	passing            *bool
	latest_check_time  *time.Time
	clearedFields      map[string]struct{}
	hostservice        *string
	clearedhostservice bool
	service            *string
	clearedservice     bool
	team               *string
	clearedteam        bool
	teamreport         *string
	clearedteamreport  bool
	done               bool
	oldValue           func(context.Context) (*HostServiceReport, error)
	predicates         []predicate.HostServiceReport
}

var _ ent.Mutation = (*HostServiceReportMutation)(nil)

// hostservicereportOption allows management of the mutation configuration using functional options.
type hostservicereportOption func(*HostServiceReportMutation)

// newHostServiceReportMutation creates new mutation for the HostServiceReport entity.
func newHostServiceReportMutation(c config, op Op, opts ...hostservicereportOption) *HostServiceReportMutation {
	m := &HostServiceReportMutation{
		config:        c,
		op:            op,
		typ:           TypeHostServiceReport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHostServiceReportID sets the ID field of the mutation.
func withHostServiceReportID(id string) hostservicereportOption {
	return func(m *HostServiceReportMutation) {
		var (
			err   error
			once  sync.Once
			value *HostServiceReport
		)
		m.oldValue = func(ctx context.Context) (*HostServiceReport, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HostServiceReport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHostServiceReport sets the old HostServiceReport of the mutation.
func withHostServiceReport(node *HostServiceReport) hostservicereportOption {
	return func(m *HostServiceReportMutation) {
		m.oldValue = func(context.Context) (*HostServiceReport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HostServiceReportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HostServiceReportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entities: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HostServiceReport entities.
func (m *HostServiceReportMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HostServiceReportMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HostServiceReportMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HostServiceReport.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *HostServiceReportMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *HostServiceReportMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the HostServiceReport entity.
// If the HostServiceReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostServiceReportMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *HostServiceReportMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[hostservicereport.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *HostServiceReportMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[hostservicereport.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *HostServiceReportMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, hostservicereport.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *HostServiceReportMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *HostServiceReportMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the HostServiceReport entity.
// If the HostServiceReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostServiceReportMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *HostServiceReportMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[hostservicereport.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *HostServiceReportMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[hostservicereport.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *HostServiceReportMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, hostservicereport.FieldUpdateTime)
}

// SetPoints sets the "points" field.
func (m *HostServiceReportMutation) SetPoints(i int) {
	m.points = &i
	m.addpoints = nil
}

// Points returns the value of the "points" field in the mutation.
func (m *HostServiceReportMutation) Points() (r int, exists bool) {
	v := m.points
	if v == nil {
		return
	}
	return *v, true
}

// OldPoints returns the old "points" field's value of the HostServiceReport entity.
// If the HostServiceReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostServiceReportMutation) OldPoints(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoints: %w", err)
	}
	return oldValue.Points, nil
}

// AddPoints adds i to the "points" field.
func (m *HostServiceReportMutation) AddPoints(i int) {
	if m.addpoints != nil {
		*m.addpoints += i
	} else {
		m.addpoints = &i
	}
}

// AddedPoints returns the value that was added to the "points" field in this mutation.
func (m *HostServiceReportMutation) AddedPoints() (r int, exists bool) {
	v := m.addpoints
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoints resets all changes to the "points" field.
func (m *HostServiceReportMutation) ResetPoints() {
	m.points = nil
	m.addpoints = nil
}

// SetPassing sets the "passing" field.
func (m *HostServiceReportMutation) SetPassing(b bool) {
	m.passing = &b
}

// Passing returns the value of the "passing" field in the mutation.
func (m *HostServiceReportMutation) Passing() (r bool, exists bool) {
	v := m.passing
	if v == nil {
		return
	}
	return *v, true
}

// OldPassing returns the old "passing" field's value of the HostServiceReport entity.
// If the HostServiceReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostServiceReportMutation) OldPassing(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassing is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassing requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassing: %w", err)
	}
	return oldValue.Passing, nil
}

// ResetPassing resets all changes to the "passing" field.
func (m *HostServiceReportMutation) ResetPassing() {
	m.passing = nil
}

// SetLatestCheckTime sets the "latest_check_time" field.
func (m *HostServiceReportMutation) SetLatestCheckTime(t time.Time) {
	m.latest_check_time = &t
}

// LatestCheckTime returns the value of the "latest_check_time" field in the mutation.
func (m *HostServiceReportMutation) LatestCheckTime() (r time.Time, exists bool) {
	v := m.latest_check_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLatestCheckTime returns the old "latest_check_time" field's value of the HostServiceReport entity.
// If the HostServiceReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostServiceReportMutation) OldLatestCheckTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatestCheckTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatestCheckTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatestCheckTime: %w", err)
	}
	return oldValue.LatestCheckTime, nil
}

// ResetLatestCheckTime resets all changes to the "latest_check_time" field.
func (m *HostServiceReportMutation) ResetLatestCheckTime() {
	m.latest_check_time = nil
}

// SetHostServiceID sets the "host_service_id" field.
func (m *HostServiceReportMutation) SetHostServiceID(s string) {
	m.hostservice = &s
}

// HostServiceID returns the value of the "host_service_id" field in the mutation.
func (m *HostServiceReportMutation) HostServiceID() (r string, exists bool) {
	v := m.hostservice
	if v == nil {
		return
	}
	return *v, true
}

// OldHostServiceID returns the old "host_service_id" field's value of the HostServiceReport entity.
// If the HostServiceReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostServiceReportMutation) OldHostServiceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostServiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostServiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostServiceID: %w", err)
	}
	return oldValue.HostServiceID, nil
}

// ResetHostServiceID resets all changes to the "host_service_id" field.
func (m *HostServiceReportMutation) ResetHostServiceID() {
	m.hostservice = nil
}

// SetServiceID sets the "service_id" field.
func (m *HostServiceReportMutation) SetServiceID(s string) {
	m.service = &s
}

// ServiceID returns the value of the "service_id" field in the mutation.
func (m *HostServiceReportMutation) ServiceID() (r string, exists bool) {
	v := m.service
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceID returns the old "service_id" field's value of the HostServiceReport entity.
// If the HostServiceReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostServiceReportMutation) OldServiceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceID: %w", err)
	}
	return oldValue.ServiceID, nil
}

// ResetServiceID resets all changes to the "service_id" field.
func (m *HostServiceReportMutation) ResetServiceID() {
	m.service = nil
}

// SetTeamID sets the "team_id" field.
func (m *HostServiceReportMutation) SetTeamID(s string) {
	m.team = &s
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *HostServiceReportMutation) TeamID() (r string, exists bool) {
	v := m.team
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the HostServiceReport entity.
// If the HostServiceReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostServiceReportMutation) OldTeamID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *HostServiceReportMutation) ResetTeamID() {
	m.team = nil
}

// SetTeamReportID sets the "team_report_id" field.
func (m *HostServiceReportMutation) SetTeamReportID(s string) {
	m.teamreport = &s
}

// TeamReportID returns the value of the "team_report_id" field in the mutation.
func (m *HostServiceReportMutation) TeamReportID() (r string, exists bool) {
	v := m.teamreport
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamReportID returns the old "team_report_id" field's value of the HostServiceReport entity.
// If the HostServiceReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostServiceReportMutation) OldTeamReportID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamReportID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamReportID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamReportID: %w", err)
	}
	return oldValue.TeamReportID, nil
}

// ClearTeamReportID clears the value of the "team_report_id" field.
func (m *HostServiceReportMutation) ClearTeamReportID() {
	m.teamreport = nil
	m.clearedFields[hostservicereport.FieldTeamReportID] = struct{}{}
}

// TeamReportIDCleared returns if the "team_report_id" field was cleared in this mutation.
func (m *HostServiceReportMutation) TeamReportIDCleared() bool {
	_, ok := m.clearedFields[hostservicereport.FieldTeamReportID]
	return ok
}

// ResetTeamReportID resets all changes to the "team_report_id" field.
func (m *HostServiceReportMutation) ResetTeamReportID() {
	m.teamreport = nil
	delete(m.clearedFields, hostservicereport.FieldTeamReportID)
}

// SetHostserviceID sets the "hostservice" edge to the HostService entity by id.
func (m *HostServiceReportMutation) SetHostserviceID(id string) {
	m.hostservice = &id
}

// ClearHostservice clears the "hostservice" edge to the HostService entity.
func (m *HostServiceReportMutation) ClearHostservice() {
	m.clearedhostservice = true
}

// HostserviceCleared reports if the "hostservice" edge to the HostService entity was cleared.
func (m *HostServiceReportMutation) HostserviceCleared() bool {
	return m.clearedhostservice
}

// HostserviceID returns the "hostservice" edge ID in the mutation.
func (m *HostServiceReportMutation) HostserviceID() (id string, exists bool) {
	if m.hostservice != nil {
		return *m.hostservice, true
	}
	return
}

// HostserviceIDs returns the "hostservice" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostserviceID instead. It exists only for internal usage by the builders.
func (m *HostServiceReportMutation) HostserviceIDs() (ids []string) {
	if id := m.hostservice; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHostservice resets all changes to the "hostservice" edge.
func (m *HostServiceReportMutation) ResetHostservice() {
	m.hostservice = nil
	m.clearedhostservice = false
}

// ClearService clears the "service" edge to the Service entity.
func (m *HostServiceReportMutation) ClearService() {
	m.clearedservice = true
}

// ServiceCleared reports if the "service" edge to the Service entity was cleared.
func (m *HostServiceReportMutation) ServiceCleared() bool {
	return m.clearedservice
}

// ServiceIDs returns the "service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceID instead. It exists only for internal usage by the builders.
func (m *HostServiceReportMutation) ServiceIDs() (ids []string) {
	if id := m.service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetService resets all changes to the "service" edge.
func (m *HostServiceReportMutation) ResetService() {
	m.service = nil
	m.clearedservice = false
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *HostServiceReportMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *HostServiceReportMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *HostServiceReportMutation) TeamIDs() (ids []string) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *HostServiceReportMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// SetTeamreportID sets the "teamreport" edge to the TeamReport entity by id.
func (m *HostServiceReportMutation) SetTeamreportID(id string) {
	m.teamreport = &id
}

// ClearTeamreport clears the "teamreport" edge to the TeamReport entity.
func (m *HostServiceReportMutation) ClearTeamreport() {
	m.clearedteamreport = true
}

// TeamreportCleared reports if the "teamreport" edge to the TeamReport entity was cleared.
func (m *HostServiceReportMutation) TeamreportCleared() bool {
	return m.TeamReportIDCleared() || m.clearedteamreport
}

// TeamreportID returns the "teamreport" edge ID in the mutation.
func (m *HostServiceReportMutation) TeamreportID() (id string, exists bool) {
	if m.teamreport != nil {
		return *m.teamreport, true
	}
	return
}

// TeamreportIDs returns the "teamreport" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamreportID instead. It exists only for internal usage by the builders.
func (m *HostServiceReportMutation) TeamreportIDs() (ids []string) {
	if id := m.teamreport; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeamreport resets all changes to the "teamreport" edge.
func (m *HostServiceReportMutation) ResetTeamreport() {
	m.teamreport = nil
	m.clearedteamreport = false
}

// Where appends a list predicates to the HostServiceReportMutation builder.
func (m *HostServiceReportMutation) Where(ps ...predicate.HostServiceReport) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HostServiceReportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HostServiceReportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HostServiceReport, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HostServiceReportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HostServiceReportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HostServiceReport).
func (m *HostServiceReportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HostServiceReportMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, hostservicereport.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, hostservicereport.FieldUpdateTime)
	}
	if m.points != nil {
		fields = append(fields, hostservicereport.FieldPoints)
	}
	if m.passing != nil {
		fields = append(fields, hostservicereport.FieldPassing)
	}
	if m.latest_check_time != nil {
		fields = append(fields, hostservicereport.FieldLatestCheckTime)
	}
	if m.hostservice != nil {
		fields = append(fields, hostservicereport.FieldHostServiceID)
	}
	if m.service != nil {
		fields = append(fields, hostservicereport.FieldServiceID)
	}
	if m.team != nil {
		fields = append(fields, hostservicereport.FieldTeamID)
	}
	if m.teamreport != nil {
		fields = append(fields, hostservicereport.FieldTeamReportID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HostServiceReportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hostservicereport.FieldCreateTime:
		return m.CreateTime()
	case hostservicereport.FieldUpdateTime:
		return m.UpdateTime()
	case hostservicereport.FieldPoints:
		return m.Points()
	case hostservicereport.FieldPassing:
		return m.Passing()
	case hostservicereport.FieldLatestCheckTime:
		return m.LatestCheckTime()
	case hostservicereport.FieldHostServiceID:
		return m.HostServiceID()
	case hostservicereport.FieldServiceID:
		return m.ServiceID()
	case hostservicereport.FieldTeamID:
		return m.TeamID()
	case hostservicereport.FieldTeamReportID:
		return m.TeamReportID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HostServiceReportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hostservicereport.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case hostservicereport.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case hostservicereport.FieldPoints:
		return m.OldPoints(ctx)
	case hostservicereport.FieldPassing:
		return m.OldPassing(ctx)
	case hostservicereport.FieldLatestCheckTime:
		return m.OldLatestCheckTime(ctx)
	case hostservicereport.FieldHostServiceID:
		return m.OldHostServiceID(ctx)
	case hostservicereport.FieldServiceID:
		return m.OldServiceID(ctx)
	case hostservicereport.FieldTeamID:
		return m.OldTeamID(ctx)
	case hostservicereport.FieldTeamReportID:
		return m.OldTeamReportID(ctx)
	}
	return nil, fmt.Errorf("unknown HostServiceReport field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostServiceReportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hostservicereport.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case hostservicereport.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case hostservicereport.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoints(v)
		return nil
	case hostservicereport.FieldPassing:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassing(v)
		return nil
	case hostservicereport.FieldLatestCheckTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatestCheckTime(v)
		return nil
	case hostservicereport.FieldHostServiceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostServiceID(v)
		return nil
	case hostservicereport.FieldServiceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceID(v)
		return nil
	case hostservicereport.FieldTeamID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	case hostservicereport.FieldTeamReportID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamReportID(v)
		return nil
	}
	return fmt.Errorf("unknown HostServiceReport field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HostServiceReportMutation) AddedFields() []string {
	var fields []string
	if m.addpoints != nil {
		fields = append(fields, hostservicereport.FieldPoints)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HostServiceReportMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hostservicereport.FieldPoints:
		return m.AddedPoints()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostServiceReportMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hostservicereport.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoints(v)
		return nil
	}
	return fmt.Errorf("unknown HostServiceReport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HostServiceReportMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hostservicereport.FieldCreateTime) {
		fields = append(fields, hostservicereport.FieldCreateTime)
	}
	if m.FieldCleared(hostservicereport.FieldUpdateTime) {
		fields = append(fields, hostservicereport.FieldUpdateTime)
	}
	if m.FieldCleared(hostservicereport.FieldTeamReportID) {
		fields = append(fields, hostservicereport.FieldTeamReportID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HostServiceReportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HostServiceReportMutation) ClearField(name string) error {
	switch name {
	case hostservicereport.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case hostservicereport.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case hostservicereport.FieldTeamReportID:
		m.ClearTeamReportID()
		return nil
	}
	return fmt.Errorf("unknown HostServiceReport nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HostServiceReportMutation) ResetField(name string) error {
	switch name {
	case hostservicereport.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case hostservicereport.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case hostservicereport.FieldPoints:
		m.ResetPoints()
		return nil
	case hostservicereport.FieldPassing:
		m.ResetPassing()
		return nil
	case hostservicereport.FieldLatestCheckTime:
		m.ResetLatestCheckTime()
		return nil
	case hostservicereport.FieldHostServiceID:
		m.ResetHostServiceID()
		return nil
	case hostservicereport.FieldServiceID:
		m.ResetServiceID()
		return nil
	case hostservicereport.FieldTeamID:
		m.ResetTeamID()
		return nil
	case hostservicereport.FieldTeamReportID:
		m.ResetTeamReportID()
		return nil
	}
	return fmt.Errorf("unknown HostServiceReport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HostServiceReportMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.hostservice != nil {
		edges = append(edges, hostservicereport.EdgeHostservice)
	}
	if m.service != nil {
		edges = append(edges, hostservicereport.EdgeService)
	}
	if m.team != nil {
		edges = append(edges, hostservicereport.EdgeTeam)
	}
	if m.teamreport != nil {
		edges = append(edges, hostservicereport.EdgeTeamreport)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HostServiceReportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hostservicereport.EdgeHostservice:
		if id := m.hostservice; id != nil {
			return []ent.Value{*id}
		}
	case hostservicereport.EdgeService:
		if id := m.service; id != nil {
			return []ent.Value{*id}
		}
	case hostservicereport.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	case hostservicereport.EdgeTeamreport:
		if id := m.teamreport; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HostServiceReportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HostServiceReportMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HostServiceReportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedhostservice {
		edges = append(edges, hostservicereport.EdgeHostservice)
	}
	if m.clearedservice {
		edges = append(edges, hostservicereport.EdgeService)
	}
	if m.clearedteam {
		edges = append(edges, hostservicereport.EdgeTeam)
	}
	if m.clearedteamreport {
		edges = append(edges, hostservicereport.EdgeTeamreport)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HostServiceReportMutation) EdgeCleared(name string) bool {
	switch name {
	case hostservicereport.EdgeHostservice:
		return m.clearedhostservice
	case hostservicereport.EdgeService:
		return m.clearedservice
	case hostservicereport.EdgeTeam:
		return m.clearedteam
	case hostservicereport.EdgeTeamreport:
		return m.clearedteamreport
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HostServiceReportMutation) ClearEdge(name string) error {
	switch name {
	case hostservicereport.EdgeHostservice:
		m.ClearHostservice()
		return nil
	case hostservicereport.EdgeService:
		m.ClearService()
		return nil
	case hostservicereport.EdgeTeam:
		m.ClearTeam()
		return nil
	case hostservicereport.EdgeTeamreport:
		m.ClearTeamreport()
		return nil
	}
	return fmt.Errorf("unknown HostServiceReport unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HostServiceReportMutation) ResetEdge(name string) error {
	switch name {
	case hostservicereport.EdgeHostservice:
		m.ResetHostservice()
		return nil
	case hostservicereport.EdgeService:
		m.ResetService()
		return nil
	case hostservicereport.EdgeTeam:
		m.ResetTeam()
		return nil
	case hostservicereport.EdgeTeamreport:
		m.ResetTeamreport()
		return nil
	}
	return fmt.Errorf("unknown HostServiceReport edge %s", name)
}

// PropertyMutation represents an operation that mutates the Property nodes in the graph.
type PropertyMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	create_time        *time.Time
	update_time        *time.Time
	key                *string
	value              *string
	clearedFields      map[string]struct{}
	hostservice        *string
	clearedhostservice bool
	done               bool
	oldValue           func(context.Context) (*Property, error)
	predicates         []predicate.Property
}

var _ ent.Mutation = (*PropertyMutation)(nil)

// propertyOption allows management of the mutation configuration using functional options.
type propertyOption func(*PropertyMutation)

// newPropertyMutation creates new mutation for the Property entity.
func newPropertyMutation(c config, op Op, opts ...propertyOption) *PropertyMutation {
	m := &PropertyMutation{
		config:        c,
		op:            op,
		typ:           TypeProperty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPropertyID sets the ID field of the mutation.
func withPropertyID(id string) propertyOption {
	return func(m *PropertyMutation) {
		var (
			err   error
			once  sync.Once
			value *Property
		)
		m.oldValue = func(ctx context.Context) (*Property, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Property.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProperty sets the old Property of the mutation.
func withProperty(node *Property) propertyOption {
	return func(m *PropertyMutation) {
		m.oldValue = func(context.Context) (*Property, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PropertyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PropertyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entities: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Property entities.
func (m *PropertyMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PropertyMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PropertyMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Property.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *PropertyMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PropertyMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *PropertyMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[property.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *PropertyMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[property.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PropertyMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, property.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *PropertyMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PropertyMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *PropertyMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[property.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *PropertyMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[property.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PropertyMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, property.FieldUpdateTime)
}

// SetKey sets the "key" field.
func (m *PropertyMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *PropertyMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *PropertyMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *PropertyMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *PropertyMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *PropertyMutation) ResetValue() {
	m.value = nil
}

// SetHostServiceID sets the "host_service_id" field.
func (m *PropertyMutation) SetHostServiceID(s string) {
	m.hostservice = &s
}

// HostServiceID returns the value of the "host_service_id" field in the mutation.
func (m *PropertyMutation) HostServiceID() (r string, exists bool) {
	v := m.hostservice
	if v == nil {
		return
	}
	return *v, true
}

// OldHostServiceID returns the old "host_service_id" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldHostServiceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostServiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostServiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostServiceID: %w", err)
	}
	return oldValue.HostServiceID, nil
}

// ResetHostServiceID resets all changes to the "host_service_id" field.
func (m *PropertyMutation) ResetHostServiceID() {
	m.hostservice = nil
}

// SetHostserviceID sets the "hostservice" edge to the HostService entity by id.
func (m *PropertyMutation) SetHostserviceID(id string) {
	m.hostservice = &id
}

// ClearHostservice clears the "hostservice" edge to the HostService entity.
func (m *PropertyMutation) ClearHostservice() {
	m.clearedhostservice = true
}

// HostserviceCleared reports if the "hostservice" edge to the HostService entity was cleared.
func (m *PropertyMutation) HostserviceCleared() bool {
	return m.clearedhostservice
}

// HostserviceID returns the "hostservice" edge ID in the mutation.
func (m *PropertyMutation) HostserviceID() (id string, exists bool) {
	if m.hostservice != nil {
		return *m.hostservice, true
	}
	return
}

// HostserviceIDs returns the "hostservice" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostserviceID instead. It exists only for internal usage by the builders.
func (m *PropertyMutation) HostserviceIDs() (ids []string) {
	if id := m.hostservice; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHostservice resets all changes to the "hostservice" edge.
func (m *PropertyMutation) ResetHostservice() {
	m.hostservice = nil
	m.clearedhostservice = false
}

// Where appends a list predicates to the PropertyMutation builder.
func (m *PropertyMutation) Where(ps ...predicate.Property) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PropertyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PropertyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Property, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PropertyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PropertyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Property).
func (m *PropertyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PropertyMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, property.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, property.FieldUpdateTime)
	}
	if m.key != nil {
		fields = append(fields, property.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, property.FieldValue)
	}
	if m.hostservice != nil {
		fields = append(fields, property.FieldHostServiceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PropertyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case property.FieldCreateTime:
		return m.CreateTime()
	case property.FieldUpdateTime:
		return m.UpdateTime()
	case property.FieldKey:
		return m.Key()
	case property.FieldValue:
		return m.Value()
	case property.FieldHostServiceID:
		return m.HostServiceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PropertyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case property.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case property.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case property.FieldKey:
		return m.OldKey(ctx)
	case property.FieldValue:
		return m.OldValue(ctx)
	case property.FieldHostServiceID:
		return m.OldHostServiceID(ctx)
	}
	return nil, fmt.Errorf("unknown Property field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PropertyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case property.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case property.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case property.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case property.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case property.FieldHostServiceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostServiceID(v)
		return nil
	}
	return fmt.Errorf("unknown Property field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PropertyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PropertyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PropertyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Property numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PropertyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(property.FieldCreateTime) {
		fields = append(fields, property.FieldCreateTime)
	}
	if m.FieldCleared(property.FieldUpdateTime) {
		fields = append(fields, property.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PropertyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PropertyMutation) ClearField(name string) error {
	switch name {
	case property.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case property.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Property nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PropertyMutation) ResetField(name string) error {
	switch name {
	case property.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case property.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case property.FieldKey:
		m.ResetKey()
		return nil
	case property.FieldValue:
		m.ResetValue()
		return nil
	case property.FieldHostServiceID:
		m.ResetHostServiceID()
		return nil
	}
	return fmt.Errorf("unknown Property field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PropertyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.hostservice != nil {
		edges = append(edges, property.EdgeHostservice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PropertyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case property.EdgeHostservice:
		if id := m.hostservice; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PropertyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PropertyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PropertyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedhostservice {
		edges = append(edges, property.EdgeHostservice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PropertyMutation) EdgeCleared(name string) bool {
	switch name {
	case property.EdgeHostservice:
		return m.clearedhostservice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PropertyMutation) ClearEdge(name string) error {
	switch name {
	case property.EdgeHostservice:
		m.ClearHostservice()
		return nil
	}
	return fmt.Errorf("unknown Property unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PropertyMutation) ResetEdge(name string) error {
	switch name {
	case property.EdgeHostservice:
		m.ResetHostservice()
		return nil
	}
	return fmt.Errorf("unknown Property edge %s", name)
}

// RoundMutation represents an operation that mutates the Round nodes in the graph.
type RoundMutation struct {
	config
	op                        Op
	typ                       string
	id                        *string
	create_time               *time.Time
	update_time               *time.Time
	round_number              *int
	addround_number           *int
	num_of_intended_checks    *int
	addnum_of_intended_checks *int
	status                    *round.Status
	started_at                *time.Time
	finished_at               *time.Time
	clearedFields             map[string]struct{}
	checks                    map[string]struct{}
	removedchecks             map[string]struct{}
	clearedchecks             bool
	done                      bool
	oldValue                  func(context.Context) (*Round, error)
	predicates                []predicate.Round
}

var _ ent.Mutation = (*RoundMutation)(nil)

// roundOption allows management of the mutation configuration using functional options.
type roundOption func(*RoundMutation)

// newRoundMutation creates new mutation for the Round entity.
func newRoundMutation(c config, op Op, opts ...roundOption) *RoundMutation {
	m := &RoundMutation{
		config:        c,
		op:            op,
		typ:           TypeRound,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoundID sets the ID field of the mutation.
func withRoundID(id string) roundOption {
	return func(m *RoundMutation) {
		var (
			err   error
			once  sync.Once
			value *Round
		)
		m.oldValue = func(ctx context.Context) (*Round, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Round.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRound sets the old Round of the mutation.
func withRound(node *Round) roundOption {
	return func(m *RoundMutation) {
		m.oldValue = func(context.Context) (*Round, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoundMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoundMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entities: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Round entities.
func (m *RoundMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoundMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoundMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Round.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *RoundMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *RoundMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *RoundMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[round.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *RoundMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[round.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *RoundMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, round.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *RoundMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *RoundMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *RoundMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[round.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *RoundMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[round.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *RoundMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, round.FieldUpdateTime)
}

// SetRoundNumber sets the "round_number" field.
func (m *RoundMutation) SetRoundNumber(i int) {
	m.round_number = &i
	m.addround_number = nil
}

// RoundNumber returns the value of the "round_number" field in the mutation.
func (m *RoundMutation) RoundNumber() (r int, exists bool) {
	v := m.round_number
	if v == nil {
		return
	}
	return *v, true
}

// OldRoundNumber returns the old "round_number" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldRoundNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoundNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoundNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoundNumber: %w", err)
	}
	return oldValue.RoundNumber, nil
}

// AddRoundNumber adds i to the "round_number" field.
func (m *RoundMutation) AddRoundNumber(i int) {
	if m.addround_number != nil {
		*m.addround_number += i
	} else {
		m.addround_number = &i
	}
}

// AddedRoundNumber returns the value that was added to the "round_number" field in this mutation.
func (m *RoundMutation) AddedRoundNumber() (r int, exists bool) {
	v := m.addround_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoundNumber resets all changes to the "round_number" field.
func (m *RoundMutation) ResetRoundNumber() {
	m.round_number = nil
	m.addround_number = nil
}

// SetNumOfIntendedChecks sets the "num_of_intended_checks" field.
func (m *RoundMutation) SetNumOfIntendedChecks(i int) {
	m.num_of_intended_checks = &i
	m.addnum_of_intended_checks = nil
}

// NumOfIntendedChecks returns the value of the "num_of_intended_checks" field in the mutation.
func (m *RoundMutation) NumOfIntendedChecks() (r int, exists bool) {
	v := m.num_of_intended_checks
	if v == nil {
		return
	}
	return *v, true
}

// OldNumOfIntendedChecks returns the old "num_of_intended_checks" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldNumOfIntendedChecks(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumOfIntendedChecks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumOfIntendedChecks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumOfIntendedChecks: %w", err)
	}
	return oldValue.NumOfIntendedChecks, nil
}

// AddNumOfIntendedChecks adds i to the "num_of_intended_checks" field.
func (m *RoundMutation) AddNumOfIntendedChecks(i int) {
	if m.addnum_of_intended_checks != nil {
		*m.addnum_of_intended_checks += i
	} else {
		m.addnum_of_intended_checks = &i
	}
}

// AddedNumOfIntendedChecks returns the value that was added to the "num_of_intended_checks" field in this mutation.
func (m *RoundMutation) AddedNumOfIntendedChecks() (r int, exists bool) {
	v := m.addnum_of_intended_checks
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumOfIntendedChecks clears the value of the "num_of_intended_checks" field.
func (m *RoundMutation) ClearNumOfIntendedChecks() {
	m.num_of_intended_checks = nil
	m.addnum_of_intended_checks = nil
	m.clearedFields[round.FieldNumOfIntendedChecks] = struct{}{}
}

// NumOfIntendedChecksCleared returns if the "num_of_intended_checks" field was cleared in this mutation.
func (m *RoundMutation) NumOfIntendedChecksCleared() bool {
	_, ok := m.clearedFields[round.FieldNumOfIntendedChecks]
	return ok
}

// ResetNumOfIntendedChecks resets all changes to the "num_of_intended_checks" field.
func (m *RoundMutation) ResetNumOfIntendedChecks() {
	m.num_of_intended_checks = nil
	m.addnum_of_intended_checks = nil
	delete(m.clearedFields, round.FieldNumOfIntendedChecks)
}

// SetStatus sets the "status" field.
func (m *RoundMutation) SetStatus(r round.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *RoundMutation) Status() (r round.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldStatus(ctx context.Context) (v round.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RoundMutation) ResetStatus() {
	m.status = nil
}

// SetStartedAt sets the "started_at" field.
func (m *RoundMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *RoundMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *RoundMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetFinishedAt sets the "finished_at" field.
func (m *RoundMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *RoundMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldFinishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ClearFinishedAt clears the value of the "finished_at" field.
func (m *RoundMutation) ClearFinishedAt() {
	m.finished_at = nil
	m.clearedFields[round.FieldFinishedAt] = struct{}{}
}

// FinishedAtCleared returns if the "finished_at" field was cleared in this mutation.
func (m *RoundMutation) FinishedAtCleared() bool {
	_, ok := m.clearedFields[round.FieldFinishedAt]
	return ok
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *RoundMutation) ResetFinishedAt() {
	m.finished_at = nil
	delete(m.clearedFields, round.FieldFinishedAt)
}

// AddCheckIDs adds the "checks" edge to the Check entity by ids.
func (m *RoundMutation) AddCheckIDs(ids ...string) {
	if m.checks == nil {
		m.checks = make(map[string]struct{})
	}
	for i := range ids {
		m.checks[ids[i]] = struct{}{}
	}
}

// ClearChecks clears the "checks" edge to the Check entity.
func (m *RoundMutation) ClearChecks() {
	m.clearedchecks = true
}

// ChecksCleared reports if the "checks" edge to the Check entity was cleared.
func (m *RoundMutation) ChecksCleared() bool {
	return m.clearedchecks
}

// RemoveCheckIDs removes the "checks" edge to the Check entity by IDs.
func (m *RoundMutation) RemoveCheckIDs(ids ...string) {
	if m.removedchecks == nil {
		m.removedchecks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.checks, ids[i])
		m.removedchecks[ids[i]] = struct{}{}
	}
}

// RemovedChecks returns the removed IDs of the "checks" edge to the Check entity.
func (m *RoundMutation) RemovedChecksIDs() (ids []string) {
	for id := range m.removedchecks {
		ids = append(ids, id)
	}
	return
}

// ChecksIDs returns the "checks" edge IDs in the mutation.
func (m *RoundMutation) ChecksIDs() (ids []string) {
	for id := range m.checks {
		ids = append(ids, id)
	}
	return
}

// ResetChecks resets all changes to the "checks" edge.
func (m *RoundMutation) ResetChecks() {
	m.checks = nil
	m.clearedchecks = false
	m.removedchecks = nil
}

// Where appends a list predicates to the RoundMutation builder.
func (m *RoundMutation) Where(ps ...predicate.Round) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoundMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoundMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Round, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoundMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoundMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Round).
func (m *RoundMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoundMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, round.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, round.FieldUpdateTime)
	}
	if m.round_number != nil {
		fields = append(fields, round.FieldRoundNumber)
	}
	if m.num_of_intended_checks != nil {
		fields = append(fields, round.FieldNumOfIntendedChecks)
	}
	if m.status != nil {
		fields = append(fields, round.FieldStatus)
	}
	if m.started_at != nil {
		fields = append(fields, round.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, round.FieldFinishedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoundMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case round.FieldCreateTime:
		return m.CreateTime()
	case round.FieldUpdateTime:
		return m.UpdateTime()
	case round.FieldRoundNumber:
		return m.RoundNumber()
	case round.FieldNumOfIntendedChecks:
		return m.NumOfIntendedChecks()
	case round.FieldStatus:
		return m.Status()
	case round.FieldStartedAt:
		return m.StartedAt()
	case round.FieldFinishedAt:
		return m.FinishedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoundMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case round.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case round.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case round.FieldRoundNumber:
		return m.OldRoundNumber(ctx)
	case round.FieldNumOfIntendedChecks:
		return m.OldNumOfIntendedChecks(ctx)
	case round.FieldStatus:
		return m.OldStatus(ctx)
	case round.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case round.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Round field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoundMutation) SetField(name string, value ent.Value) error {
	switch name {
	case round.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case round.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case round.FieldRoundNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoundNumber(v)
		return nil
	case round.FieldNumOfIntendedChecks:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumOfIntendedChecks(v)
		return nil
	case round.FieldStatus:
		v, ok := value.(round.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case round.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case round.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Round field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoundMutation) AddedFields() []string {
	var fields []string
	if m.addround_number != nil {
		fields = append(fields, round.FieldRoundNumber)
	}
	if m.addnum_of_intended_checks != nil {
		fields = append(fields, round.FieldNumOfIntendedChecks)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoundMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case round.FieldRoundNumber:
		return m.AddedRoundNumber()
	case round.FieldNumOfIntendedChecks:
		return m.AddedNumOfIntendedChecks()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoundMutation) AddField(name string, value ent.Value) error {
	switch name {
	case round.FieldRoundNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoundNumber(v)
		return nil
	case round.FieldNumOfIntendedChecks:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumOfIntendedChecks(v)
		return nil
	}
	return fmt.Errorf("unknown Round numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoundMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(round.FieldCreateTime) {
		fields = append(fields, round.FieldCreateTime)
	}
	if m.FieldCleared(round.FieldUpdateTime) {
		fields = append(fields, round.FieldUpdateTime)
	}
	if m.FieldCleared(round.FieldNumOfIntendedChecks) {
		fields = append(fields, round.FieldNumOfIntendedChecks)
	}
	if m.FieldCleared(round.FieldFinishedAt) {
		fields = append(fields, round.FieldFinishedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoundMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoundMutation) ClearField(name string) error {
	switch name {
	case round.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case round.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case round.FieldNumOfIntendedChecks:
		m.ClearNumOfIntendedChecks()
		return nil
	case round.FieldFinishedAt:
		m.ClearFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown Round nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoundMutation) ResetField(name string) error {
	switch name {
	case round.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case round.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case round.FieldRoundNumber:
		m.ResetRoundNumber()
		return nil
	case round.FieldNumOfIntendedChecks:
		m.ResetNumOfIntendedChecks()
		return nil
	case round.FieldStatus:
		m.ResetStatus()
		return nil
	case round.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case round.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown Round field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoundMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.checks != nil {
		edges = append(edges, round.EdgeChecks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoundMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case round.EdgeChecks:
		ids := make([]ent.Value, 0, len(m.checks))
		for id := range m.checks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoundMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedchecks != nil {
		edges = append(edges, round.EdgeChecks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoundMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case round.EdgeChecks:
		ids := make([]ent.Value, 0, len(m.removedchecks))
		for id := range m.removedchecks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoundMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedchecks {
		edges = append(edges, round.EdgeChecks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoundMutation) EdgeCleared(name string) bool {
	switch name {
	case round.EdgeChecks:
		return m.clearedchecks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoundMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Round unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoundMutation) ResetEdge(name string) error {
	switch name {
	case round.EdgeChecks:
		m.ResetChecks()
		return nil
	}
	return fmt.Errorf("unknown Round edge %s", name)
}

// ServiceMutation represents an operation that mutates the Service nodes in the graph.
type ServiceMutation struct {
	config
	op                        Op
	typ                       string
	id                        *string
	name                      *string
	display_name              *string
	pause                     *bool
	hidden                    *bool
	create_time               *time.Time
	update_time               *time.Time
	_type                     *scorer.ServiceType
	weight                    *int
	addweight                 *int
	point_boost               *int
	addpoint_boost            *int
	round_frequency           *int
	addround_frequency        *int
	round_delay               *int
	addround_delay            *int
	clearedFields             map[string]struct{}
	hostservices              map[string]struct{}
	removedhostservices       map[string]struct{}
	clearedhostservices       bool
	hostservicereports        map[string]struct{}
	removedhostservicereports map[string]struct{}
	clearedhostservicereports bool
	done                      bool
	oldValue                  func(context.Context) (*Service, error)
	predicates                []predicate.Service
}

var _ ent.Mutation = (*ServiceMutation)(nil)

// serviceOption allows management of the mutation configuration using functional options.
type serviceOption func(*ServiceMutation)

// newServiceMutation creates new mutation for the Service entity.
func newServiceMutation(c config, op Op, opts ...serviceOption) *ServiceMutation {
	m := &ServiceMutation{
		config:        c,
		op:            op,
		typ:           TypeService,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceID sets the ID field of the mutation.
func withServiceID(id string) serviceOption {
	return func(m *ServiceMutation) {
		var (
			err   error
			once  sync.Once
			value *Service
		)
		m.oldValue = func(ctx context.Context) (*Service, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Service.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withService sets the old Service of the mutation.
func withService(node *Service) serviceOption {
	return func(m *ServiceMutation) {
		m.oldValue = func(context.Context) (*Service, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entities: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Service entities.
func (m *ServiceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Service.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ServiceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ServiceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ServiceMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *ServiceMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ServiceMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ServiceMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetPause sets the "pause" field.
func (m *ServiceMutation) SetPause(b bool) {
	m.pause = &b
}

// Pause returns the value of the "pause" field in the mutation.
func (m *ServiceMutation) Pause() (r bool, exists bool) {
	v := m.pause
	if v == nil {
		return
	}
	return *v, true
}

// OldPause returns the old "pause" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldPause(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPause is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPause requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPause: %w", err)
	}
	return oldValue.Pause, nil
}

// ClearPause clears the value of the "pause" field.
func (m *ServiceMutation) ClearPause() {
	m.pause = nil
	m.clearedFields[service.FieldPause] = struct{}{}
}

// PauseCleared returns if the "pause" field was cleared in this mutation.
func (m *ServiceMutation) PauseCleared() bool {
	_, ok := m.clearedFields[service.FieldPause]
	return ok
}

// ResetPause resets all changes to the "pause" field.
func (m *ServiceMutation) ResetPause() {
	m.pause = nil
	delete(m.clearedFields, service.FieldPause)
}

// SetHidden sets the "hidden" field.
func (m *ServiceMutation) SetHidden(b bool) {
	m.hidden = &b
}

// Hidden returns the value of the "hidden" field in the mutation.
func (m *ServiceMutation) Hidden() (r bool, exists bool) {
	v := m.hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldHidden returns the old "hidden" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHidden: %w", err)
	}
	return oldValue.Hidden, nil
}

// ClearHidden clears the value of the "hidden" field.
func (m *ServiceMutation) ClearHidden() {
	m.hidden = nil
	m.clearedFields[service.FieldHidden] = struct{}{}
}

// HiddenCleared returns if the "hidden" field was cleared in this mutation.
func (m *ServiceMutation) HiddenCleared() bool {
	_, ok := m.clearedFields[service.FieldHidden]
	return ok
}

// ResetHidden resets all changes to the "hidden" field.
func (m *ServiceMutation) ResetHidden() {
	m.hidden = nil
	delete(m.clearedFields, service.FieldHidden)
}

// SetCreateTime sets the "create_time" field.
func (m *ServiceMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ServiceMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *ServiceMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[service.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *ServiceMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[service.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ServiceMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, service.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *ServiceMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ServiceMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *ServiceMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[service.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *ServiceMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[service.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ServiceMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, service.FieldUpdateTime)
}

// SetType sets the "type" field.
func (m *ServiceMutation) SetType(st scorer.ServiceType) {
	m._type = &st
}

// GetType returns the value of the "type" field in the mutation.
func (m *ServiceMutation) GetType() (r scorer.ServiceType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldType(ctx context.Context) (v scorer.ServiceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ServiceMutation) ResetType() {
	m._type = nil
}

// SetWeight sets the "weight" field.
func (m *ServiceMutation) SetWeight(i int) {
	m.weight = &i
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *ServiceMutation) Weight() (r int, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds i to the "weight" field.
func (m *ServiceMutation) AddWeight(i int) {
	if m.addweight != nil {
		*m.addweight += i
	} else {
		m.addweight = &i
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *ServiceMutation) AddedWeight() (r int, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight resets all changes to the "weight" field.
func (m *ServiceMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// SetPointBoost sets the "point_boost" field.
func (m *ServiceMutation) SetPointBoost(i int) {
	m.point_boost = &i
	m.addpoint_boost = nil
}

// PointBoost returns the value of the "point_boost" field in the mutation.
func (m *ServiceMutation) PointBoost() (r int, exists bool) {
	v := m.point_boost
	if v == nil {
		return
	}
	return *v, true
}

// OldPointBoost returns the old "point_boost" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldPointBoost(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPointBoost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPointBoost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPointBoost: %w", err)
	}
	return oldValue.PointBoost, nil
}

// AddPointBoost adds i to the "point_boost" field.
func (m *ServiceMutation) AddPointBoost(i int) {
	if m.addpoint_boost != nil {
		*m.addpoint_boost += i
	} else {
		m.addpoint_boost = &i
	}
}

// AddedPointBoost returns the value that was added to the "point_boost" field in this mutation.
func (m *ServiceMutation) AddedPointBoost() (r int, exists bool) {
	v := m.addpoint_boost
	if v == nil {
		return
	}
	return *v, true
}

// ResetPointBoost resets all changes to the "point_boost" field.
func (m *ServiceMutation) ResetPointBoost() {
	m.point_boost = nil
	m.addpoint_boost = nil
}

// SetRoundFrequency sets the "round_frequency" field.
func (m *ServiceMutation) SetRoundFrequency(i int) {
	m.round_frequency = &i
	m.addround_frequency = nil
}

// RoundFrequency returns the value of the "round_frequency" field in the mutation.
func (m *ServiceMutation) RoundFrequency() (r int, exists bool) {
	v := m.round_frequency
	if v == nil {
		return
	}
	return *v, true
}

// OldRoundFrequency returns the old "round_frequency" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldRoundFrequency(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoundFrequency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoundFrequency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoundFrequency: %w", err)
	}
	return oldValue.RoundFrequency, nil
}

// AddRoundFrequency adds i to the "round_frequency" field.
func (m *ServiceMutation) AddRoundFrequency(i int) {
	if m.addround_frequency != nil {
		*m.addround_frequency += i
	} else {
		m.addround_frequency = &i
	}
}

// AddedRoundFrequency returns the value that was added to the "round_frequency" field in this mutation.
func (m *ServiceMutation) AddedRoundFrequency() (r int, exists bool) {
	v := m.addround_frequency
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoundFrequency resets all changes to the "round_frequency" field.
func (m *ServiceMutation) ResetRoundFrequency() {
	m.round_frequency = nil
	m.addround_frequency = nil
}

// SetRoundDelay sets the "round_delay" field.
func (m *ServiceMutation) SetRoundDelay(i int) {
	m.round_delay = &i
	m.addround_delay = nil
}

// RoundDelay returns the value of the "round_delay" field in the mutation.
func (m *ServiceMutation) RoundDelay() (r int, exists bool) {
	v := m.round_delay
	if v == nil {
		return
	}
	return *v, true
}

// OldRoundDelay returns the old "round_delay" field's value of the Service entity.
// If the Service object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceMutation) OldRoundDelay(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoundDelay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoundDelay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoundDelay: %w", err)
	}
	return oldValue.RoundDelay, nil
}

// AddRoundDelay adds i to the "round_delay" field.
func (m *ServiceMutation) AddRoundDelay(i int) {
	if m.addround_delay != nil {
		*m.addround_delay += i
	} else {
		m.addround_delay = &i
	}
}

// AddedRoundDelay returns the value that was added to the "round_delay" field in this mutation.
func (m *ServiceMutation) AddedRoundDelay() (r int, exists bool) {
	v := m.addround_delay
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoundDelay resets all changes to the "round_delay" field.
func (m *ServiceMutation) ResetRoundDelay() {
	m.round_delay = nil
	m.addround_delay = nil
}

// AddHostserviceIDs adds the "hostservices" edge to the HostService entity by ids.
func (m *ServiceMutation) AddHostserviceIDs(ids ...string) {
	if m.hostservices == nil {
		m.hostservices = make(map[string]struct{})
	}
	for i := range ids {
		m.hostservices[ids[i]] = struct{}{}
	}
}

// ClearHostservices clears the "hostservices" edge to the HostService entity.
func (m *ServiceMutation) ClearHostservices() {
	m.clearedhostservices = true
}

// HostservicesCleared reports if the "hostservices" edge to the HostService entity was cleared.
func (m *ServiceMutation) HostservicesCleared() bool {
	return m.clearedhostservices
}

// RemoveHostserviceIDs removes the "hostservices" edge to the HostService entity by IDs.
func (m *ServiceMutation) RemoveHostserviceIDs(ids ...string) {
	if m.removedhostservices == nil {
		m.removedhostservices = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hostservices, ids[i])
		m.removedhostservices[ids[i]] = struct{}{}
	}
}

// RemovedHostservices returns the removed IDs of the "hostservices" edge to the HostService entity.
func (m *ServiceMutation) RemovedHostservicesIDs() (ids []string) {
	for id := range m.removedhostservices {
		ids = append(ids, id)
	}
	return
}

// HostservicesIDs returns the "hostservices" edge IDs in the mutation.
func (m *ServiceMutation) HostservicesIDs() (ids []string) {
	for id := range m.hostservices {
		ids = append(ids, id)
	}
	return
}

// ResetHostservices resets all changes to the "hostservices" edge.
func (m *ServiceMutation) ResetHostservices() {
	m.hostservices = nil
	m.clearedhostservices = false
	m.removedhostservices = nil
}

// AddHostservicereportIDs adds the "hostservicereports" edge to the HostServiceReport entity by ids.
func (m *ServiceMutation) AddHostservicereportIDs(ids ...string) {
	if m.hostservicereports == nil {
		m.hostservicereports = make(map[string]struct{})
	}
	for i := range ids {
		m.hostservicereports[ids[i]] = struct{}{}
	}
}

// ClearHostservicereports clears the "hostservicereports" edge to the HostServiceReport entity.
func (m *ServiceMutation) ClearHostservicereports() {
	m.clearedhostservicereports = true
}

// HostservicereportsCleared reports if the "hostservicereports" edge to the HostServiceReport entity was cleared.
func (m *ServiceMutation) HostservicereportsCleared() bool {
	return m.clearedhostservicereports
}

// RemoveHostservicereportIDs removes the "hostservicereports" edge to the HostServiceReport entity by IDs.
func (m *ServiceMutation) RemoveHostservicereportIDs(ids ...string) {
	if m.removedhostservicereports == nil {
		m.removedhostservicereports = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hostservicereports, ids[i])
		m.removedhostservicereports[ids[i]] = struct{}{}
	}
}

// RemovedHostservicereports returns the removed IDs of the "hostservicereports" edge to the HostServiceReport entity.
func (m *ServiceMutation) RemovedHostservicereportsIDs() (ids []string) {
	for id := range m.removedhostservicereports {
		ids = append(ids, id)
	}
	return
}

// HostservicereportsIDs returns the "hostservicereports" edge IDs in the mutation.
func (m *ServiceMutation) HostservicereportsIDs() (ids []string) {
	for id := range m.hostservicereports {
		ids = append(ids, id)
	}
	return
}

// ResetHostservicereports resets all changes to the "hostservicereports" edge.
func (m *ServiceMutation) ResetHostservicereports() {
	m.hostservicereports = nil
	m.clearedhostservicereports = false
	m.removedhostservicereports = nil
}

// Where appends a list predicates to the ServiceMutation builder.
func (m *ServiceMutation) Where(ps ...predicate.Service) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Service, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Service).
func (m *ServiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.name != nil {
		fields = append(fields, service.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, service.FieldDisplayName)
	}
	if m.pause != nil {
		fields = append(fields, service.FieldPause)
	}
	if m.hidden != nil {
		fields = append(fields, service.FieldHidden)
	}
	if m.create_time != nil {
		fields = append(fields, service.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, service.FieldUpdateTime)
	}
	if m._type != nil {
		fields = append(fields, service.FieldType)
	}
	if m.weight != nil {
		fields = append(fields, service.FieldWeight)
	}
	if m.point_boost != nil {
		fields = append(fields, service.FieldPointBoost)
	}
	if m.round_frequency != nil {
		fields = append(fields, service.FieldRoundFrequency)
	}
	if m.round_delay != nil {
		fields = append(fields, service.FieldRoundDelay)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case service.FieldName:
		return m.Name()
	case service.FieldDisplayName:
		return m.DisplayName()
	case service.FieldPause:
		return m.Pause()
	case service.FieldHidden:
		return m.Hidden()
	case service.FieldCreateTime:
		return m.CreateTime()
	case service.FieldUpdateTime:
		return m.UpdateTime()
	case service.FieldType:
		return m.GetType()
	case service.FieldWeight:
		return m.Weight()
	case service.FieldPointBoost:
		return m.PointBoost()
	case service.FieldRoundFrequency:
		return m.RoundFrequency()
	case service.FieldRoundDelay:
		return m.RoundDelay()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case service.FieldName:
		return m.OldName(ctx)
	case service.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case service.FieldPause:
		return m.OldPause(ctx)
	case service.FieldHidden:
		return m.OldHidden(ctx)
	case service.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case service.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case service.FieldType:
		return m.OldType(ctx)
	case service.FieldWeight:
		return m.OldWeight(ctx)
	case service.FieldPointBoost:
		return m.OldPointBoost(ctx)
	case service.FieldRoundFrequency:
		return m.OldRoundFrequency(ctx)
	case service.FieldRoundDelay:
		return m.OldRoundDelay(ctx)
	}
	return nil, fmt.Errorf("unknown Service field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case service.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case service.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case service.FieldPause:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPause(v)
		return nil
	case service.FieldHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHidden(v)
		return nil
	case service.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case service.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case service.FieldType:
		v, ok := value.(scorer.ServiceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case service.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case service.FieldPointBoost:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPointBoost(v)
		return nil
	case service.FieldRoundFrequency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoundFrequency(v)
		return nil
	case service.FieldRoundDelay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoundDelay(v)
		return nil
	}
	return fmt.Errorf("unknown Service field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceMutation) AddedFields() []string {
	var fields []string
	if m.addweight != nil {
		fields = append(fields, service.FieldWeight)
	}
	if m.addpoint_boost != nil {
		fields = append(fields, service.FieldPointBoost)
	}
	if m.addround_frequency != nil {
		fields = append(fields, service.FieldRoundFrequency)
	}
	if m.addround_delay != nil {
		fields = append(fields, service.FieldRoundDelay)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case service.FieldWeight:
		return m.AddedWeight()
	case service.FieldPointBoost:
		return m.AddedPointBoost()
	case service.FieldRoundFrequency:
		return m.AddedRoundFrequency()
	case service.FieldRoundDelay:
		return m.AddedRoundDelay()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case service.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	case service.FieldPointBoost:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPointBoost(v)
		return nil
	case service.FieldRoundFrequency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoundFrequency(v)
		return nil
	case service.FieldRoundDelay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoundDelay(v)
		return nil
	}
	return fmt.Errorf("unknown Service numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(service.FieldPause) {
		fields = append(fields, service.FieldPause)
	}
	if m.FieldCleared(service.FieldHidden) {
		fields = append(fields, service.FieldHidden)
	}
	if m.FieldCleared(service.FieldCreateTime) {
		fields = append(fields, service.FieldCreateTime)
	}
	if m.FieldCleared(service.FieldUpdateTime) {
		fields = append(fields, service.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceMutation) ClearField(name string) error {
	switch name {
	case service.FieldPause:
		m.ClearPause()
		return nil
	case service.FieldHidden:
		m.ClearHidden()
		return nil
	case service.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case service.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Service nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceMutation) ResetField(name string) error {
	switch name {
	case service.FieldName:
		m.ResetName()
		return nil
	case service.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case service.FieldPause:
		m.ResetPause()
		return nil
	case service.FieldHidden:
		m.ResetHidden()
		return nil
	case service.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case service.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case service.FieldType:
		m.ResetType()
		return nil
	case service.FieldWeight:
		m.ResetWeight()
		return nil
	case service.FieldPointBoost:
		m.ResetPointBoost()
		return nil
	case service.FieldRoundFrequency:
		m.ResetRoundFrequency()
		return nil
	case service.FieldRoundDelay:
		m.ResetRoundDelay()
		return nil
	}
	return fmt.Errorf("unknown Service field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.hostservices != nil {
		edges = append(edges, service.EdgeHostservices)
	}
	if m.hostservicereports != nil {
		edges = append(edges, service.EdgeHostservicereports)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case service.EdgeHostservices:
		ids := make([]ent.Value, 0, len(m.hostservices))
		for id := range m.hostservices {
			ids = append(ids, id)
		}
		return ids
	case service.EdgeHostservicereports:
		ids := make([]ent.Value, 0, len(m.hostservicereports))
		for id := range m.hostservicereports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedhostservices != nil {
		edges = append(edges, service.EdgeHostservices)
	}
	if m.removedhostservicereports != nil {
		edges = append(edges, service.EdgeHostservicereports)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case service.EdgeHostservices:
		ids := make([]ent.Value, 0, len(m.removedhostservices))
		for id := range m.removedhostservices {
			ids = append(ids, id)
		}
		return ids
	case service.EdgeHostservicereports:
		ids := make([]ent.Value, 0, len(m.removedhostservicereports))
		for id := range m.removedhostservicereports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedhostservices {
		edges = append(edges, service.EdgeHostservices)
	}
	if m.clearedhostservicereports {
		edges = append(edges, service.EdgeHostservicereports)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceMutation) EdgeCleared(name string) bool {
	switch name {
	case service.EdgeHostservices:
		return m.clearedhostservices
	case service.EdgeHostservicereports:
		return m.clearedhostservicereports
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Service unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceMutation) ResetEdge(name string) error {
	switch name {
	case service.EdgeHostservices:
		m.ResetHostservices()
		return nil
	case service.EdgeHostservicereports:
		m.ResetHostservicereports()
		return nil
	}
	return fmt.Errorf("unknown Service edge %s", name)
}

// TeamMutation represents an operation that mutates the Team nodes in the graph.
type TeamMutation struct {
	config
	op                        Op
	typ                       string
	id                        *string
	name                      *string
	display_name              *string
	pause                     *bool
	hidden                    *bool
	create_time               *time.Time
	update_time               *time.Time
	number                    *int
	addnumber                 *int
	clearedFields             map[string]struct{}
	hosts                     map[string]struct{}
	removedhosts              map[string]struct{}
	clearedhosts              bool
	hostservices              map[string]struct{}
	removedhostservices       map[string]struct{}
	clearedhostservices       bool
	teamreport                *string
	clearedteamreport         bool
	hostservicereports        map[string]struct{}
	removedhostservicereports map[string]struct{}
	clearedhostservicereports bool
	done                      bool
	oldValue                  func(context.Context) (*Team, error)
	predicates                []predicate.Team
}

var _ ent.Mutation = (*TeamMutation)(nil)

// teamOption allows management of the mutation configuration using functional options.
type teamOption func(*TeamMutation)

// newTeamMutation creates new mutation for the Team entity.
func newTeamMutation(c config, op Op, opts ...teamOption) *TeamMutation {
	m := &TeamMutation{
		config:        c,
		op:            op,
		typ:           TypeTeam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamID sets the ID field of the mutation.
func withTeamID(id string) teamOption {
	return func(m *TeamMutation) {
		var (
			err   error
			once  sync.Once
			value *Team
		)
		m.oldValue = func(ctx context.Context) (*Team, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Team.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeam sets the old Team of the mutation.
func withTeam(node *Team) teamOption {
	return func(m *TeamMutation) {
		m.oldValue = func(context.Context) (*Team, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entities: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Team entities.
func (m *TeamMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Team.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TeamMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeamMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeamMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *TeamMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *TeamMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *TeamMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetPause sets the "pause" field.
func (m *TeamMutation) SetPause(b bool) {
	m.pause = &b
}

// Pause returns the value of the "pause" field in the mutation.
func (m *TeamMutation) Pause() (r bool, exists bool) {
	v := m.pause
	if v == nil {
		return
	}
	return *v, true
}

// OldPause returns the old "pause" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldPause(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPause is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPause requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPause: %w", err)
	}
	return oldValue.Pause, nil
}

// ClearPause clears the value of the "pause" field.
func (m *TeamMutation) ClearPause() {
	m.pause = nil
	m.clearedFields[team.FieldPause] = struct{}{}
}

// PauseCleared returns if the "pause" field was cleared in this mutation.
func (m *TeamMutation) PauseCleared() bool {
	_, ok := m.clearedFields[team.FieldPause]
	return ok
}

// ResetPause resets all changes to the "pause" field.
func (m *TeamMutation) ResetPause() {
	m.pause = nil
	delete(m.clearedFields, team.FieldPause)
}

// SetHidden sets the "hidden" field.
func (m *TeamMutation) SetHidden(b bool) {
	m.hidden = &b
}

// Hidden returns the value of the "hidden" field in the mutation.
func (m *TeamMutation) Hidden() (r bool, exists bool) {
	v := m.hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldHidden returns the old "hidden" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHidden: %w", err)
	}
	return oldValue.Hidden, nil
}

// ClearHidden clears the value of the "hidden" field.
func (m *TeamMutation) ClearHidden() {
	m.hidden = nil
	m.clearedFields[team.FieldHidden] = struct{}{}
}

// HiddenCleared returns if the "hidden" field was cleared in this mutation.
func (m *TeamMutation) HiddenCleared() bool {
	_, ok := m.clearedFields[team.FieldHidden]
	return ok
}

// ResetHidden resets all changes to the "hidden" field.
func (m *TeamMutation) ResetHidden() {
	m.hidden = nil
	delete(m.clearedFields, team.FieldHidden)
}

// SetCreateTime sets the "create_time" field.
func (m *TeamMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TeamMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *TeamMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[team.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *TeamMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[team.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TeamMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, team.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *TeamMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TeamMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *TeamMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[team.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *TeamMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[team.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TeamMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, team.FieldUpdateTime)
}

// SetNumber sets the "number" field.
func (m *TeamMutation) SetNumber(i int) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *TeamMutation) Number() (r int, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to the "number" field.
func (m *TeamMutation) AddNumber(i int) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *TeamMutation) AddedNumber() (r int, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber resets all changes to the "number" field.
func (m *TeamMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
}

// AddHostIDs adds the "hosts" edge to the Host entity by ids.
func (m *TeamMutation) AddHostIDs(ids ...string) {
	if m.hosts == nil {
		m.hosts = make(map[string]struct{})
	}
	for i := range ids {
		m.hosts[ids[i]] = struct{}{}
	}
}

// ClearHosts clears the "hosts" edge to the Host entity.
func (m *TeamMutation) ClearHosts() {
	m.clearedhosts = true
}

// HostsCleared reports if the "hosts" edge to the Host entity was cleared.
func (m *TeamMutation) HostsCleared() bool {
	return m.clearedhosts
}

// RemoveHostIDs removes the "hosts" edge to the Host entity by IDs.
func (m *TeamMutation) RemoveHostIDs(ids ...string) {
	if m.removedhosts == nil {
		m.removedhosts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hosts, ids[i])
		m.removedhosts[ids[i]] = struct{}{}
	}
}

// RemovedHosts returns the removed IDs of the "hosts" edge to the Host entity.
func (m *TeamMutation) RemovedHostsIDs() (ids []string) {
	for id := range m.removedhosts {
		ids = append(ids, id)
	}
	return
}

// HostsIDs returns the "hosts" edge IDs in the mutation.
func (m *TeamMutation) HostsIDs() (ids []string) {
	for id := range m.hosts {
		ids = append(ids, id)
	}
	return
}

// ResetHosts resets all changes to the "hosts" edge.
func (m *TeamMutation) ResetHosts() {
	m.hosts = nil
	m.clearedhosts = false
	m.removedhosts = nil
}

// AddHostserviceIDs adds the "hostservices" edge to the HostService entity by ids.
func (m *TeamMutation) AddHostserviceIDs(ids ...string) {
	if m.hostservices == nil {
		m.hostservices = make(map[string]struct{})
	}
	for i := range ids {
		m.hostservices[ids[i]] = struct{}{}
	}
}

// ClearHostservices clears the "hostservices" edge to the HostService entity.
func (m *TeamMutation) ClearHostservices() {
	m.clearedhostservices = true
}

// HostservicesCleared reports if the "hostservices" edge to the HostService entity was cleared.
func (m *TeamMutation) HostservicesCleared() bool {
	return m.clearedhostservices
}

// RemoveHostserviceIDs removes the "hostservices" edge to the HostService entity by IDs.
func (m *TeamMutation) RemoveHostserviceIDs(ids ...string) {
	if m.removedhostservices == nil {
		m.removedhostservices = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hostservices, ids[i])
		m.removedhostservices[ids[i]] = struct{}{}
	}
}

// RemovedHostservices returns the removed IDs of the "hostservices" edge to the HostService entity.
func (m *TeamMutation) RemovedHostservicesIDs() (ids []string) {
	for id := range m.removedhostservices {
		ids = append(ids, id)
	}
	return
}

// HostservicesIDs returns the "hostservices" edge IDs in the mutation.
func (m *TeamMutation) HostservicesIDs() (ids []string) {
	for id := range m.hostservices {
		ids = append(ids, id)
	}
	return
}

// ResetHostservices resets all changes to the "hostservices" edge.
func (m *TeamMutation) ResetHostservices() {
	m.hostservices = nil
	m.clearedhostservices = false
	m.removedhostservices = nil
}

// SetTeamreportID sets the "teamreport" edge to the TeamReport entity by id.
func (m *TeamMutation) SetTeamreportID(id string) {
	m.teamreport = &id
}

// ClearTeamreport clears the "teamreport" edge to the TeamReport entity.
func (m *TeamMutation) ClearTeamreport() {
	m.clearedteamreport = true
}

// TeamreportCleared reports if the "teamreport" edge to the TeamReport entity was cleared.
func (m *TeamMutation) TeamreportCleared() bool {
	return m.clearedteamreport
}

// TeamreportID returns the "teamreport" edge ID in the mutation.
func (m *TeamMutation) TeamreportID() (id string, exists bool) {
	if m.teamreport != nil {
		return *m.teamreport, true
	}
	return
}

// TeamreportIDs returns the "teamreport" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamreportID instead. It exists only for internal usage by the builders.
func (m *TeamMutation) TeamreportIDs() (ids []string) {
	if id := m.teamreport; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeamreport resets all changes to the "teamreport" edge.
func (m *TeamMutation) ResetTeamreport() {
	m.teamreport = nil
	m.clearedteamreport = false
}

// AddHostservicereportIDs adds the "hostservicereports" edge to the HostServiceReport entity by ids.
func (m *TeamMutation) AddHostservicereportIDs(ids ...string) {
	if m.hostservicereports == nil {
		m.hostservicereports = make(map[string]struct{})
	}
	for i := range ids {
		m.hostservicereports[ids[i]] = struct{}{}
	}
}

// ClearHostservicereports clears the "hostservicereports" edge to the HostServiceReport entity.
func (m *TeamMutation) ClearHostservicereports() {
	m.clearedhostservicereports = true
}

// HostservicereportsCleared reports if the "hostservicereports" edge to the HostServiceReport entity was cleared.
func (m *TeamMutation) HostservicereportsCleared() bool {
	return m.clearedhostservicereports
}

// RemoveHostservicereportIDs removes the "hostservicereports" edge to the HostServiceReport entity by IDs.
func (m *TeamMutation) RemoveHostservicereportIDs(ids ...string) {
	if m.removedhostservicereports == nil {
		m.removedhostservicereports = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hostservicereports, ids[i])
		m.removedhostservicereports[ids[i]] = struct{}{}
	}
}

// RemovedHostservicereports returns the removed IDs of the "hostservicereports" edge to the HostServiceReport entity.
func (m *TeamMutation) RemovedHostservicereportsIDs() (ids []string) {
	for id := range m.removedhostservicereports {
		ids = append(ids, id)
	}
	return
}

// HostservicereportsIDs returns the "hostservicereports" edge IDs in the mutation.
func (m *TeamMutation) HostservicereportsIDs() (ids []string) {
	for id := range m.hostservicereports {
		ids = append(ids, id)
	}
	return
}

// ResetHostservicereports resets all changes to the "hostservicereports" edge.
func (m *TeamMutation) ResetHostservicereports() {
	m.hostservicereports = nil
	m.clearedhostservicereports = false
	m.removedhostservicereports = nil
}

// Where appends a list predicates to the TeamMutation builder.
func (m *TeamMutation) Where(ps ...predicate.Team) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Team, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Team).
func (m *TeamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, team.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, team.FieldDisplayName)
	}
	if m.pause != nil {
		fields = append(fields, team.FieldPause)
	}
	if m.hidden != nil {
		fields = append(fields, team.FieldHidden)
	}
	if m.create_time != nil {
		fields = append(fields, team.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, team.FieldUpdateTime)
	}
	if m.number != nil {
		fields = append(fields, team.FieldNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case team.FieldName:
		return m.Name()
	case team.FieldDisplayName:
		return m.DisplayName()
	case team.FieldPause:
		return m.Pause()
	case team.FieldHidden:
		return m.Hidden()
	case team.FieldCreateTime:
		return m.CreateTime()
	case team.FieldUpdateTime:
		return m.UpdateTime()
	case team.FieldNumber:
		return m.Number()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case team.FieldName:
		return m.OldName(ctx)
	case team.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case team.FieldPause:
		return m.OldPause(ctx)
	case team.FieldHidden:
		return m.OldHidden(ctx)
	case team.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case team.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case team.FieldNumber:
		return m.OldNumber(ctx)
	}
	return nil, fmt.Errorf("unknown Team field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case team.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case team.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case team.FieldPause:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPause(v)
		return nil
	case team.FieldHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHidden(v)
		return nil
	case team.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case team.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case team.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamMutation) AddedFields() []string {
	var fields []string
	if m.addnumber != nil {
		fields = append(fields, team.FieldNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case team.FieldNumber:
		return m.AddedNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) AddField(name string, value ent.Value) error {
	switch name {
	case team.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Team numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(team.FieldPause) {
		fields = append(fields, team.FieldPause)
	}
	if m.FieldCleared(team.FieldHidden) {
		fields = append(fields, team.FieldHidden)
	}
	if m.FieldCleared(team.FieldCreateTime) {
		fields = append(fields, team.FieldCreateTime)
	}
	if m.FieldCleared(team.FieldUpdateTime) {
		fields = append(fields, team.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamMutation) ClearField(name string) error {
	switch name {
	case team.FieldPause:
		m.ClearPause()
		return nil
	case team.FieldHidden:
		m.ClearHidden()
		return nil
	case team.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case team.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Team nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamMutation) ResetField(name string) error {
	switch name {
	case team.FieldName:
		m.ResetName()
		return nil
	case team.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case team.FieldPause:
		m.ResetPause()
		return nil
	case team.FieldHidden:
		m.ResetHidden()
		return nil
	case team.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case team.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case team.FieldNumber:
		m.ResetNumber()
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.hosts != nil {
		edges = append(edges, team.EdgeHosts)
	}
	if m.hostservices != nil {
		edges = append(edges, team.EdgeHostservices)
	}
	if m.teamreport != nil {
		edges = append(edges, team.EdgeTeamreport)
	}
	if m.hostservicereports != nil {
		edges = append(edges, team.EdgeHostservicereports)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeHosts:
		ids := make([]ent.Value, 0, len(m.hosts))
		for id := range m.hosts {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeHostservices:
		ids := make([]ent.Value, 0, len(m.hostservices))
		for id := range m.hostservices {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeTeamreport:
		if id := m.teamreport; id != nil {
			return []ent.Value{*id}
		}
	case team.EdgeHostservicereports:
		ids := make([]ent.Value, 0, len(m.hostservicereports))
		for id := range m.hostservicereports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedhosts != nil {
		edges = append(edges, team.EdgeHosts)
	}
	if m.removedhostservices != nil {
		edges = append(edges, team.EdgeHostservices)
	}
	if m.removedhostservicereports != nil {
		edges = append(edges, team.EdgeHostservicereports)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeHosts:
		ids := make([]ent.Value, 0, len(m.removedhosts))
		for id := range m.removedhosts {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeHostservices:
		ids := make([]ent.Value, 0, len(m.removedhostservices))
		for id := range m.removedhostservices {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeHostservicereports:
		ids := make([]ent.Value, 0, len(m.removedhostservicereports))
		for id := range m.removedhostservicereports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedhosts {
		edges = append(edges, team.EdgeHosts)
	}
	if m.clearedhostservices {
		edges = append(edges, team.EdgeHostservices)
	}
	if m.clearedteamreport {
		edges = append(edges, team.EdgeTeamreport)
	}
	if m.clearedhostservicereports {
		edges = append(edges, team.EdgeHostservicereports)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamMutation) EdgeCleared(name string) bool {
	switch name {
	case team.EdgeHosts:
		return m.clearedhosts
	case team.EdgeHostservices:
		return m.clearedhostservices
	case team.EdgeTeamreport:
		return m.clearedteamreport
	case team.EdgeHostservicereports:
		return m.clearedhostservicereports
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamMutation) ClearEdge(name string) error {
	switch name {
	case team.EdgeTeamreport:
		m.ClearTeamreport()
		return nil
	}
	return fmt.Errorf("unknown Team unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamMutation) ResetEdge(name string) error {
	switch name {
	case team.EdgeHosts:
		m.ResetHosts()
		return nil
	case team.EdgeHostservices:
		m.ResetHostservices()
		return nil
	case team.EdgeTeamreport:
		m.ResetTeamreport()
		return nil
	case team.EdgeHostservicereports:
		m.ResetHostservicereports()
		return nil
	}
	return fmt.Errorf("unknown Team edge %s", name)
}

// TeamReportMutation represents an operation that mutates the TeamReport nodes in the graph.
type TeamReportMutation struct {
	config
	op                        Op
	typ                       string
	id                        *string
	create_time               *time.Time
	update_time               *time.Time
	points                    *int
	addpoints                 *int
	clearedFields             map[string]struct{}
	team                      *string
	clearedteam               bool
	hostservicereports        map[string]struct{}
	removedhostservicereports map[string]struct{}
	clearedhostservicereports bool
	done                      bool
	oldValue                  func(context.Context) (*TeamReport, error)
	predicates                []predicate.TeamReport
}

var _ ent.Mutation = (*TeamReportMutation)(nil)

// teamreportOption allows management of the mutation configuration using functional options.
type teamreportOption func(*TeamReportMutation)

// newTeamReportMutation creates new mutation for the TeamReport entity.
func newTeamReportMutation(c config, op Op, opts ...teamreportOption) *TeamReportMutation {
	m := &TeamReportMutation{
		config:        c,
		op:            op,
		typ:           TypeTeamReport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamReportID sets the ID field of the mutation.
func withTeamReportID(id string) teamreportOption {
	return func(m *TeamReportMutation) {
		var (
			err   error
			once  sync.Once
			value *TeamReport
		)
		m.oldValue = func(ctx context.Context) (*TeamReport, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TeamReport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeamReport sets the old TeamReport of the mutation.
func withTeamReport(node *TeamReport) teamreportOption {
	return func(m *TeamReportMutation) {
		m.oldValue = func(context.Context) (*TeamReport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamReportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamReportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entities: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TeamReport entities.
func (m *TeamReportMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamReportMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamReportMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TeamReport.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TeamReportMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TeamReportMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the TeamReport entity.
// If the TeamReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamReportMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *TeamReportMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[teamreport.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *TeamReportMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[teamreport.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TeamReportMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, teamreport.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *TeamReportMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TeamReportMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the TeamReport entity.
// If the TeamReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamReportMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *TeamReportMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[teamreport.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *TeamReportMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[teamreport.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TeamReportMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, teamreport.FieldUpdateTime)
}

// SetPoints sets the "points" field.
func (m *TeamReportMutation) SetPoints(i int) {
	m.points = &i
	m.addpoints = nil
}

// Points returns the value of the "points" field in the mutation.
func (m *TeamReportMutation) Points() (r int, exists bool) {
	v := m.points
	if v == nil {
		return
	}
	return *v, true
}

// OldPoints returns the old "points" field's value of the TeamReport entity.
// If the TeamReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamReportMutation) OldPoints(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoints: %w", err)
	}
	return oldValue.Points, nil
}

// AddPoints adds i to the "points" field.
func (m *TeamReportMutation) AddPoints(i int) {
	if m.addpoints != nil {
		*m.addpoints += i
	} else {
		m.addpoints = &i
	}
}

// AddedPoints returns the value that was added to the "points" field in this mutation.
func (m *TeamReportMutation) AddedPoints() (r int, exists bool) {
	v := m.addpoints
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoints resets all changes to the "points" field.
func (m *TeamReportMutation) ResetPoints() {
	m.points = nil
	m.addpoints = nil
}

// SetTeamID sets the "team_id" field.
func (m *TeamReportMutation) SetTeamID(s string) {
	m.team = &s
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *TeamReportMutation) TeamID() (r string, exists bool) {
	v := m.team
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the TeamReport entity.
// If the TeamReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamReportMutation) OldTeamID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *TeamReportMutation) ResetTeamID() {
	m.team = nil
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *TeamReportMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *TeamReportMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *TeamReportMutation) TeamIDs() (ids []string) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *TeamReportMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// AddHostservicereportIDs adds the "hostservicereports" edge to the HostServiceReport entity by ids.
func (m *TeamReportMutation) AddHostservicereportIDs(ids ...string) {
	if m.hostservicereports == nil {
		m.hostservicereports = make(map[string]struct{})
	}
	for i := range ids {
		m.hostservicereports[ids[i]] = struct{}{}
	}
}

// ClearHostservicereports clears the "hostservicereports" edge to the HostServiceReport entity.
func (m *TeamReportMutation) ClearHostservicereports() {
	m.clearedhostservicereports = true
}

// HostservicereportsCleared reports if the "hostservicereports" edge to the HostServiceReport entity was cleared.
func (m *TeamReportMutation) HostservicereportsCleared() bool {
	return m.clearedhostservicereports
}

// RemoveHostservicereportIDs removes the "hostservicereports" edge to the HostServiceReport entity by IDs.
func (m *TeamReportMutation) RemoveHostservicereportIDs(ids ...string) {
	if m.removedhostservicereports == nil {
		m.removedhostservicereports = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hostservicereports, ids[i])
		m.removedhostservicereports[ids[i]] = struct{}{}
	}
}

// RemovedHostservicereports returns the removed IDs of the "hostservicereports" edge to the HostServiceReport entity.
func (m *TeamReportMutation) RemovedHostservicereportsIDs() (ids []string) {
	for id := range m.removedhostservicereports {
		ids = append(ids, id)
	}
	return
}

// HostservicereportsIDs returns the "hostservicereports" edge IDs in the mutation.
func (m *TeamReportMutation) HostservicereportsIDs() (ids []string) {
	for id := range m.hostservicereports {
		ids = append(ids, id)
	}
	return
}

// ResetHostservicereports resets all changes to the "hostservicereports" edge.
func (m *TeamReportMutation) ResetHostservicereports() {
	m.hostservicereports = nil
	m.clearedhostservicereports = false
	m.removedhostservicereports = nil
}

// Where appends a list predicates to the TeamReportMutation builder.
func (m *TeamReportMutation) Where(ps ...predicate.TeamReport) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeamReportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeamReportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TeamReport, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeamReportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeamReportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TeamReport).
func (m *TeamReportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamReportMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, teamreport.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, teamreport.FieldUpdateTime)
	}
	if m.points != nil {
		fields = append(fields, teamreport.FieldPoints)
	}
	if m.team != nil {
		fields = append(fields, teamreport.FieldTeamID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamReportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case teamreport.FieldCreateTime:
		return m.CreateTime()
	case teamreport.FieldUpdateTime:
		return m.UpdateTime()
	case teamreport.FieldPoints:
		return m.Points()
	case teamreport.FieldTeamID:
		return m.TeamID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamReportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case teamreport.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case teamreport.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case teamreport.FieldPoints:
		return m.OldPoints(ctx)
	case teamreport.FieldTeamID:
		return m.OldTeamID(ctx)
	}
	return nil, fmt.Errorf("unknown TeamReport field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamReportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case teamreport.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case teamreport.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case teamreport.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoints(v)
		return nil
	case teamreport.FieldTeamID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	}
	return fmt.Errorf("unknown TeamReport field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamReportMutation) AddedFields() []string {
	var fields []string
	if m.addpoints != nil {
		fields = append(fields, teamreport.FieldPoints)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamReportMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case teamreport.FieldPoints:
		return m.AddedPoints()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamReportMutation) AddField(name string, value ent.Value) error {
	switch name {
	case teamreport.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoints(v)
		return nil
	}
	return fmt.Errorf("unknown TeamReport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamReportMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(teamreport.FieldCreateTime) {
		fields = append(fields, teamreport.FieldCreateTime)
	}
	if m.FieldCleared(teamreport.FieldUpdateTime) {
		fields = append(fields, teamreport.FieldUpdateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamReportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamReportMutation) ClearField(name string) error {
	switch name {
	case teamreport.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case teamreport.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown TeamReport nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamReportMutation) ResetField(name string) error {
	switch name {
	case teamreport.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case teamreport.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case teamreport.FieldPoints:
		m.ResetPoints()
		return nil
	case teamreport.FieldTeamID:
		m.ResetTeamID()
		return nil
	}
	return fmt.Errorf("unknown TeamReport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamReportMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.team != nil {
		edges = append(edges, teamreport.EdgeTeam)
	}
	if m.hostservicereports != nil {
		edges = append(edges, teamreport.EdgeHostservicereports)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamReportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case teamreport.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	case teamreport.EdgeHostservicereports:
		ids := make([]ent.Value, 0, len(m.hostservicereports))
		for id := range m.hostservicereports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamReportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedhostservicereports != nil {
		edges = append(edges, teamreport.EdgeHostservicereports)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamReportMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case teamreport.EdgeHostservicereports:
		ids := make([]ent.Value, 0, len(m.removedhostservicereports))
		for id := range m.removedhostservicereports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamReportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedteam {
		edges = append(edges, teamreport.EdgeTeam)
	}
	if m.clearedhostservicereports {
		edges = append(edges, teamreport.EdgeHostservicereports)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamReportMutation) EdgeCleared(name string) bool {
	switch name {
	case teamreport.EdgeTeam:
		return m.clearedteam
	case teamreport.EdgeHostservicereports:
		return m.clearedhostservicereports
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamReportMutation) ClearEdge(name string) error {
	switch name {
	case teamreport.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown TeamReport unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamReportMutation) ResetEdge(name string) error {
	switch name {
	case teamreport.EdgeTeam:
		m.ResetTeam()
		return nil
	case teamreport.EdgeHostservicereports:
		m.ResetHostservicereports()
		return nil
	}
	return fmt.Errorf("unknown TeamReport edge %s", name)
}
